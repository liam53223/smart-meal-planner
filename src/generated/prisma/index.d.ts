
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>
/**
 * Model HealthCondition
 * 
 */
export type HealthCondition = $Result.DefaultSelection<Prisma.$HealthConditionPayload>
/**
 * Model UserHealthCondition
 * 
 */
export type UserHealthCondition = $Result.DefaultSelection<Prisma.$UserHealthConditionPayload>
/**
 * Model Allergen
 * 
 */
export type Allergen = $Result.DefaultSelection<Prisma.$AllergenPayload>
/**
 * Model UserAllergy
 * 
 */
export type UserAllergy = $Result.DefaultSelection<Prisma.$UserAllergyPayload>
/**
 * Model Appliance
 * 
 */
export type Appliance = $Result.DefaultSelection<Prisma.$AppliancePayload>
/**
 * Model UserAppliance
 * 
 */
export type UserAppliance = $Result.DefaultSelection<Prisma.$UserAppliancePayload>
/**
 * Model UserBehavior
 * 
 */
export type UserBehavior = $Result.DefaultSelection<Prisma.$UserBehaviorPayload>
/**
 * Model SpiceBlend
 * 
 */
export type SpiceBlend = $Result.DefaultSelection<Prisma.$SpiceBlendPayload>
/**
 * Model RecipeSpiceBlend
 * 
 */
export type RecipeSpiceBlend = $Result.DefaultSelection<Prisma.$RecipeSpiceBlendPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model RecipeIngredient
 * 
 */
export type RecipeIngredient = $Result.DefaultSelection<Prisma.$RecipeIngredientPayload>
/**
 * Model RecipeInstruction
 * 
 */
export type RecipeInstruction = $Result.DefaultSelection<Prisma.$RecipeInstructionPayload>
/**
 * Model NutritionalInfo
 * 
 */
export type NutritionalInfo = $Result.DefaultSelection<Prisma.$NutritionalInfoPayload>
/**
 * Model MedicalTag
 * 
 */
export type MedicalTag = $Result.DefaultSelection<Prisma.$MedicalTagPayload>
/**
 * Model RecipeMedicalTag
 * 
 */
export type RecipeMedicalTag = $Result.DefaultSelection<Prisma.$RecipeMedicalTagPayload>
/**
 * Model DietaryTag
 * 
 */
export type DietaryTag = $Result.DefaultSelection<Prisma.$DietaryTagPayload>
/**
 * Model RecipeDietaryTag
 * 
 */
export type RecipeDietaryTag = $Result.DefaultSelection<Prisma.$RecipeDietaryTagPayload>
/**
 * Model PracticalTag
 * 
 */
export type PracticalTag = $Result.DefaultSelection<Prisma.$PracticalTagPayload>
/**
 * Model RecipePracticalTag
 * 
 */
export type RecipePracticalTag = $Result.DefaultSelection<Prisma.$RecipePracticalTagPayload>
/**
 * Model NutritionalTag
 * 
 */
export type NutritionalTag = $Result.DefaultSelection<Prisma.$NutritionalTagPayload>
/**
 * Model RecipeNutritionalTag
 * 
 */
export type RecipeNutritionalTag = $Result.DefaultSelection<Prisma.$RecipeNutritionalTagPayload>
/**
 * Model MealPlan
 * 
 */
export type MealPlan = $Result.DefaultSelection<Prisma.$MealPlanPayload>
/**
 * Model MealPlanItem
 * 
 */
export type MealPlanItem = $Result.DefaultSelection<Prisma.$MealPlanItemPayload>
/**
 * Model ShoppingList
 * 
 */
export type ShoppingList = $Result.DefaultSelection<Prisma.$ShoppingListPayload>
/**
 * Model ShoppingListItem
 * 
 */
export type ShoppingListItem = $Result.DefaultSelection<Prisma.$ShoppingListItemPayload>
/**
 * Model UserFavoriteRecipe
 * 
 */
export type UserFavoriteRecipe = $Result.DefaultSelection<Prisma.$UserFavoriteRecipePayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model ABTest
 * 
 */
export type ABTest = $Result.DefaultSelection<Prisma.$ABTestPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DietaryGoal: {
  WEIGHT_LOSS: 'WEIGHT_LOSS',
  MUSCLE_GAIN: 'MUSCLE_GAIN',
  MEDICAL_CONDITION: 'MEDICAL_CONDITION',
  LIFESTYLE_DIET: 'LIFESTYLE_DIET',
  GENERAL_HEALTH: 'GENERAL_HEALTH'
};

export type DietaryGoal = (typeof DietaryGoal)[keyof typeof DietaryGoal]


export const HealthCategory: {
  DIGESTIVE: 'DIGESTIVE',
  METABOLIC: 'METABOLIC',
  AUTOIMMUNE: 'AUTOIMMUNE',
  CARDIOVASCULAR: 'CARDIOVASCULAR',
  HORMONAL: 'HORMONAL',
  NEUROLOGICAL: 'NEUROLOGICAL',
  OTHER: 'OTHER'
};

export type HealthCategory = (typeof HealthCategory)[keyof typeof HealthCategory]


export const AllergenCategory: {
  FOOD: 'FOOD',
  ENVIRONMENTAL: 'ENVIRONMENTAL',
  MEDICATION: 'MEDICATION',
  OTHER: 'OTHER'
};

export type AllergenCategory = (typeof AllergenCategory)[keyof typeof AllergenCategory]


export const Severity: {
  MILD: 'MILD',
  MODERATE: 'MODERATE',
  SEVERE: 'SEVERE'
};

export type Severity = (typeof Severity)[keyof typeof Severity]


export const CookingSkill: {
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

export type CookingSkill = (typeof CookingSkill)[keyof typeof CookingSkill]


export const BudgetRange: {
  BUDGET: 'BUDGET',
  MODERATE: 'MODERATE',
  PREMIUM: 'PREMIUM'
};

export type BudgetRange = (typeof BudgetRange)[keyof typeof BudgetRange]


export const DietaryCategory: {
  RESTRICTION: 'RESTRICTION',
  PREFERENCE: 'PREFERENCE',
  LIFESTYLE: 'LIFESTYLE',
  RELIGIOUS: 'RELIGIOUS'
};

export type DietaryCategory = (typeof DietaryCategory)[keyof typeof DietaryCategory]


export const PracticalCategory: {
  TIME: 'TIME',
  EQUIPMENT: 'EQUIPMENT',
  SKILL: 'SKILL',
  BATCH_COOKING: 'BATCH_COOKING'
};

export type PracticalCategory = (typeof PracticalCategory)[keyof typeof PracticalCategory]


export const NutritionalCategory: {
  MACRONUTRIENT: 'MACRONUTRIENT',
  MICRONUTRIENT: 'MICRONUTRIENT',
  SPECIAL_FOCUS: 'SPECIAL_FOCUS'
};

export type NutritionalCategory = (typeof NutritionalCategory)[keyof typeof NutritionalCategory]


export const DayOfWeek: {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY'
};

export type DayOfWeek = (typeof DayOfWeek)[keyof typeof DayOfWeek]


export const MealType: {
  BREAKFAST: 'BREAKFAST',
  LUNCH: 'LUNCH',
  DINNER: 'DINNER',
  SNACK: 'SNACK'
};

export type MealType = (typeof MealType)[keyof typeof MealType]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELED: 'CANCELED',
  PAST_DUE: 'PAST_DUE',
  TRIALING: 'TRIALING',
  INCOMPLETE: 'INCOMPLETE'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const SubscriptionTier: {
  MEDICAL_BASIC: 'MEDICAL_BASIC',
  MEDICAL_PREMIUM: 'MEDICAL_PREMIUM',
  MEDICAL_SPECIALIST: 'MEDICAL_SPECIALIST',
  LIFESTYLE_STARTER: 'LIFESTYLE_STARTER',
  LIFESTYLE_PREMIUM: 'LIFESTYLE_PREMIUM',
  LIFESTYLE_FAMILY: 'LIFESTYLE_FAMILY',
  WHITE_LABEL_NUTRITIONIST: 'WHITE_LABEL_NUTRITIONIST',
  WHITE_LABEL_CLINIC: 'WHITE_LABEL_CLINIC'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]

}

export type DietaryGoal = $Enums.DietaryGoal

export const DietaryGoal: typeof $Enums.DietaryGoal

export type HealthCategory = $Enums.HealthCategory

export const HealthCategory: typeof $Enums.HealthCategory

export type AllergenCategory = $Enums.AllergenCategory

export const AllergenCategory: typeof $Enums.AllergenCategory

export type Severity = $Enums.Severity

export const Severity: typeof $Enums.Severity

export type CookingSkill = $Enums.CookingSkill

export const CookingSkill: typeof $Enums.CookingSkill

export type BudgetRange = $Enums.BudgetRange

export const BudgetRange: typeof $Enums.BudgetRange

export type DietaryCategory = $Enums.DietaryCategory

export const DietaryCategory: typeof $Enums.DietaryCategory

export type PracticalCategory = $Enums.PracticalCategory

export const PracticalCategory: typeof $Enums.PracticalCategory

export type NutritionalCategory = $Enums.NutritionalCategory

export const NutritionalCategory: typeof $Enums.NutritionalCategory

export type DayOfWeek = $Enums.DayOfWeek

export const DayOfWeek: typeof $Enums.DayOfWeek

export type MealType = $Enums.MealType

export const MealType: typeof $Enums.MealType

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.healthCondition`: Exposes CRUD operations for the **HealthCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthConditions
    * const healthConditions = await prisma.healthCondition.findMany()
    * ```
    */
  get healthCondition(): Prisma.HealthConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userHealthCondition`: Exposes CRUD operations for the **UserHealthCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserHealthConditions
    * const userHealthConditions = await prisma.userHealthCondition.findMany()
    * ```
    */
  get userHealthCondition(): Prisma.UserHealthConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.allergen`: Exposes CRUD operations for the **Allergen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Allergens
    * const allergens = await prisma.allergen.findMany()
    * ```
    */
  get allergen(): Prisma.AllergenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAllergy`: Exposes CRUD operations for the **UserAllergy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAllergies
    * const userAllergies = await prisma.userAllergy.findMany()
    * ```
    */
  get userAllergy(): Prisma.UserAllergyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appliance`: Exposes CRUD operations for the **Appliance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appliances
    * const appliances = await prisma.appliance.findMany()
    * ```
    */
  get appliance(): Prisma.ApplianceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAppliance`: Exposes CRUD operations for the **UserAppliance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAppliances
    * const userAppliances = await prisma.userAppliance.findMany()
    * ```
    */
  get userAppliance(): Prisma.UserApplianceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBehavior`: Exposes CRUD operations for the **UserBehavior** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBehaviors
    * const userBehaviors = await prisma.userBehavior.findMany()
    * ```
    */
  get userBehavior(): Prisma.UserBehaviorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spiceBlend`: Exposes CRUD operations for the **SpiceBlend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpiceBlends
    * const spiceBlends = await prisma.spiceBlend.findMany()
    * ```
    */
  get spiceBlend(): Prisma.SpiceBlendDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeSpiceBlend`: Exposes CRUD operations for the **RecipeSpiceBlend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeSpiceBlends
    * const recipeSpiceBlends = await prisma.recipeSpiceBlend.findMany()
    * ```
    */
  get recipeSpiceBlend(): Prisma.RecipeSpiceBlendDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeIngredient`: Exposes CRUD operations for the **RecipeIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeIngredients
    * const recipeIngredients = await prisma.recipeIngredient.findMany()
    * ```
    */
  get recipeIngredient(): Prisma.RecipeIngredientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeInstruction`: Exposes CRUD operations for the **RecipeInstruction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeInstructions
    * const recipeInstructions = await prisma.recipeInstruction.findMany()
    * ```
    */
  get recipeInstruction(): Prisma.RecipeInstructionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutritionalInfo`: Exposes CRUD operations for the **NutritionalInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionalInfos
    * const nutritionalInfos = await prisma.nutritionalInfo.findMany()
    * ```
    */
  get nutritionalInfo(): Prisma.NutritionalInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalTag`: Exposes CRUD operations for the **MedicalTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalTags
    * const medicalTags = await prisma.medicalTag.findMany()
    * ```
    */
  get medicalTag(): Prisma.MedicalTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeMedicalTag`: Exposes CRUD operations for the **RecipeMedicalTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeMedicalTags
    * const recipeMedicalTags = await prisma.recipeMedicalTag.findMany()
    * ```
    */
  get recipeMedicalTag(): Prisma.RecipeMedicalTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dietaryTag`: Exposes CRUD operations for the **DietaryTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DietaryTags
    * const dietaryTags = await prisma.dietaryTag.findMany()
    * ```
    */
  get dietaryTag(): Prisma.DietaryTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeDietaryTag`: Exposes CRUD operations for the **RecipeDietaryTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeDietaryTags
    * const recipeDietaryTags = await prisma.recipeDietaryTag.findMany()
    * ```
    */
  get recipeDietaryTag(): Prisma.RecipeDietaryTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.practicalTag`: Exposes CRUD operations for the **PracticalTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PracticalTags
    * const practicalTags = await prisma.practicalTag.findMany()
    * ```
    */
  get practicalTag(): Prisma.PracticalTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipePracticalTag`: Exposes CRUD operations for the **RecipePracticalTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipePracticalTags
    * const recipePracticalTags = await prisma.recipePracticalTag.findMany()
    * ```
    */
  get recipePracticalTag(): Prisma.RecipePracticalTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutritionalTag`: Exposes CRUD operations for the **NutritionalTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionalTags
    * const nutritionalTags = await prisma.nutritionalTag.findMany()
    * ```
    */
  get nutritionalTag(): Prisma.NutritionalTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recipeNutritionalTag`: Exposes CRUD operations for the **RecipeNutritionalTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeNutritionalTags
    * const recipeNutritionalTags = await prisma.recipeNutritionalTag.findMany()
    * ```
    */
  get recipeNutritionalTag(): Prisma.RecipeNutritionalTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mealPlan`: Exposes CRUD operations for the **MealPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MealPlans
    * const mealPlans = await prisma.mealPlan.findMany()
    * ```
    */
  get mealPlan(): Prisma.MealPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mealPlanItem`: Exposes CRUD operations for the **MealPlanItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MealPlanItems
    * const mealPlanItems = await prisma.mealPlanItem.findMany()
    * ```
    */
  get mealPlanItem(): Prisma.MealPlanItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shoppingList`: Exposes CRUD operations for the **ShoppingList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShoppingLists
    * const shoppingLists = await prisma.shoppingList.findMany()
    * ```
    */
  get shoppingList(): Prisma.ShoppingListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shoppingListItem`: Exposes CRUD operations for the **ShoppingListItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShoppingListItems
    * const shoppingListItems = await prisma.shoppingListItem.findMany()
    * ```
    */
  get shoppingListItem(): Prisma.ShoppingListItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFavoriteRecipe`: Exposes CRUD operations for the **UserFavoriteRecipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFavoriteRecipes
    * const userFavoriteRecipes = await prisma.userFavoriteRecipe.findMany()
    * ```
    */
  get userFavoriteRecipe(): Prisma.UserFavoriteRecipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aBTest`: Exposes CRUD operations for the **ABTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ABTests
    * const aBTests = await prisma.aBTest.findMany()
    * ```
    */
  get aBTest(): Prisma.ABTestDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserPreferences: 'UserPreferences',
    HealthCondition: 'HealthCondition',
    UserHealthCondition: 'UserHealthCondition',
    Allergen: 'Allergen',
    UserAllergy: 'UserAllergy',
    Appliance: 'Appliance',
    UserAppliance: 'UserAppliance',
    UserBehavior: 'UserBehavior',
    SpiceBlend: 'SpiceBlend',
    RecipeSpiceBlend: 'RecipeSpiceBlend',
    Recipe: 'Recipe',
    RecipeIngredient: 'RecipeIngredient',
    RecipeInstruction: 'RecipeInstruction',
    NutritionalInfo: 'NutritionalInfo',
    MedicalTag: 'MedicalTag',
    RecipeMedicalTag: 'RecipeMedicalTag',
    DietaryTag: 'DietaryTag',
    RecipeDietaryTag: 'RecipeDietaryTag',
    PracticalTag: 'PracticalTag',
    RecipePracticalTag: 'RecipePracticalTag',
    NutritionalTag: 'NutritionalTag',
    RecipeNutritionalTag: 'RecipeNutritionalTag',
    MealPlan: 'MealPlan',
    MealPlanItem: 'MealPlanItem',
    ShoppingList: 'ShoppingList',
    ShoppingListItem: 'ShoppingListItem',
    UserFavoriteRecipe: 'UserFavoriteRecipe',
    Subscription: 'Subscription',
    Feedback: 'Feedback',
    ABTest: 'ABTest'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userPreferences" | "healthCondition" | "userHealthCondition" | "allergen" | "userAllergy" | "appliance" | "userAppliance" | "userBehavior" | "spiceBlend" | "recipeSpiceBlend" | "recipe" | "recipeIngredient" | "recipeInstruction" | "nutritionalInfo" | "medicalTag" | "recipeMedicalTag" | "dietaryTag" | "recipeDietaryTag" | "practicalTag" | "recipePracticalTag" | "nutritionalTag" | "recipeNutritionalTag" | "mealPlan" | "mealPlanItem" | "shoppingList" | "shoppingListItem" | "userFavoriteRecipe" | "subscription" | "feedback" | "aBTest"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      HealthCondition: {
        payload: Prisma.$HealthConditionPayload<ExtArgs>
        fields: Prisma.HealthConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload>
          }
          findFirst: {
            args: Prisma.HealthConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload>
          }
          findMany: {
            args: Prisma.HealthConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload>[]
          }
          create: {
            args: Prisma.HealthConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload>
          }
          createMany: {
            args: Prisma.HealthConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload>[]
          }
          delete: {
            args: Prisma.HealthConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload>
          }
          update: {
            args: Prisma.HealthConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload>
          }
          deleteMany: {
            args: Prisma.HealthConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HealthConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload>[]
          }
          upsert: {
            args: Prisma.HealthConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthConditionPayload>
          }
          aggregate: {
            args: Prisma.HealthConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthCondition>
          }
          groupBy: {
            args: Prisma.HealthConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthConditionCountArgs<ExtArgs>
            result: $Utils.Optional<HealthConditionCountAggregateOutputType> | number
          }
        }
      }
      UserHealthCondition: {
        payload: Prisma.$UserHealthConditionPayload<ExtArgs>
        fields: Prisma.UserHealthConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserHealthConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserHealthConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload>
          }
          findFirst: {
            args: Prisma.UserHealthConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserHealthConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload>
          }
          findMany: {
            args: Prisma.UserHealthConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload>[]
          }
          create: {
            args: Prisma.UserHealthConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload>
          }
          createMany: {
            args: Prisma.UserHealthConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserHealthConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload>[]
          }
          delete: {
            args: Prisma.UserHealthConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload>
          }
          update: {
            args: Prisma.UserHealthConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload>
          }
          deleteMany: {
            args: Prisma.UserHealthConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserHealthConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserHealthConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload>[]
          }
          upsert: {
            args: Prisma.UserHealthConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserHealthConditionPayload>
          }
          aggregate: {
            args: Prisma.UserHealthConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserHealthCondition>
          }
          groupBy: {
            args: Prisma.UserHealthConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserHealthConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserHealthConditionCountArgs<ExtArgs>
            result: $Utils.Optional<UserHealthConditionCountAggregateOutputType> | number
          }
        }
      }
      Allergen: {
        payload: Prisma.$AllergenPayload<ExtArgs>
        fields: Prisma.AllergenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllergenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllergenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload>
          }
          findFirst: {
            args: Prisma.AllergenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllergenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload>
          }
          findMany: {
            args: Prisma.AllergenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload>[]
          }
          create: {
            args: Prisma.AllergenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload>
          }
          createMany: {
            args: Prisma.AllergenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllergenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload>[]
          }
          delete: {
            args: Prisma.AllergenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload>
          }
          update: {
            args: Prisma.AllergenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload>
          }
          deleteMany: {
            args: Prisma.AllergenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllergenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AllergenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload>[]
          }
          upsert: {
            args: Prisma.AllergenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergenPayload>
          }
          aggregate: {
            args: Prisma.AllergenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllergen>
          }
          groupBy: {
            args: Prisma.AllergenGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllergenGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllergenCountArgs<ExtArgs>
            result: $Utils.Optional<AllergenCountAggregateOutputType> | number
          }
        }
      }
      UserAllergy: {
        payload: Prisma.$UserAllergyPayload<ExtArgs>
        fields: Prisma.UserAllergyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAllergyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAllergyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload>
          }
          findFirst: {
            args: Prisma.UserAllergyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAllergyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload>
          }
          findMany: {
            args: Prisma.UserAllergyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload>[]
          }
          create: {
            args: Prisma.UserAllergyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload>
          }
          createMany: {
            args: Prisma.UserAllergyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAllergyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload>[]
          }
          delete: {
            args: Prisma.UserAllergyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload>
          }
          update: {
            args: Prisma.UserAllergyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload>
          }
          deleteMany: {
            args: Prisma.UserAllergyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAllergyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAllergyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload>[]
          }
          upsert: {
            args: Prisma.UserAllergyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAllergyPayload>
          }
          aggregate: {
            args: Prisma.UserAllergyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAllergy>
          }
          groupBy: {
            args: Prisma.UserAllergyGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAllergyGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAllergyCountArgs<ExtArgs>
            result: $Utils.Optional<UserAllergyCountAggregateOutputType> | number
          }
        }
      }
      Appliance: {
        payload: Prisma.$AppliancePayload<ExtArgs>
        fields: Prisma.ApplianceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplianceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplianceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload>
          }
          findFirst: {
            args: Prisma.ApplianceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplianceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload>
          }
          findMany: {
            args: Prisma.ApplianceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload>[]
          }
          create: {
            args: Prisma.ApplianceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload>
          }
          createMany: {
            args: Prisma.ApplianceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplianceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload>[]
          }
          delete: {
            args: Prisma.ApplianceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload>
          }
          update: {
            args: Prisma.ApplianceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload>
          }
          deleteMany: {
            args: Prisma.ApplianceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplianceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApplianceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload>[]
          }
          upsert: {
            args: Prisma.ApplianceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppliancePayload>
          }
          aggregate: {
            args: Prisma.ApplianceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppliance>
          }
          groupBy: {
            args: Prisma.ApplianceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplianceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplianceCountArgs<ExtArgs>
            result: $Utils.Optional<ApplianceCountAggregateOutputType> | number
          }
        }
      }
      UserAppliance: {
        payload: Prisma.$UserAppliancePayload<ExtArgs>
        fields: Prisma.UserApplianceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserApplianceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserApplianceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload>
          }
          findFirst: {
            args: Prisma.UserApplianceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserApplianceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload>
          }
          findMany: {
            args: Prisma.UserApplianceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload>[]
          }
          create: {
            args: Prisma.UserApplianceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload>
          }
          createMany: {
            args: Prisma.UserApplianceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserApplianceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload>[]
          }
          delete: {
            args: Prisma.UserApplianceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload>
          }
          update: {
            args: Prisma.UserApplianceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload>
          }
          deleteMany: {
            args: Prisma.UserApplianceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserApplianceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserApplianceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload>[]
          }
          upsert: {
            args: Prisma.UserApplianceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAppliancePayload>
          }
          aggregate: {
            args: Prisma.UserApplianceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAppliance>
          }
          groupBy: {
            args: Prisma.UserApplianceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserApplianceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserApplianceCountArgs<ExtArgs>
            result: $Utils.Optional<UserApplianceCountAggregateOutputType> | number
          }
        }
      }
      UserBehavior: {
        payload: Prisma.$UserBehaviorPayload<ExtArgs>
        fields: Prisma.UserBehaviorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBehaviorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBehaviorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload>
          }
          findFirst: {
            args: Prisma.UserBehaviorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBehaviorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload>
          }
          findMany: {
            args: Prisma.UserBehaviorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload>[]
          }
          create: {
            args: Prisma.UserBehaviorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload>
          }
          createMany: {
            args: Prisma.UserBehaviorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBehaviorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload>[]
          }
          delete: {
            args: Prisma.UserBehaviorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload>
          }
          update: {
            args: Prisma.UserBehaviorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload>
          }
          deleteMany: {
            args: Prisma.UserBehaviorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBehaviorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBehaviorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload>[]
          }
          upsert: {
            args: Prisma.UserBehaviorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBehaviorPayload>
          }
          aggregate: {
            args: Prisma.UserBehaviorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBehavior>
          }
          groupBy: {
            args: Prisma.UserBehaviorGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBehaviorGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBehaviorCountArgs<ExtArgs>
            result: $Utils.Optional<UserBehaviorCountAggregateOutputType> | number
          }
        }
      }
      SpiceBlend: {
        payload: Prisma.$SpiceBlendPayload<ExtArgs>
        fields: Prisma.SpiceBlendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpiceBlendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpiceBlendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload>
          }
          findFirst: {
            args: Prisma.SpiceBlendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpiceBlendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload>
          }
          findMany: {
            args: Prisma.SpiceBlendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload>[]
          }
          create: {
            args: Prisma.SpiceBlendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload>
          }
          createMany: {
            args: Prisma.SpiceBlendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpiceBlendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload>[]
          }
          delete: {
            args: Prisma.SpiceBlendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload>
          }
          update: {
            args: Prisma.SpiceBlendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload>
          }
          deleteMany: {
            args: Prisma.SpiceBlendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpiceBlendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpiceBlendUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload>[]
          }
          upsert: {
            args: Prisma.SpiceBlendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpiceBlendPayload>
          }
          aggregate: {
            args: Prisma.SpiceBlendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpiceBlend>
          }
          groupBy: {
            args: Prisma.SpiceBlendGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpiceBlendGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpiceBlendCountArgs<ExtArgs>
            result: $Utils.Optional<SpiceBlendCountAggregateOutputType> | number
          }
        }
      }
      RecipeSpiceBlend: {
        payload: Prisma.$RecipeSpiceBlendPayload<ExtArgs>
        fields: Prisma.RecipeSpiceBlendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeSpiceBlendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeSpiceBlendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload>
          }
          findFirst: {
            args: Prisma.RecipeSpiceBlendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeSpiceBlendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload>
          }
          findMany: {
            args: Prisma.RecipeSpiceBlendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload>[]
          }
          create: {
            args: Prisma.RecipeSpiceBlendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload>
          }
          createMany: {
            args: Prisma.RecipeSpiceBlendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeSpiceBlendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload>[]
          }
          delete: {
            args: Prisma.RecipeSpiceBlendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload>
          }
          update: {
            args: Prisma.RecipeSpiceBlendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload>
          }
          deleteMany: {
            args: Prisma.RecipeSpiceBlendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeSpiceBlendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeSpiceBlendUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload>[]
          }
          upsert: {
            args: Prisma.RecipeSpiceBlendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeSpiceBlendPayload>
          }
          aggregate: {
            args: Prisma.RecipeSpiceBlendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeSpiceBlend>
          }
          groupBy: {
            args: Prisma.RecipeSpiceBlendGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeSpiceBlendGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeSpiceBlendCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeSpiceBlendCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      RecipeIngredient: {
        payload: Prisma.$RecipeIngredientPayload<ExtArgs>
        fields: Prisma.RecipeIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeIngredientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findFirst: {
            args: Prisma.RecipeIngredientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeIngredientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findMany: {
            args: Prisma.RecipeIngredientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          create: {
            args: Prisma.RecipeIngredientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          createMany: {
            args: Prisma.RecipeIngredientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeIngredientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          delete: {
            args: Prisma.RecipeIngredientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          update: {
            args: Prisma.RecipeIngredientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          deleteMany: {
            args: Prisma.RecipeIngredientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeIngredientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeIngredientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          upsert: {
            args: Prisma.RecipeIngredientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          aggregate: {
            args: Prisma.RecipeIngredientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeIngredient>
          }
          groupBy: {
            args: Prisma.RecipeIngredientGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeIngredientCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeIngredientCountAggregateOutputType> | number
          }
        }
      }
      RecipeInstruction: {
        payload: Prisma.$RecipeInstructionPayload<ExtArgs>
        fields: Prisma.RecipeInstructionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeInstructionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeInstructionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          findFirst: {
            args: Prisma.RecipeInstructionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeInstructionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          findMany: {
            args: Prisma.RecipeInstructionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>[]
          }
          create: {
            args: Prisma.RecipeInstructionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          createMany: {
            args: Prisma.RecipeInstructionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeInstructionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>[]
          }
          delete: {
            args: Prisma.RecipeInstructionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          update: {
            args: Prisma.RecipeInstructionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          deleteMany: {
            args: Prisma.RecipeInstructionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeInstructionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeInstructionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>[]
          }
          upsert: {
            args: Prisma.RecipeInstructionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeInstructionPayload>
          }
          aggregate: {
            args: Prisma.RecipeInstructionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeInstruction>
          }
          groupBy: {
            args: Prisma.RecipeInstructionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeInstructionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeInstructionCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeInstructionCountAggregateOutputType> | number
          }
        }
      }
      NutritionalInfo: {
        payload: Prisma.$NutritionalInfoPayload<ExtArgs>
        fields: Prisma.NutritionalInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutritionalInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutritionalInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload>
          }
          findFirst: {
            args: Prisma.NutritionalInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutritionalInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload>
          }
          findMany: {
            args: Prisma.NutritionalInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload>[]
          }
          create: {
            args: Prisma.NutritionalInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload>
          }
          createMany: {
            args: Prisma.NutritionalInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutritionalInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload>[]
          }
          delete: {
            args: Prisma.NutritionalInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload>
          }
          update: {
            args: Prisma.NutritionalInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload>
          }
          deleteMany: {
            args: Prisma.NutritionalInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutritionalInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NutritionalInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload>[]
          }
          upsert: {
            args: Prisma.NutritionalInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalInfoPayload>
          }
          aggregate: {
            args: Prisma.NutritionalInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionalInfo>
          }
          groupBy: {
            args: Prisma.NutritionalInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionalInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutritionalInfoCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionalInfoCountAggregateOutputType> | number
          }
        }
      }
      MedicalTag: {
        payload: Prisma.$MedicalTagPayload<ExtArgs>
        fields: Prisma.MedicalTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload>
          }
          findFirst: {
            args: Prisma.MedicalTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload>
          }
          findMany: {
            args: Prisma.MedicalTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload>[]
          }
          create: {
            args: Prisma.MedicalTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload>
          }
          createMany: {
            args: Prisma.MedicalTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload>[]
          }
          delete: {
            args: Prisma.MedicalTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload>
          }
          update: {
            args: Prisma.MedicalTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload>
          }
          deleteMany: {
            args: Prisma.MedicalTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload>[]
          }
          upsert: {
            args: Prisma.MedicalTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalTagPayload>
          }
          aggregate: {
            args: Prisma.MedicalTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalTag>
          }
          groupBy: {
            args: Prisma.MedicalTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalTagCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalTagCountAggregateOutputType> | number
          }
        }
      }
      RecipeMedicalTag: {
        payload: Prisma.$RecipeMedicalTagPayload<ExtArgs>
        fields: Prisma.RecipeMedicalTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeMedicalTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeMedicalTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload>
          }
          findFirst: {
            args: Prisma.RecipeMedicalTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeMedicalTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload>
          }
          findMany: {
            args: Prisma.RecipeMedicalTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload>[]
          }
          create: {
            args: Prisma.RecipeMedicalTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload>
          }
          createMany: {
            args: Prisma.RecipeMedicalTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeMedicalTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload>[]
          }
          delete: {
            args: Prisma.RecipeMedicalTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload>
          }
          update: {
            args: Prisma.RecipeMedicalTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload>
          }
          deleteMany: {
            args: Prisma.RecipeMedicalTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeMedicalTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeMedicalTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload>[]
          }
          upsert: {
            args: Prisma.RecipeMedicalTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeMedicalTagPayload>
          }
          aggregate: {
            args: Prisma.RecipeMedicalTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeMedicalTag>
          }
          groupBy: {
            args: Prisma.RecipeMedicalTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeMedicalTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeMedicalTagCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeMedicalTagCountAggregateOutputType> | number
          }
        }
      }
      DietaryTag: {
        payload: Prisma.$DietaryTagPayload<ExtArgs>
        fields: Prisma.DietaryTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DietaryTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DietaryTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload>
          }
          findFirst: {
            args: Prisma.DietaryTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DietaryTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload>
          }
          findMany: {
            args: Prisma.DietaryTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload>[]
          }
          create: {
            args: Prisma.DietaryTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload>
          }
          createMany: {
            args: Prisma.DietaryTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DietaryTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload>[]
          }
          delete: {
            args: Prisma.DietaryTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload>
          }
          update: {
            args: Prisma.DietaryTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload>
          }
          deleteMany: {
            args: Prisma.DietaryTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DietaryTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DietaryTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload>[]
          }
          upsert: {
            args: Prisma.DietaryTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DietaryTagPayload>
          }
          aggregate: {
            args: Prisma.DietaryTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDietaryTag>
          }
          groupBy: {
            args: Prisma.DietaryTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<DietaryTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.DietaryTagCountArgs<ExtArgs>
            result: $Utils.Optional<DietaryTagCountAggregateOutputType> | number
          }
        }
      }
      RecipeDietaryTag: {
        payload: Prisma.$RecipeDietaryTagPayload<ExtArgs>
        fields: Prisma.RecipeDietaryTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeDietaryTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeDietaryTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload>
          }
          findFirst: {
            args: Prisma.RecipeDietaryTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeDietaryTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload>
          }
          findMany: {
            args: Prisma.RecipeDietaryTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload>[]
          }
          create: {
            args: Prisma.RecipeDietaryTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload>
          }
          createMany: {
            args: Prisma.RecipeDietaryTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeDietaryTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload>[]
          }
          delete: {
            args: Prisma.RecipeDietaryTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload>
          }
          update: {
            args: Prisma.RecipeDietaryTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload>
          }
          deleteMany: {
            args: Prisma.RecipeDietaryTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeDietaryTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeDietaryTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload>[]
          }
          upsert: {
            args: Prisma.RecipeDietaryTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeDietaryTagPayload>
          }
          aggregate: {
            args: Prisma.RecipeDietaryTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeDietaryTag>
          }
          groupBy: {
            args: Prisma.RecipeDietaryTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeDietaryTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeDietaryTagCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeDietaryTagCountAggregateOutputType> | number
          }
        }
      }
      PracticalTag: {
        payload: Prisma.$PracticalTagPayload<ExtArgs>
        fields: Prisma.PracticalTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PracticalTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PracticalTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload>
          }
          findFirst: {
            args: Prisma.PracticalTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PracticalTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload>
          }
          findMany: {
            args: Prisma.PracticalTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload>[]
          }
          create: {
            args: Prisma.PracticalTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload>
          }
          createMany: {
            args: Prisma.PracticalTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PracticalTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload>[]
          }
          delete: {
            args: Prisma.PracticalTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload>
          }
          update: {
            args: Prisma.PracticalTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload>
          }
          deleteMany: {
            args: Prisma.PracticalTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PracticalTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PracticalTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload>[]
          }
          upsert: {
            args: Prisma.PracticalTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PracticalTagPayload>
          }
          aggregate: {
            args: Prisma.PracticalTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePracticalTag>
          }
          groupBy: {
            args: Prisma.PracticalTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PracticalTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PracticalTagCountArgs<ExtArgs>
            result: $Utils.Optional<PracticalTagCountAggregateOutputType> | number
          }
        }
      }
      RecipePracticalTag: {
        payload: Prisma.$RecipePracticalTagPayload<ExtArgs>
        fields: Prisma.RecipePracticalTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipePracticalTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipePracticalTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload>
          }
          findFirst: {
            args: Prisma.RecipePracticalTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipePracticalTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload>
          }
          findMany: {
            args: Prisma.RecipePracticalTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload>[]
          }
          create: {
            args: Prisma.RecipePracticalTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload>
          }
          createMany: {
            args: Prisma.RecipePracticalTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipePracticalTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload>[]
          }
          delete: {
            args: Prisma.RecipePracticalTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload>
          }
          update: {
            args: Prisma.RecipePracticalTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload>
          }
          deleteMany: {
            args: Prisma.RecipePracticalTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipePracticalTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipePracticalTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload>[]
          }
          upsert: {
            args: Prisma.RecipePracticalTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePracticalTagPayload>
          }
          aggregate: {
            args: Prisma.RecipePracticalTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipePracticalTag>
          }
          groupBy: {
            args: Prisma.RecipePracticalTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipePracticalTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipePracticalTagCountArgs<ExtArgs>
            result: $Utils.Optional<RecipePracticalTagCountAggregateOutputType> | number
          }
        }
      }
      NutritionalTag: {
        payload: Prisma.$NutritionalTagPayload<ExtArgs>
        fields: Prisma.NutritionalTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutritionalTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutritionalTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload>
          }
          findFirst: {
            args: Prisma.NutritionalTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutritionalTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload>
          }
          findMany: {
            args: Prisma.NutritionalTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload>[]
          }
          create: {
            args: Prisma.NutritionalTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload>
          }
          createMany: {
            args: Prisma.NutritionalTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NutritionalTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload>[]
          }
          delete: {
            args: Prisma.NutritionalTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload>
          }
          update: {
            args: Prisma.NutritionalTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload>
          }
          deleteMany: {
            args: Prisma.NutritionalTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutritionalTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NutritionalTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload>[]
          }
          upsert: {
            args: Prisma.NutritionalTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalTagPayload>
          }
          aggregate: {
            args: Prisma.NutritionalTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionalTag>
          }
          groupBy: {
            args: Prisma.NutritionalTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionalTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutritionalTagCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionalTagCountAggregateOutputType> | number
          }
        }
      }
      RecipeNutritionalTag: {
        payload: Prisma.$RecipeNutritionalTagPayload<ExtArgs>
        fields: Prisma.RecipeNutritionalTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeNutritionalTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeNutritionalTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload>
          }
          findFirst: {
            args: Prisma.RecipeNutritionalTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeNutritionalTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload>
          }
          findMany: {
            args: Prisma.RecipeNutritionalTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload>[]
          }
          create: {
            args: Prisma.RecipeNutritionalTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload>
          }
          createMany: {
            args: Prisma.RecipeNutritionalTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeNutritionalTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload>[]
          }
          delete: {
            args: Prisma.RecipeNutritionalTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload>
          }
          update: {
            args: Prisma.RecipeNutritionalTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload>
          }
          deleteMany: {
            args: Prisma.RecipeNutritionalTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeNutritionalTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecipeNutritionalTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload>[]
          }
          upsert: {
            args: Prisma.RecipeNutritionalTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipeNutritionalTagPayload>
          }
          aggregate: {
            args: Prisma.RecipeNutritionalTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipeNutritionalTag>
          }
          groupBy: {
            args: Prisma.RecipeNutritionalTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeNutritionalTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeNutritionalTagCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeNutritionalTagCountAggregateOutputType> | number
          }
        }
      }
      MealPlan: {
        payload: Prisma.$MealPlanPayload<ExtArgs>
        fields: Prisma.MealPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MealPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MealPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          findFirst: {
            args: Prisma.MealPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MealPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          findMany: {
            args: Prisma.MealPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>[]
          }
          create: {
            args: Prisma.MealPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          createMany: {
            args: Prisma.MealPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MealPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>[]
          }
          delete: {
            args: Prisma.MealPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          update: {
            args: Prisma.MealPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          deleteMany: {
            args: Prisma.MealPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MealPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MealPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>[]
          }
          upsert: {
            args: Prisma.MealPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanPayload>
          }
          aggregate: {
            args: Prisma.MealPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMealPlan>
          }
          groupBy: {
            args: Prisma.MealPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<MealPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.MealPlanCountArgs<ExtArgs>
            result: $Utils.Optional<MealPlanCountAggregateOutputType> | number
          }
        }
      }
      MealPlanItem: {
        payload: Prisma.$MealPlanItemPayload<ExtArgs>
        fields: Prisma.MealPlanItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MealPlanItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MealPlanItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload>
          }
          findFirst: {
            args: Prisma.MealPlanItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MealPlanItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload>
          }
          findMany: {
            args: Prisma.MealPlanItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload>[]
          }
          create: {
            args: Prisma.MealPlanItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload>
          }
          createMany: {
            args: Prisma.MealPlanItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MealPlanItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload>[]
          }
          delete: {
            args: Prisma.MealPlanItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload>
          }
          update: {
            args: Prisma.MealPlanItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload>
          }
          deleteMany: {
            args: Prisma.MealPlanItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MealPlanItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MealPlanItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload>[]
          }
          upsert: {
            args: Prisma.MealPlanItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPlanItemPayload>
          }
          aggregate: {
            args: Prisma.MealPlanItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMealPlanItem>
          }
          groupBy: {
            args: Prisma.MealPlanItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MealPlanItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MealPlanItemCountArgs<ExtArgs>
            result: $Utils.Optional<MealPlanItemCountAggregateOutputType> | number
          }
        }
      }
      ShoppingList: {
        payload: Prisma.$ShoppingListPayload<ExtArgs>
        fields: Prisma.ShoppingListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShoppingListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShoppingListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload>
          }
          findFirst: {
            args: Prisma.ShoppingListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShoppingListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload>
          }
          findMany: {
            args: Prisma.ShoppingListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload>[]
          }
          create: {
            args: Prisma.ShoppingListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload>
          }
          createMany: {
            args: Prisma.ShoppingListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShoppingListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload>[]
          }
          delete: {
            args: Prisma.ShoppingListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload>
          }
          update: {
            args: Prisma.ShoppingListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload>
          }
          deleteMany: {
            args: Prisma.ShoppingListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShoppingListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShoppingListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload>[]
          }
          upsert: {
            args: Prisma.ShoppingListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListPayload>
          }
          aggregate: {
            args: Prisma.ShoppingListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShoppingList>
          }
          groupBy: {
            args: Prisma.ShoppingListGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShoppingListGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShoppingListCountArgs<ExtArgs>
            result: $Utils.Optional<ShoppingListCountAggregateOutputType> | number
          }
        }
      }
      ShoppingListItem: {
        payload: Prisma.$ShoppingListItemPayload<ExtArgs>
        fields: Prisma.ShoppingListItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShoppingListItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShoppingListItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload>
          }
          findFirst: {
            args: Prisma.ShoppingListItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShoppingListItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload>
          }
          findMany: {
            args: Prisma.ShoppingListItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload>[]
          }
          create: {
            args: Prisma.ShoppingListItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload>
          }
          createMany: {
            args: Prisma.ShoppingListItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShoppingListItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload>[]
          }
          delete: {
            args: Prisma.ShoppingListItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload>
          }
          update: {
            args: Prisma.ShoppingListItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload>
          }
          deleteMany: {
            args: Prisma.ShoppingListItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShoppingListItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShoppingListItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload>[]
          }
          upsert: {
            args: Prisma.ShoppingListItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShoppingListItemPayload>
          }
          aggregate: {
            args: Prisma.ShoppingListItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShoppingListItem>
          }
          groupBy: {
            args: Prisma.ShoppingListItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShoppingListItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShoppingListItemCountArgs<ExtArgs>
            result: $Utils.Optional<ShoppingListItemCountAggregateOutputType> | number
          }
        }
      }
      UserFavoriteRecipe: {
        payload: Prisma.$UserFavoriteRecipePayload<ExtArgs>
        fields: Prisma.UserFavoriteRecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFavoriteRecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFavoriteRecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload>
          }
          findFirst: {
            args: Prisma.UserFavoriteRecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFavoriteRecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload>
          }
          findMany: {
            args: Prisma.UserFavoriteRecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload>[]
          }
          create: {
            args: Prisma.UserFavoriteRecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload>
          }
          createMany: {
            args: Prisma.UserFavoriteRecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFavoriteRecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload>[]
          }
          delete: {
            args: Prisma.UserFavoriteRecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload>
          }
          update: {
            args: Prisma.UserFavoriteRecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload>
          }
          deleteMany: {
            args: Prisma.UserFavoriteRecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFavoriteRecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFavoriteRecipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload>[]
          }
          upsert: {
            args: Prisma.UserFavoriteRecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoriteRecipePayload>
          }
          aggregate: {
            args: Prisma.UserFavoriteRecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFavoriteRecipe>
          }
          groupBy: {
            args: Prisma.UserFavoriteRecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteRecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFavoriteRecipeCountArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteRecipeCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeedbackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      ABTest: {
        payload: Prisma.$ABTestPayload<ExtArgs>
        fields: Prisma.ABTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ABTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ABTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          findFirst: {
            args: Prisma.ABTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ABTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          findMany: {
            args: Prisma.ABTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>[]
          }
          create: {
            args: Prisma.ABTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          createMany: {
            args: Prisma.ABTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ABTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>[]
          }
          delete: {
            args: Prisma.ABTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          update: {
            args: Prisma.ABTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          deleteMany: {
            args: Prisma.ABTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ABTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ABTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>[]
          }
          upsert: {
            args: Prisma.ABTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ABTestPayload>
          }
          aggregate: {
            args: Prisma.ABTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateABTest>
          }
          groupBy: {
            args: Prisma.ABTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ABTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ABTestCountArgs<ExtArgs>
            result: $Utils.Optional<ABTestCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userPreferences?: UserPreferencesOmit
    healthCondition?: HealthConditionOmit
    userHealthCondition?: UserHealthConditionOmit
    allergen?: AllergenOmit
    userAllergy?: UserAllergyOmit
    appliance?: ApplianceOmit
    userAppliance?: UserApplianceOmit
    userBehavior?: UserBehaviorOmit
    spiceBlend?: SpiceBlendOmit
    recipeSpiceBlend?: RecipeSpiceBlendOmit
    recipe?: RecipeOmit
    recipeIngredient?: RecipeIngredientOmit
    recipeInstruction?: RecipeInstructionOmit
    nutritionalInfo?: NutritionalInfoOmit
    medicalTag?: MedicalTagOmit
    recipeMedicalTag?: RecipeMedicalTagOmit
    dietaryTag?: DietaryTagOmit
    recipeDietaryTag?: RecipeDietaryTagOmit
    practicalTag?: PracticalTagOmit
    recipePracticalTag?: RecipePracticalTagOmit
    nutritionalTag?: NutritionalTagOmit
    recipeNutritionalTag?: RecipeNutritionalTagOmit
    mealPlan?: MealPlanOmit
    mealPlanItem?: MealPlanItemOmit
    shoppingList?: ShoppingListOmit
    shoppingListItem?: ShoppingListItemOmit
    userFavoriteRecipe?: UserFavoriteRecipeOmit
    subscription?: SubscriptionOmit
    feedback?: FeedbackOmit
    aBTest?: ABTestOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    healthConditions: number
    allergies: number
    mealPlans: number
    shoppingLists: number
    favoriteRecipes: number
    feedbacks: number
    abTests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthConditions?: boolean | UserCountOutputTypeCountHealthConditionsArgs
    allergies?: boolean | UserCountOutputTypeCountAllergiesArgs
    mealPlans?: boolean | UserCountOutputTypeCountMealPlansArgs
    shoppingLists?: boolean | UserCountOutputTypeCountShoppingListsArgs
    favoriteRecipes?: boolean | UserCountOutputTypeCountFavoriteRecipesArgs
    feedbacks?: boolean | UserCountOutputTypeCountFeedbacksArgs
    abTests?: boolean | UserCountOutputTypeCountAbTestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHealthConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserHealthConditionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAllergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAllergyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMealPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShoppingListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShoppingListWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoriteRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteRecipeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAbTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ABTestWhereInput
  }


  /**
   * Count Type UserPreferencesCountOutputType
   */

  export type UserPreferencesCountOutputType = {
    appliances: number
  }

  export type UserPreferencesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appliances?: boolean | UserPreferencesCountOutputTypeCountAppliancesArgs
  }

  // Custom InputTypes
  /**
   * UserPreferencesCountOutputType without action
   */
  export type UserPreferencesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferencesCountOutputType
     */
    select?: UserPreferencesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserPreferencesCountOutputType without action
   */
  export type UserPreferencesCountOutputTypeCountAppliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApplianceWhereInput
  }


  /**
   * Count Type HealthConditionCountOutputType
   */

  export type HealthConditionCountOutputType = {
    users: number
  }

  export type HealthConditionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | HealthConditionCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * HealthConditionCountOutputType without action
   */
  export type HealthConditionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthConditionCountOutputType
     */
    select?: HealthConditionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HealthConditionCountOutputType without action
   */
  export type HealthConditionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserHealthConditionWhereInput
  }


  /**
   * Count Type AllergenCountOutputType
   */

  export type AllergenCountOutputType = {
    users: number
  }

  export type AllergenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AllergenCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * AllergenCountOutputType without action
   */
  export type AllergenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AllergenCountOutputType
     */
    select?: AllergenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AllergenCountOutputType without action
   */
  export type AllergenCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAllergyWhereInput
  }


  /**
   * Count Type ApplianceCountOutputType
   */

  export type ApplianceCountOutputType = {
    users: number
  }

  export type ApplianceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ApplianceCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * ApplianceCountOutputType without action
   */
  export type ApplianceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplianceCountOutputType
     */
    select?: ApplianceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplianceCountOutputType without action
   */
  export type ApplianceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApplianceWhereInput
  }


  /**
   * Count Type SpiceBlendCountOutputType
   */

  export type SpiceBlendCountOutputType = {
    recipes: number
  }

  export type SpiceBlendCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | SpiceBlendCountOutputTypeCountRecipesArgs
  }

  // Custom InputTypes
  /**
   * SpiceBlendCountOutputType without action
   */
  export type SpiceBlendCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlendCountOutputType
     */
    select?: SpiceBlendCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpiceBlendCountOutputType without action
   */
  export type SpiceBlendCountOutputTypeCountRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeSpiceBlendWhereInput
  }


  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    ingredients: number
    instructions: number
    medicalTags: number
    dietaryTags: number
    practicalTags: number
    nutritionalTags: number
    spiceBlends: number
    favorites: number
    mealPlanItems: number
    feedbacks: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredients?: boolean | RecipeCountOutputTypeCountIngredientsArgs
    instructions?: boolean | RecipeCountOutputTypeCountInstructionsArgs
    medicalTags?: boolean | RecipeCountOutputTypeCountMedicalTagsArgs
    dietaryTags?: boolean | RecipeCountOutputTypeCountDietaryTagsArgs
    practicalTags?: boolean | RecipeCountOutputTypeCountPracticalTagsArgs
    nutritionalTags?: boolean | RecipeCountOutputTypeCountNutritionalTagsArgs
    spiceBlends?: boolean | RecipeCountOutputTypeCountSpiceBlendsArgs
    favorites?: boolean | RecipeCountOutputTypeCountFavoritesArgs
    mealPlanItems?: boolean | RecipeCountOutputTypeCountMealPlanItemsArgs
    feedbacks?: boolean | RecipeCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountInstructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeInstructionWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountMedicalTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeMedicalTagWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountDietaryTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeDietaryTagWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountPracticalTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipePracticalTagWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountNutritionalTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeNutritionalTagWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountSpiceBlendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeSpiceBlendWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteRecipeWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountMealPlanItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealPlanItemWhereInput
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }


  /**
   * Count Type MedicalTagCountOutputType
   */

  export type MedicalTagCountOutputType = {
    recipes: number
  }

  export type MedicalTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | MedicalTagCountOutputTypeCountRecipesArgs
  }

  // Custom InputTypes
  /**
   * MedicalTagCountOutputType without action
   */
  export type MedicalTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTagCountOutputType
     */
    select?: MedicalTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicalTagCountOutputType without action
   */
  export type MedicalTagCountOutputTypeCountRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeMedicalTagWhereInput
  }


  /**
   * Count Type DietaryTagCountOutputType
   */

  export type DietaryTagCountOutputType = {
    recipes: number
  }

  export type DietaryTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | DietaryTagCountOutputTypeCountRecipesArgs
  }

  // Custom InputTypes
  /**
   * DietaryTagCountOutputType without action
   */
  export type DietaryTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTagCountOutputType
     */
    select?: DietaryTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DietaryTagCountOutputType without action
   */
  export type DietaryTagCountOutputTypeCountRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeDietaryTagWhereInput
  }


  /**
   * Count Type PracticalTagCountOutputType
   */

  export type PracticalTagCountOutputType = {
    recipes: number
  }

  export type PracticalTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | PracticalTagCountOutputTypeCountRecipesArgs
  }

  // Custom InputTypes
  /**
   * PracticalTagCountOutputType without action
   */
  export type PracticalTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTagCountOutputType
     */
    select?: PracticalTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PracticalTagCountOutputType without action
   */
  export type PracticalTagCountOutputTypeCountRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipePracticalTagWhereInput
  }


  /**
   * Count Type NutritionalTagCountOutputType
   */

  export type NutritionalTagCountOutputType = {
    recipes: number
  }

  export type NutritionalTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | NutritionalTagCountOutputTypeCountRecipesArgs
  }

  // Custom InputTypes
  /**
   * NutritionalTagCountOutputType without action
   */
  export type NutritionalTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTagCountOutputType
     */
    select?: NutritionalTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NutritionalTagCountOutputType without action
   */
  export type NutritionalTagCountOutputTypeCountRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeNutritionalTagWhereInput
  }


  /**
   * Count Type MealPlanCountOutputType
   */

  export type MealPlanCountOutputType = {
    meals: number
  }

  export type MealPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meals?: boolean | MealPlanCountOutputTypeCountMealsArgs
  }

  // Custom InputTypes
  /**
   * MealPlanCountOutputType without action
   */
  export type MealPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanCountOutputType
     */
    select?: MealPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MealPlanCountOutputType without action
   */
  export type MealPlanCountOutputTypeCountMealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealPlanItemWhereInput
  }


  /**
   * Count Type ShoppingListCountOutputType
   */

  export type ShoppingListCountOutputType = {
    items: number
  }

  export type ShoppingListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ShoppingListCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * ShoppingListCountOutputType without action
   */
  export type ShoppingListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListCountOutputType
     */
    select?: ShoppingListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShoppingListCountOutputType without action
   */
  export type ShoppingListCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShoppingListItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    primaryGoal: $Enums.DietaryGoal | null
    preferencesJson: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    primaryGoal: $Enums.DietaryGoal | null
    preferencesJson: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    createdAt: number
    updatedAt: number
    primaryGoal: number
    preferencesJson: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    primaryGoal?: true
    preferencesJson?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    primaryGoal?: true
    preferencesJson?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    primaryGoal?: true
    preferencesJson?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    createdAt: Date
    updatedAt: Date
    primaryGoal: $Enums.DietaryGoal | null
    preferencesJson: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryGoal?: boolean
    preferencesJson?: boolean
    healthConditions?: boolean | User$healthConditionsArgs<ExtArgs>
    allergies?: boolean | User$allergiesArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    mealPlans?: boolean | User$mealPlansArgs<ExtArgs>
    shoppingLists?: boolean | User$shoppingListsArgs<ExtArgs>
    favoriteRecipes?: boolean | User$favoriteRecipesArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    abTests?: boolean | User$abTestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryGoal?: boolean
    preferencesJson?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryGoal?: boolean
    preferencesJson?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    primaryGoal?: boolean
    preferencesJson?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "createdAt" | "updatedAt" | "primaryGoal" | "preferencesJson", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthConditions?: boolean | User$healthConditionsArgs<ExtArgs>
    allergies?: boolean | User$allergiesArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    mealPlans?: boolean | User$mealPlansArgs<ExtArgs>
    shoppingLists?: boolean | User$shoppingListsArgs<ExtArgs>
    favoriteRecipes?: boolean | User$favoriteRecipesArgs<ExtArgs>
    subscription?: boolean | User$subscriptionArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    abTests?: boolean | User$abTestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      healthConditions: Prisma.$UserHealthConditionPayload<ExtArgs>[]
      allergies: Prisma.$UserAllergyPayload<ExtArgs>[]
      preferences: Prisma.$UserPreferencesPayload<ExtArgs> | null
      mealPlans: Prisma.$MealPlanPayload<ExtArgs>[]
      shoppingLists: Prisma.$ShoppingListPayload<ExtArgs>[]
      favoriteRecipes: Prisma.$UserFavoriteRecipePayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
      abTests: Prisma.$ABTestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      createdAt: Date
      updatedAt: Date
      primaryGoal: $Enums.DietaryGoal | null
      preferencesJson: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    healthConditions<T extends User$healthConditionsArgs<ExtArgs> = {}>(args?: Subset<T, User$healthConditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allergies<T extends User$allergiesArgs<ExtArgs> = {}>(args?: Subset<T, User$allergiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mealPlans<T extends User$mealPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$mealPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shoppingLists<T extends User$shoppingListsArgs<ExtArgs> = {}>(args?: Subset<T, User$shoppingListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoriteRecipes<T extends User$favoriteRecipesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoriteRecipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends User$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    feedbacks<T extends User$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    abTests<T extends User$abTestsArgs<ExtArgs> = {}>(args?: Subset<T, User$abTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly primaryGoal: FieldRef<"User", 'DietaryGoal'>
    readonly preferencesJson: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.healthConditions
   */
  export type User$healthConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    where?: UserHealthConditionWhereInput
    orderBy?: UserHealthConditionOrderByWithRelationInput | UserHealthConditionOrderByWithRelationInput[]
    cursor?: UserHealthConditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserHealthConditionScalarFieldEnum | UserHealthConditionScalarFieldEnum[]
  }

  /**
   * User.allergies
   */
  export type User$allergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    where?: UserAllergyWhereInput
    orderBy?: UserAllergyOrderByWithRelationInput | UserAllergyOrderByWithRelationInput[]
    cursor?: UserAllergyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAllergyScalarFieldEnum | UserAllergyScalarFieldEnum[]
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
  }

  /**
   * User.mealPlans
   */
  export type User$mealPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    where?: MealPlanWhereInput
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    cursor?: MealPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MealPlanScalarFieldEnum | MealPlanScalarFieldEnum[]
  }

  /**
   * User.shoppingLists
   */
  export type User$shoppingListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    where?: ShoppingListWhereInput
    orderBy?: ShoppingListOrderByWithRelationInput | ShoppingListOrderByWithRelationInput[]
    cursor?: ShoppingListWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShoppingListScalarFieldEnum | ShoppingListScalarFieldEnum[]
  }

  /**
   * User.favoriteRecipes
   */
  export type User$favoriteRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    where?: UserFavoriteRecipeWhereInput
    orderBy?: UserFavoriteRecipeOrderByWithRelationInput | UserFavoriteRecipeOrderByWithRelationInput[]
    cursor?: UserFavoriteRecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteRecipeScalarFieldEnum | UserFavoriteRecipeScalarFieldEnum[]
  }

  /**
   * User.subscription
   */
  export type User$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * User.feedbacks
   */
  export type User$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.abTests
   */
  export type User$abTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    where?: ABTestWhereInput
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    cursor?: ABTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesAvgAggregateOutputType = {
    maxPrepTimeMinutes: number | null
    householdSize: number | null
    mealsPerDay: number | null
    snacksPerDay: number | null
    targetCaloriesMin: number | null
    targetCaloriesMax: number | null
    spiceTolerance: number | null
    flavorIntensity: number | null
    recipeComplexityComfort: number | null
    weeklyFoodBudget: number | null
    mealPlanningApproach: number | null
  }

  export type UserPreferencesSumAggregateOutputType = {
    maxPrepTimeMinutes: number | null
    householdSize: number | null
    mealsPerDay: number | null
    snacksPerDay: number | null
    targetCaloriesMin: number | null
    targetCaloriesMax: number | null
    spiceTolerance: number | null
    flavorIntensity: number | null
    recipeComplexityComfort: number | null
    weeklyFoodBudget: number | null
    mealPlanningApproach: number | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cookingSkillLevel: $Enums.CookingSkill | null
    maxPrepTimeMinutes: number | null
    budgetRange: $Enums.BudgetRange | null
    householdSize: number | null
    hasOven: boolean | null
    hasStove: boolean | null
    hasMicrowave: boolean | null
    hasBlender: boolean | null
    hasAirFryer: boolean | null
    hasSlowCooker: boolean | null
    hasInstantPot: boolean | null
    mealsPerDay: number | null
    snacksPerDay: number | null
    batchCookingPreference: boolean | null
    energyRestrictionGoal: string | null
    targetCaloriesMin: number | null
    targetCaloriesMax: number | null
    cuisinePreferences: string | null
    spiceTolerance: number | null
    flavorIntensity: number | null
    knifeSkillLevel: string | null
    preferredTechniques: string | null
    recipeComplexityComfort: number | null
    weeklyFoodBudget: number | null
    shoppingFrequency: string | null
    mealPlanningApproach: number | null
    textureLimitations: string | null
    foodsToAvoid: string | null
    mealTimingPreference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cookingSkillLevel: $Enums.CookingSkill | null
    maxPrepTimeMinutes: number | null
    budgetRange: $Enums.BudgetRange | null
    householdSize: number | null
    hasOven: boolean | null
    hasStove: boolean | null
    hasMicrowave: boolean | null
    hasBlender: boolean | null
    hasAirFryer: boolean | null
    hasSlowCooker: boolean | null
    hasInstantPot: boolean | null
    mealsPerDay: number | null
    snacksPerDay: number | null
    batchCookingPreference: boolean | null
    energyRestrictionGoal: string | null
    targetCaloriesMin: number | null
    targetCaloriesMax: number | null
    cuisinePreferences: string | null
    spiceTolerance: number | null
    flavorIntensity: number | null
    knifeSkillLevel: string | null
    preferredTechniques: string | null
    recipeComplexityComfort: number | null
    weeklyFoodBudget: number | null
    shoppingFrequency: string | null
    mealPlanningApproach: number | null
    textureLimitations: string | null
    foodsToAvoid: string | null
    mealTimingPreference: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    cookingSkillLevel: number
    maxPrepTimeMinutes: number
    budgetRange: number
    householdSize: number
    hasOven: number
    hasStove: number
    hasMicrowave: number
    hasBlender: number
    hasAirFryer: number
    hasSlowCooker: number
    hasInstantPot: number
    mealsPerDay: number
    snacksPerDay: number
    batchCookingPreference: number
    energyRestrictionGoal: number
    targetCaloriesMin: number
    targetCaloriesMax: number
    cuisinePreferences: number
    spiceTolerance: number
    flavorIntensity: number
    knifeSkillLevel: number
    preferredTechniques: number
    recipeComplexityComfort: number
    weeklyFoodBudget: number
    shoppingFrequency: number
    mealPlanningApproach: number
    textureLimitations: number
    foodsToAvoid: number
    mealTimingPreference: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPreferencesAvgAggregateInputType = {
    maxPrepTimeMinutes?: true
    householdSize?: true
    mealsPerDay?: true
    snacksPerDay?: true
    targetCaloriesMin?: true
    targetCaloriesMax?: true
    spiceTolerance?: true
    flavorIntensity?: true
    recipeComplexityComfort?: true
    weeklyFoodBudget?: true
    mealPlanningApproach?: true
  }

  export type UserPreferencesSumAggregateInputType = {
    maxPrepTimeMinutes?: true
    householdSize?: true
    mealsPerDay?: true
    snacksPerDay?: true
    targetCaloriesMin?: true
    targetCaloriesMax?: true
    spiceTolerance?: true
    flavorIntensity?: true
    recipeComplexityComfort?: true
    weeklyFoodBudget?: true
    mealPlanningApproach?: true
  }

  export type UserPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    cookingSkillLevel?: true
    maxPrepTimeMinutes?: true
    budgetRange?: true
    householdSize?: true
    hasOven?: true
    hasStove?: true
    hasMicrowave?: true
    hasBlender?: true
    hasAirFryer?: true
    hasSlowCooker?: true
    hasInstantPot?: true
    mealsPerDay?: true
    snacksPerDay?: true
    batchCookingPreference?: true
    energyRestrictionGoal?: true
    targetCaloriesMin?: true
    targetCaloriesMax?: true
    cuisinePreferences?: true
    spiceTolerance?: true
    flavorIntensity?: true
    knifeSkillLevel?: true
    preferredTechniques?: true
    recipeComplexityComfort?: true
    weeklyFoodBudget?: true
    shoppingFrequency?: true
    mealPlanningApproach?: true
    textureLimitations?: true
    foodsToAvoid?: true
    mealTimingPreference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    cookingSkillLevel?: true
    maxPrepTimeMinutes?: true
    budgetRange?: true
    householdSize?: true
    hasOven?: true
    hasStove?: true
    hasMicrowave?: true
    hasBlender?: true
    hasAirFryer?: true
    hasSlowCooker?: true
    hasInstantPot?: true
    mealsPerDay?: true
    snacksPerDay?: true
    batchCookingPreference?: true
    energyRestrictionGoal?: true
    targetCaloriesMin?: true
    targetCaloriesMax?: true
    cuisinePreferences?: true
    spiceTolerance?: true
    flavorIntensity?: true
    knifeSkillLevel?: true
    preferredTechniques?: true
    recipeComplexityComfort?: true
    weeklyFoodBudget?: true
    shoppingFrequency?: true
    mealPlanningApproach?: true
    textureLimitations?: true
    foodsToAvoid?: true
    mealTimingPreference?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    cookingSkillLevel?: true
    maxPrepTimeMinutes?: true
    budgetRange?: true
    householdSize?: true
    hasOven?: true
    hasStove?: true
    hasMicrowave?: true
    hasBlender?: true
    hasAirFryer?: true
    hasSlowCooker?: true
    hasInstantPot?: true
    mealsPerDay?: true
    snacksPerDay?: true
    batchCookingPreference?: true
    energyRestrictionGoal?: true
    targetCaloriesMin?: true
    targetCaloriesMax?: true
    cuisinePreferences?: true
    spiceTolerance?: true
    flavorIntensity?: true
    knifeSkillLevel?: true
    preferredTechniques?: true
    recipeComplexityComfort?: true
    weeklyFoodBudget?: true
    shoppingFrequency?: true
    mealPlanningApproach?: true
    textureLimitations?: true
    foodsToAvoid?: true
    mealTimingPreference?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _avg?: UserPreferencesAvgAggregateInputType
    _sum?: UserPreferencesSumAggregateInputType
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: string
    userId: string
    cookingSkillLevel: $Enums.CookingSkill
    maxPrepTimeMinutes: number
    budgetRange: $Enums.BudgetRange
    householdSize: number
    hasOven: boolean
    hasStove: boolean
    hasMicrowave: boolean
    hasBlender: boolean
    hasAirFryer: boolean
    hasSlowCooker: boolean
    hasInstantPot: boolean
    mealsPerDay: number
    snacksPerDay: number
    batchCookingPreference: boolean
    energyRestrictionGoal: string | null
    targetCaloriesMin: number | null
    targetCaloriesMax: number | null
    cuisinePreferences: string | null
    spiceTolerance: number
    flavorIntensity: number
    knifeSkillLevel: string
    preferredTechniques: string | null
    recipeComplexityComfort: number
    weeklyFoodBudget: number | null
    shoppingFrequency: string
    mealPlanningApproach: number
    textureLimitations: string | null
    foodsToAvoid: string | null
    mealTimingPreference: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cookingSkillLevel?: boolean
    maxPrepTimeMinutes?: boolean
    budgetRange?: boolean
    householdSize?: boolean
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: boolean
    snacksPerDay?: boolean
    batchCookingPreference?: boolean
    energyRestrictionGoal?: boolean
    targetCaloriesMin?: boolean
    targetCaloriesMax?: boolean
    cuisinePreferences?: boolean
    spiceTolerance?: boolean
    flavorIntensity?: boolean
    knifeSkillLevel?: boolean
    preferredTechniques?: boolean
    recipeComplexityComfort?: boolean
    weeklyFoodBudget?: boolean
    shoppingFrequency?: boolean
    mealPlanningApproach?: boolean
    textureLimitations?: boolean
    foodsToAvoid?: boolean
    mealTimingPreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    appliances?: boolean | UserPreferences$appliancesArgs<ExtArgs>
    behaviorProfile?: boolean | UserPreferences$behaviorProfileArgs<ExtArgs>
    _count?: boolean | UserPreferencesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cookingSkillLevel?: boolean
    maxPrepTimeMinutes?: boolean
    budgetRange?: boolean
    householdSize?: boolean
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: boolean
    snacksPerDay?: boolean
    batchCookingPreference?: boolean
    energyRestrictionGoal?: boolean
    targetCaloriesMin?: boolean
    targetCaloriesMax?: boolean
    cuisinePreferences?: boolean
    spiceTolerance?: boolean
    flavorIntensity?: boolean
    knifeSkillLevel?: boolean
    preferredTechniques?: boolean
    recipeComplexityComfort?: boolean
    weeklyFoodBudget?: boolean
    shoppingFrequency?: boolean
    mealPlanningApproach?: boolean
    textureLimitations?: boolean
    foodsToAvoid?: boolean
    mealTimingPreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cookingSkillLevel?: boolean
    maxPrepTimeMinutes?: boolean
    budgetRange?: boolean
    householdSize?: boolean
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: boolean
    snacksPerDay?: boolean
    batchCookingPreference?: boolean
    energyRestrictionGoal?: boolean
    targetCaloriesMin?: boolean
    targetCaloriesMax?: boolean
    cuisinePreferences?: boolean
    spiceTolerance?: boolean
    flavorIntensity?: boolean
    knifeSkillLevel?: boolean
    preferredTechniques?: boolean
    recipeComplexityComfort?: boolean
    weeklyFoodBudget?: boolean
    shoppingFrequency?: boolean
    mealPlanningApproach?: boolean
    textureLimitations?: boolean
    foodsToAvoid?: boolean
    mealTimingPreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    cookingSkillLevel?: boolean
    maxPrepTimeMinutes?: boolean
    budgetRange?: boolean
    householdSize?: boolean
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: boolean
    snacksPerDay?: boolean
    batchCookingPreference?: boolean
    energyRestrictionGoal?: boolean
    targetCaloriesMin?: boolean
    targetCaloriesMax?: boolean
    cuisinePreferences?: boolean
    spiceTolerance?: boolean
    flavorIntensity?: boolean
    knifeSkillLevel?: boolean
    preferredTechniques?: boolean
    recipeComplexityComfort?: boolean
    weeklyFoodBudget?: boolean
    shoppingFrequency?: boolean
    mealPlanningApproach?: boolean
    textureLimitations?: boolean
    foodsToAvoid?: boolean
    mealTimingPreference?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cookingSkillLevel" | "maxPrepTimeMinutes" | "budgetRange" | "householdSize" | "hasOven" | "hasStove" | "hasMicrowave" | "hasBlender" | "hasAirFryer" | "hasSlowCooker" | "hasInstantPot" | "mealsPerDay" | "snacksPerDay" | "batchCookingPreference" | "energyRestrictionGoal" | "targetCaloriesMin" | "targetCaloriesMax" | "cuisinePreferences" | "spiceTolerance" | "flavorIntensity" | "knifeSkillLevel" | "preferredTechniques" | "recipeComplexityComfort" | "weeklyFoodBudget" | "shoppingFrequency" | "mealPlanningApproach" | "textureLimitations" | "foodsToAvoid" | "mealTimingPreference" | "createdAt" | "updatedAt", ExtArgs["result"]["userPreferences"]>
  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    appliances?: boolean | UserPreferences$appliancesArgs<ExtArgs>
    behaviorProfile?: boolean | UserPreferences$behaviorProfileArgs<ExtArgs>
    _count?: boolean | UserPreferencesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      appliances: Prisma.$UserAppliancePayload<ExtArgs>[]
      behaviorProfile: Prisma.$UserBehaviorPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cookingSkillLevel: $Enums.CookingSkill
      maxPrepTimeMinutes: number
      budgetRange: $Enums.BudgetRange
      householdSize: number
      hasOven: boolean
      hasStove: boolean
      hasMicrowave: boolean
      hasBlender: boolean
      hasAirFryer: boolean
      hasSlowCooker: boolean
      hasInstantPot: boolean
      mealsPerDay: number
      snacksPerDay: number
      batchCookingPreference: boolean
      energyRestrictionGoal: string | null
      targetCaloriesMin: number | null
      targetCaloriesMax: number | null
      cuisinePreferences: string | null
      spiceTolerance: number
      flavorIntensity: number
      knifeSkillLevel: string
      preferredTechniques: string | null
      recipeComplexityComfort: number
      weeklyFoodBudget: number | null
      shoppingFrequency: string
      mealPlanningApproach: number
      textureLimitations: string | null
      foodsToAvoid: string | null
      mealTimingPreference: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferencesUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appliances<T extends UserPreferences$appliancesArgs<ExtArgs> = {}>(args?: Subset<T, UserPreferences$appliancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    behaviorProfile<T extends UserPreferences$behaviorProfileArgs<ExtArgs> = {}>(args?: Subset<T, UserPreferences$behaviorProfileArgs<ExtArgs>>): Prisma__UserBehaviorClient<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'String'>
    readonly userId: FieldRef<"UserPreferences", 'String'>
    readonly cookingSkillLevel: FieldRef<"UserPreferences", 'CookingSkill'>
    readonly maxPrepTimeMinutes: FieldRef<"UserPreferences", 'Int'>
    readonly budgetRange: FieldRef<"UserPreferences", 'BudgetRange'>
    readonly householdSize: FieldRef<"UserPreferences", 'Int'>
    readonly hasOven: FieldRef<"UserPreferences", 'Boolean'>
    readonly hasStove: FieldRef<"UserPreferences", 'Boolean'>
    readonly hasMicrowave: FieldRef<"UserPreferences", 'Boolean'>
    readonly hasBlender: FieldRef<"UserPreferences", 'Boolean'>
    readonly hasAirFryer: FieldRef<"UserPreferences", 'Boolean'>
    readonly hasSlowCooker: FieldRef<"UserPreferences", 'Boolean'>
    readonly hasInstantPot: FieldRef<"UserPreferences", 'Boolean'>
    readonly mealsPerDay: FieldRef<"UserPreferences", 'Int'>
    readonly snacksPerDay: FieldRef<"UserPreferences", 'Int'>
    readonly batchCookingPreference: FieldRef<"UserPreferences", 'Boolean'>
    readonly energyRestrictionGoal: FieldRef<"UserPreferences", 'String'>
    readonly targetCaloriesMin: FieldRef<"UserPreferences", 'Int'>
    readonly targetCaloriesMax: FieldRef<"UserPreferences", 'Int'>
    readonly cuisinePreferences: FieldRef<"UserPreferences", 'String'>
    readonly spiceTolerance: FieldRef<"UserPreferences", 'Int'>
    readonly flavorIntensity: FieldRef<"UserPreferences", 'Int'>
    readonly knifeSkillLevel: FieldRef<"UserPreferences", 'String'>
    readonly preferredTechniques: FieldRef<"UserPreferences", 'String'>
    readonly recipeComplexityComfort: FieldRef<"UserPreferences", 'Int'>
    readonly weeklyFoodBudget: FieldRef<"UserPreferences", 'Float'>
    readonly shoppingFrequency: FieldRef<"UserPreferences", 'String'>
    readonly mealPlanningApproach: FieldRef<"UserPreferences", 'Int'>
    readonly textureLimitations: FieldRef<"UserPreferences", 'String'>
    readonly foodsToAvoid: FieldRef<"UserPreferences", 'String'>
    readonly mealTimingPreference: FieldRef<"UserPreferences", 'String'>
    readonly createdAt: FieldRef<"UserPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreferences updateManyAndReturn
   */
  export type UserPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreferences.appliances
   */
  export type UserPreferences$appliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    where?: UserApplianceWhereInput
    orderBy?: UserApplianceOrderByWithRelationInput | UserApplianceOrderByWithRelationInput[]
    cursor?: UserApplianceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserApplianceScalarFieldEnum | UserApplianceScalarFieldEnum[]
  }

  /**
   * UserPreferences.behaviorProfile
   */
  export type UserPreferences$behaviorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    where?: UserBehaviorWhereInput
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model HealthCondition
   */

  export type AggregateHealthCondition = {
    _count: HealthConditionCountAggregateOutputType | null
    _min: HealthConditionMinAggregateOutputType | null
    _max: HealthConditionMaxAggregateOutputType | null
  }

  export type HealthConditionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.HealthCategory | null
  }

  export type HealthConditionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.HealthCategory | null
  }

  export type HealthConditionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    _all: number
  }


  export type HealthConditionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type HealthConditionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type HealthConditionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    _all?: true
  }

  export type HealthConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthCondition to aggregate.
     */
    where?: HealthConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthConditions to fetch.
     */
    orderBy?: HealthConditionOrderByWithRelationInput | HealthConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthConditions
    **/
    _count?: true | HealthConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthConditionMaxAggregateInputType
  }

  export type GetHealthConditionAggregateType<T extends HealthConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthCondition[P]>
      : GetScalarType<T[P], AggregateHealthCondition[P]>
  }




  export type HealthConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthConditionWhereInput
    orderBy?: HealthConditionOrderByWithAggregationInput | HealthConditionOrderByWithAggregationInput[]
    by: HealthConditionScalarFieldEnum[] | HealthConditionScalarFieldEnum
    having?: HealthConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthConditionCountAggregateInputType | true
    _min?: HealthConditionMinAggregateInputType
    _max?: HealthConditionMaxAggregateInputType
  }

  export type HealthConditionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: $Enums.HealthCategory
    _count: HealthConditionCountAggregateOutputType | null
    _min: HealthConditionMinAggregateOutputType | null
    _max: HealthConditionMaxAggregateOutputType | null
  }

  type GetHealthConditionGroupByPayload<T extends HealthConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthConditionGroupByOutputType[P]>
            : GetScalarType<T[P], HealthConditionGroupByOutputType[P]>
        }
      >
    >


  export type HealthConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    users?: boolean | HealthCondition$usersArgs<ExtArgs>
    _count?: boolean | HealthConditionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthCondition"]>

  export type HealthConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["healthCondition"]>

  export type HealthConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["healthCondition"]>

  export type HealthConditionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }

  export type HealthConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category", ExtArgs["result"]["healthCondition"]>
  export type HealthConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | HealthCondition$usersArgs<ExtArgs>
    _count?: boolean | HealthConditionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HealthConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HealthConditionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HealthConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthCondition"
    objects: {
      users: Prisma.$UserHealthConditionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: $Enums.HealthCategory
    }, ExtArgs["result"]["healthCondition"]>
    composites: {}
  }

  type HealthConditionGetPayload<S extends boolean | null | undefined | HealthConditionDefaultArgs> = $Result.GetResult<Prisma.$HealthConditionPayload, S>

  type HealthConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HealthConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HealthConditionCountAggregateInputType | true
    }

  export interface HealthConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthCondition'], meta: { name: 'HealthCondition' } }
    /**
     * Find zero or one HealthCondition that matches the filter.
     * @param {HealthConditionFindUniqueArgs} args - Arguments to find a HealthCondition
     * @example
     * // Get one HealthCondition
     * const healthCondition = await prisma.healthCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthConditionFindUniqueArgs>(args: SelectSubset<T, HealthConditionFindUniqueArgs<ExtArgs>>): Prisma__HealthConditionClient<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HealthCondition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HealthConditionFindUniqueOrThrowArgs} args - Arguments to find a HealthCondition
     * @example
     * // Get one HealthCondition
     * const healthCondition = await prisma.healthCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthConditionClient<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthConditionFindFirstArgs} args - Arguments to find a HealthCondition
     * @example
     * // Get one HealthCondition
     * const healthCondition = await prisma.healthCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthConditionFindFirstArgs>(args?: SelectSubset<T, HealthConditionFindFirstArgs<ExtArgs>>): Prisma__HealthConditionClient<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthConditionFindFirstOrThrowArgs} args - Arguments to find a HealthCondition
     * @example
     * // Get one HealthCondition
     * const healthCondition = await prisma.healthCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthConditionClient<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HealthConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthConditions
     * const healthConditions = await prisma.healthCondition.findMany()
     * 
     * // Get first 10 HealthConditions
     * const healthConditions = await prisma.healthCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthConditionWithIdOnly = await prisma.healthCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthConditionFindManyArgs>(args?: SelectSubset<T, HealthConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HealthCondition.
     * @param {HealthConditionCreateArgs} args - Arguments to create a HealthCondition.
     * @example
     * // Create one HealthCondition
     * const HealthCondition = await prisma.healthCondition.create({
     *   data: {
     *     // ... data to create a HealthCondition
     *   }
     * })
     * 
     */
    create<T extends HealthConditionCreateArgs>(args: SelectSubset<T, HealthConditionCreateArgs<ExtArgs>>): Prisma__HealthConditionClient<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HealthConditions.
     * @param {HealthConditionCreateManyArgs} args - Arguments to create many HealthConditions.
     * @example
     * // Create many HealthConditions
     * const healthCondition = await prisma.healthCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthConditionCreateManyArgs>(args?: SelectSubset<T, HealthConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthConditions and returns the data saved in the database.
     * @param {HealthConditionCreateManyAndReturnArgs} args - Arguments to create many HealthConditions.
     * @example
     * // Create many HealthConditions
     * const healthCondition = await prisma.healthCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthConditions and only return the `id`
     * const healthConditionWithIdOnly = await prisma.healthCondition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HealthCondition.
     * @param {HealthConditionDeleteArgs} args - Arguments to delete one HealthCondition.
     * @example
     * // Delete one HealthCondition
     * const HealthCondition = await prisma.healthCondition.delete({
     *   where: {
     *     // ... filter to delete one HealthCondition
     *   }
     * })
     * 
     */
    delete<T extends HealthConditionDeleteArgs>(args: SelectSubset<T, HealthConditionDeleteArgs<ExtArgs>>): Prisma__HealthConditionClient<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HealthCondition.
     * @param {HealthConditionUpdateArgs} args - Arguments to update one HealthCondition.
     * @example
     * // Update one HealthCondition
     * const healthCondition = await prisma.healthCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthConditionUpdateArgs>(args: SelectSubset<T, HealthConditionUpdateArgs<ExtArgs>>): Prisma__HealthConditionClient<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HealthConditions.
     * @param {HealthConditionDeleteManyArgs} args - Arguments to filter HealthConditions to delete.
     * @example
     * // Delete a few HealthConditions
     * const { count } = await prisma.healthCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthConditionDeleteManyArgs>(args?: SelectSubset<T, HealthConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthConditions
     * const healthCondition = await prisma.healthCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthConditionUpdateManyArgs>(args: SelectSubset<T, HealthConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthConditions and returns the data updated in the database.
     * @param {HealthConditionUpdateManyAndReturnArgs} args - Arguments to update many HealthConditions.
     * @example
     * // Update many HealthConditions
     * const healthCondition = await prisma.healthCondition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HealthConditions and only return the `id`
     * const healthConditionWithIdOnly = await prisma.healthCondition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HealthConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, HealthConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HealthCondition.
     * @param {HealthConditionUpsertArgs} args - Arguments to update or create a HealthCondition.
     * @example
     * // Update or create a HealthCondition
     * const healthCondition = await prisma.healthCondition.upsert({
     *   create: {
     *     // ... data to create a HealthCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthCondition we want to update
     *   }
     * })
     */
    upsert<T extends HealthConditionUpsertArgs>(args: SelectSubset<T, HealthConditionUpsertArgs<ExtArgs>>): Prisma__HealthConditionClient<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HealthConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthConditionCountArgs} args - Arguments to filter HealthConditions to count.
     * @example
     * // Count the number of HealthConditions
     * const count = await prisma.healthCondition.count({
     *   where: {
     *     // ... the filter for the HealthConditions we want to count
     *   }
     * })
    **/
    count<T extends HealthConditionCountArgs>(
      args?: Subset<T, HealthConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthConditionAggregateArgs>(args: Subset<T, HealthConditionAggregateArgs>): Prisma.PrismaPromise<GetHealthConditionAggregateType<T>>

    /**
     * Group by HealthCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthConditionGroupByArgs['orderBy'] }
        : { orderBy?: HealthConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthCondition model
   */
  readonly fields: HealthConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends HealthCondition$usersArgs<ExtArgs> = {}>(args?: Subset<T, HealthCondition$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthCondition model
   */
  interface HealthConditionFieldRefs {
    readonly id: FieldRef<"HealthCondition", 'String'>
    readonly name: FieldRef<"HealthCondition", 'String'>
    readonly description: FieldRef<"HealthCondition", 'String'>
    readonly category: FieldRef<"HealthCondition", 'HealthCategory'>
  }
    

  // Custom InputTypes
  /**
   * HealthCondition findUnique
   */
  export type HealthConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which HealthCondition to fetch.
     */
    where: HealthConditionWhereUniqueInput
  }

  /**
   * HealthCondition findUniqueOrThrow
   */
  export type HealthConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which HealthCondition to fetch.
     */
    where: HealthConditionWhereUniqueInput
  }

  /**
   * HealthCondition findFirst
   */
  export type HealthConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which HealthCondition to fetch.
     */
    where?: HealthConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthConditions to fetch.
     */
    orderBy?: HealthConditionOrderByWithRelationInput | HealthConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthConditions.
     */
    cursor?: HealthConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthConditions.
     */
    distinct?: HealthConditionScalarFieldEnum | HealthConditionScalarFieldEnum[]
  }

  /**
   * HealthCondition findFirstOrThrow
   */
  export type HealthConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which HealthCondition to fetch.
     */
    where?: HealthConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthConditions to fetch.
     */
    orderBy?: HealthConditionOrderByWithRelationInput | HealthConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthConditions.
     */
    cursor?: HealthConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthConditions.
     */
    distinct?: HealthConditionScalarFieldEnum | HealthConditionScalarFieldEnum[]
  }

  /**
   * HealthCondition findMany
   */
  export type HealthConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which HealthConditions to fetch.
     */
    where?: HealthConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthConditions to fetch.
     */
    orderBy?: HealthConditionOrderByWithRelationInput | HealthConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthConditions.
     */
    cursor?: HealthConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthConditions.
     */
    skip?: number
    distinct?: HealthConditionScalarFieldEnum | HealthConditionScalarFieldEnum[]
  }

  /**
   * HealthCondition create
   */
  export type HealthConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthCondition.
     */
    data: XOR<HealthConditionCreateInput, HealthConditionUncheckedCreateInput>
  }

  /**
   * HealthCondition createMany
   */
  export type HealthConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthConditions.
     */
    data: HealthConditionCreateManyInput | HealthConditionCreateManyInput[]
  }

  /**
   * HealthCondition createManyAndReturn
   */
  export type HealthConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * The data used to create many HealthConditions.
     */
    data: HealthConditionCreateManyInput | HealthConditionCreateManyInput[]
  }

  /**
   * HealthCondition update
   */
  export type HealthConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthCondition.
     */
    data: XOR<HealthConditionUpdateInput, HealthConditionUncheckedUpdateInput>
    /**
     * Choose, which HealthCondition to update.
     */
    where: HealthConditionWhereUniqueInput
  }

  /**
   * HealthCondition updateMany
   */
  export type HealthConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthConditions.
     */
    data: XOR<HealthConditionUpdateManyMutationInput, HealthConditionUncheckedUpdateManyInput>
    /**
     * Filter which HealthConditions to update
     */
    where?: HealthConditionWhereInput
    /**
     * Limit how many HealthConditions to update.
     */
    limit?: number
  }

  /**
   * HealthCondition updateManyAndReturn
   */
  export type HealthConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * The data used to update HealthConditions.
     */
    data: XOR<HealthConditionUpdateManyMutationInput, HealthConditionUncheckedUpdateManyInput>
    /**
     * Filter which HealthConditions to update
     */
    where?: HealthConditionWhereInput
    /**
     * Limit how many HealthConditions to update.
     */
    limit?: number
  }

  /**
   * HealthCondition upsert
   */
  export type HealthConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthCondition to update in case it exists.
     */
    where: HealthConditionWhereUniqueInput
    /**
     * In case the HealthCondition found by the `where` argument doesn't exist, create a new HealthCondition with this data.
     */
    create: XOR<HealthConditionCreateInput, HealthConditionUncheckedCreateInput>
    /**
     * In case the HealthCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthConditionUpdateInput, HealthConditionUncheckedUpdateInput>
  }

  /**
   * HealthCondition delete
   */
  export type HealthConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
    /**
     * Filter which HealthCondition to delete.
     */
    where: HealthConditionWhereUniqueInput
  }

  /**
   * HealthCondition deleteMany
   */
  export type HealthConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthConditions to delete
     */
    where?: HealthConditionWhereInput
    /**
     * Limit how many HealthConditions to delete.
     */
    limit?: number
  }

  /**
   * HealthCondition.users
   */
  export type HealthCondition$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    where?: UserHealthConditionWhereInput
    orderBy?: UserHealthConditionOrderByWithRelationInput | UserHealthConditionOrderByWithRelationInput[]
    cursor?: UserHealthConditionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserHealthConditionScalarFieldEnum | UserHealthConditionScalarFieldEnum[]
  }

  /**
   * HealthCondition without action
   */
  export type HealthConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthCondition
     */
    select?: HealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthCondition
     */
    omit?: HealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthConditionInclude<ExtArgs> | null
  }


  /**
   * Model UserHealthCondition
   */

  export type AggregateUserHealthCondition = {
    _count: UserHealthConditionCountAggregateOutputType | null
    _min: UserHealthConditionMinAggregateOutputType | null
    _max: UserHealthConditionMaxAggregateOutputType | null
  }

  export type UserHealthConditionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    healthConditionId: string | null
    severity: $Enums.Severity | null
    diagnosedDate: Date | null
  }

  export type UserHealthConditionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    healthConditionId: string | null
    severity: $Enums.Severity | null
    diagnosedDate: Date | null
  }

  export type UserHealthConditionCountAggregateOutputType = {
    id: number
    userId: number
    healthConditionId: number
    severity: number
    diagnosedDate: number
    _all: number
  }


  export type UserHealthConditionMinAggregateInputType = {
    id?: true
    userId?: true
    healthConditionId?: true
    severity?: true
    diagnosedDate?: true
  }

  export type UserHealthConditionMaxAggregateInputType = {
    id?: true
    userId?: true
    healthConditionId?: true
    severity?: true
    diagnosedDate?: true
  }

  export type UserHealthConditionCountAggregateInputType = {
    id?: true
    userId?: true
    healthConditionId?: true
    severity?: true
    diagnosedDate?: true
    _all?: true
  }

  export type UserHealthConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserHealthCondition to aggregate.
     */
    where?: UserHealthConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserHealthConditions to fetch.
     */
    orderBy?: UserHealthConditionOrderByWithRelationInput | UserHealthConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserHealthConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserHealthConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserHealthConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserHealthConditions
    **/
    _count?: true | UserHealthConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserHealthConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserHealthConditionMaxAggregateInputType
  }

  export type GetUserHealthConditionAggregateType<T extends UserHealthConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserHealthCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserHealthCondition[P]>
      : GetScalarType<T[P], AggregateUserHealthCondition[P]>
  }




  export type UserHealthConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserHealthConditionWhereInput
    orderBy?: UserHealthConditionOrderByWithAggregationInput | UserHealthConditionOrderByWithAggregationInput[]
    by: UserHealthConditionScalarFieldEnum[] | UserHealthConditionScalarFieldEnum
    having?: UserHealthConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserHealthConditionCountAggregateInputType | true
    _min?: UserHealthConditionMinAggregateInputType
    _max?: UserHealthConditionMaxAggregateInputType
  }

  export type UserHealthConditionGroupByOutputType = {
    id: string
    userId: string
    healthConditionId: string
    severity: $Enums.Severity
    diagnosedDate: Date | null
    _count: UserHealthConditionCountAggregateOutputType | null
    _min: UserHealthConditionMinAggregateOutputType | null
    _max: UserHealthConditionMaxAggregateOutputType | null
  }

  type GetUserHealthConditionGroupByPayload<T extends UserHealthConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserHealthConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserHealthConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserHealthConditionGroupByOutputType[P]>
            : GetScalarType<T[P], UserHealthConditionGroupByOutputType[P]>
        }
      >
    >


  export type UserHealthConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    healthConditionId?: boolean
    severity?: boolean
    diagnosedDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    healthCondition?: boolean | HealthConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userHealthCondition"]>

  export type UserHealthConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    healthConditionId?: boolean
    severity?: boolean
    diagnosedDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    healthCondition?: boolean | HealthConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userHealthCondition"]>

  export type UserHealthConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    healthConditionId?: boolean
    severity?: boolean
    diagnosedDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    healthCondition?: boolean | HealthConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userHealthCondition"]>

  export type UserHealthConditionSelectScalar = {
    id?: boolean
    userId?: boolean
    healthConditionId?: boolean
    severity?: boolean
    diagnosedDate?: boolean
  }

  export type UserHealthConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "healthConditionId" | "severity" | "diagnosedDate", ExtArgs["result"]["userHealthCondition"]>
  export type UserHealthConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    healthCondition?: boolean | HealthConditionDefaultArgs<ExtArgs>
  }
  export type UserHealthConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    healthCondition?: boolean | HealthConditionDefaultArgs<ExtArgs>
  }
  export type UserHealthConditionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    healthCondition?: boolean | HealthConditionDefaultArgs<ExtArgs>
  }

  export type $UserHealthConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserHealthCondition"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      healthCondition: Prisma.$HealthConditionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      healthConditionId: string
      severity: $Enums.Severity
      diagnosedDate: Date | null
    }, ExtArgs["result"]["userHealthCondition"]>
    composites: {}
  }

  type UserHealthConditionGetPayload<S extends boolean | null | undefined | UserHealthConditionDefaultArgs> = $Result.GetResult<Prisma.$UserHealthConditionPayload, S>

  type UserHealthConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserHealthConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserHealthConditionCountAggregateInputType | true
    }

  export interface UserHealthConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserHealthCondition'], meta: { name: 'UserHealthCondition' } }
    /**
     * Find zero or one UserHealthCondition that matches the filter.
     * @param {UserHealthConditionFindUniqueArgs} args - Arguments to find a UserHealthCondition
     * @example
     * // Get one UserHealthCondition
     * const userHealthCondition = await prisma.userHealthCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserHealthConditionFindUniqueArgs>(args: SelectSubset<T, UserHealthConditionFindUniqueArgs<ExtArgs>>): Prisma__UserHealthConditionClient<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserHealthCondition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserHealthConditionFindUniqueOrThrowArgs} args - Arguments to find a UserHealthCondition
     * @example
     * // Get one UserHealthCondition
     * const userHealthCondition = await prisma.userHealthCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserHealthConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserHealthConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserHealthConditionClient<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserHealthCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHealthConditionFindFirstArgs} args - Arguments to find a UserHealthCondition
     * @example
     * // Get one UserHealthCondition
     * const userHealthCondition = await prisma.userHealthCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserHealthConditionFindFirstArgs>(args?: SelectSubset<T, UserHealthConditionFindFirstArgs<ExtArgs>>): Prisma__UserHealthConditionClient<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserHealthCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHealthConditionFindFirstOrThrowArgs} args - Arguments to find a UserHealthCondition
     * @example
     * // Get one UserHealthCondition
     * const userHealthCondition = await prisma.userHealthCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserHealthConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserHealthConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserHealthConditionClient<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserHealthConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHealthConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserHealthConditions
     * const userHealthConditions = await prisma.userHealthCondition.findMany()
     * 
     * // Get first 10 UserHealthConditions
     * const userHealthConditions = await prisma.userHealthCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userHealthConditionWithIdOnly = await prisma.userHealthCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserHealthConditionFindManyArgs>(args?: SelectSubset<T, UserHealthConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserHealthCondition.
     * @param {UserHealthConditionCreateArgs} args - Arguments to create a UserHealthCondition.
     * @example
     * // Create one UserHealthCondition
     * const UserHealthCondition = await prisma.userHealthCondition.create({
     *   data: {
     *     // ... data to create a UserHealthCondition
     *   }
     * })
     * 
     */
    create<T extends UserHealthConditionCreateArgs>(args: SelectSubset<T, UserHealthConditionCreateArgs<ExtArgs>>): Prisma__UserHealthConditionClient<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserHealthConditions.
     * @param {UserHealthConditionCreateManyArgs} args - Arguments to create many UserHealthConditions.
     * @example
     * // Create many UserHealthConditions
     * const userHealthCondition = await prisma.userHealthCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserHealthConditionCreateManyArgs>(args?: SelectSubset<T, UserHealthConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserHealthConditions and returns the data saved in the database.
     * @param {UserHealthConditionCreateManyAndReturnArgs} args - Arguments to create many UserHealthConditions.
     * @example
     * // Create many UserHealthConditions
     * const userHealthCondition = await prisma.userHealthCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserHealthConditions and only return the `id`
     * const userHealthConditionWithIdOnly = await prisma.userHealthCondition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserHealthConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserHealthConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserHealthCondition.
     * @param {UserHealthConditionDeleteArgs} args - Arguments to delete one UserHealthCondition.
     * @example
     * // Delete one UserHealthCondition
     * const UserHealthCondition = await prisma.userHealthCondition.delete({
     *   where: {
     *     // ... filter to delete one UserHealthCondition
     *   }
     * })
     * 
     */
    delete<T extends UserHealthConditionDeleteArgs>(args: SelectSubset<T, UserHealthConditionDeleteArgs<ExtArgs>>): Prisma__UserHealthConditionClient<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserHealthCondition.
     * @param {UserHealthConditionUpdateArgs} args - Arguments to update one UserHealthCondition.
     * @example
     * // Update one UserHealthCondition
     * const userHealthCondition = await prisma.userHealthCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserHealthConditionUpdateArgs>(args: SelectSubset<T, UserHealthConditionUpdateArgs<ExtArgs>>): Prisma__UserHealthConditionClient<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserHealthConditions.
     * @param {UserHealthConditionDeleteManyArgs} args - Arguments to filter UserHealthConditions to delete.
     * @example
     * // Delete a few UserHealthConditions
     * const { count } = await prisma.userHealthCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserHealthConditionDeleteManyArgs>(args?: SelectSubset<T, UserHealthConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserHealthConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHealthConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserHealthConditions
     * const userHealthCondition = await prisma.userHealthCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserHealthConditionUpdateManyArgs>(args: SelectSubset<T, UserHealthConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserHealthConditions and returns the data updated in the database.
     * @param {UserHealthConditionUpdateManyAndReturnArgs} args - Arguments to update many UserHealthConditions.
     * @example
     * // Update many UserHealthConditions
     * const userHealthCondition = await prisma.userHealthCondition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserHealthConditions and only return the `id`
     * const userHealthConditionWithIdOnly = await prisma.userHealthCondition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserHealthConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserHealthConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserHealthCondition.
     * @param {UserHealthConditionUpsertArgs} args - Arguments to update or create a UserHealthCondition.
     * @example
     * // Update or create a UserHealthCondition
     * const userHealthCondition = await prisma.userHealthCondition.upsert({
     *   create: {
     *     // ... data to create a UserHealthCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserHealthCondition we want to update
     *   }
     * })
     */
    upsert<T extends UserHealthConditionUpsertArgs>(args: SelectSubset<T, UserHealthConditionUpsertArgs<ExtArgs>>): Prisma__UserHealthConditionClient<$Result.GetResult<Prisma.$UserHealthConditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserHealthConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHealthConditionCountArgs} args - Arguments to filter UserHealthConditions to count.
     * @example
     * // Count the number of UserHealthConditions
     * const count = await prisma.userHealthCondition.count({
     *   where: {
     *     // ... the filter for the UserHealthConditions we want to count
     *   }
     * })
    **/
    count<T extends UserHealthConditionCountArgs>(
      args?: Subset<T, UserHealthConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserHealthConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserHealthCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHealthConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserHealthConditionAggregateArgs>(args: Subset<T, UserHealthConditionAggregateArgs>): Prisma.PrismaPromise<GetUserHealthConditionAggregateType<T>>

    /**
     * Group by UserHealthCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserHealthConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserHealthConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserHealthConditionGroupByArgs['orderBy'] }
        : { orderBy?: UserHealthConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserHealthConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserHealthConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserHealthCondition model
   */
  readonly fields: UserHealthConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserHealthCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserHealthConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    healthCondition<T extends HealthConditionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HealthConditionDefaultArgs<ExtArgs>>): Prisma__HealthConditionClient<$Result.GetResult<Prisma.$HealthConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserHealthCondition model
   */
  interface UserHealthConditionFieldRefs {
    readonly id: FieldRef<"UserHealthCondition", 'String'>
    readonly userId: FieldRef<"UserHealthCondition", 'String'>
    readonly healthConditionId: FieldRef<"UserHealthCondition", 'String'>
    readonly severity: FieldRef<"UserHealthCondition", 'Severity'>
    readonly diagnosedDate: FieldRef<"UserHealthCondition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserHealthCondition findUnique
   */
  export type UserHealthConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which UserHealthCondition to fetch.
     */
    where: UserHealthConditionWhereUniqueInput
  }

  /**
   * UserHealthCondition findUniqueOrThrow
   */
  export type UserHealthConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which UserHealthCondition to fetch.
     */
    where: UserHealthConditionWhereUniqueInput
  }

  /**
   * UserHealthCondition findFirst
   */
  export type UserHealthConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which UserHealthCondition to fetch.
     */
    where?: UserHealthConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserHealthConditions to fetch.
     */
    orderBy?: UserHealthConditionOrderByWithRelationInput | UserHealthConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserHealthConditions.
     */
    cursor?: UserHealthConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserHealthConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserHealthConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserHealthConditions.
     */
    distinct?: UserHealthConditionScalarFieldEnum | UserHealthConditionScalarFieldEnum[]
  }

  /**
   * UserHealthCondition findFirstOrThrow
   */
  export type UserHealthConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which UserHealthCondition to fetch.
     */
    where?: UserHealthConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserHealthConditions to fetch.
     */
    orderBy?: UserHealthConditionOrderByWithRelationInput | UserHealthConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserHealthConditions.
     */
    cursor?: UserHealthConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserHealthConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserHealthConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserHealthConditions.
     */
    distinct?: UserHealthConditionScalarFieldEnum | UserHealthConditionScalarFieldEnum[]
  }

  /**
   * UserHealthCondition findMany
   */
  export type UserHealthConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    /**
     * Filter, which UserHealthConditions to fetch.
     */
    where?: UserHealthConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserHealthConditions to fetch.
     */
    orderBy?: UserHealthConditionOrderByWithRelationInput | UserHealthConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserHealthConditions.
     */
    cursor?: UserHealthConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserHealthConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserHealthConditions.
     */
    skip?: number
    distinct?: UserHealthConditionScalarFieldEnum | UserHealthConditionScalarFieldEnum[]
  }

  /**
   * UserHealthCondition create
   */
  export type UserHealthConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserHealthCondition.
     */
    data: XOR<UserHealthConditionCreateInput, UserHealthConditionUncheckedCreateInput>
  }

  /**
   * UserHealthCondition createMany
   */
  export type UserHealthConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserHealthConditions.
     */
    data: UserHealthConditionCreateManyInput | UserHealthConditionCreateManyInput[]
  }

  /**
   * UserHealthCondition createManyAndReturn
   */
  export type UserHealthConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * The data used to create many UserHealthConditions.
     */
    data: UserHealthConditionCreateManyInput | UserHealthConditionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserHealthCondition update
   */
  export type UserHealthConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserHealthCondition.
     */
    data: XOR<UserHealthConditionUpdateInput, UserHealthConditionUncheckedUpdateInput>
    /**
     * Choose, which UserHealthCondition to update.
     */
    where: UserHealthConditionWhereUniqueInput
  }

  /**
   * UserHealthCondition updateMany
   */
  export type UserHealthConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserHealthConditions.
     */
    data: XOR<UserHealthConditionUpdateManyMutationInput, UserHealthConditionUncheckedUpdateManyInput>
    /**
     * Filter which UserHealthConditions to update
     */
    where?: UserHealthConditionWhereInput
    /**
     * Limit how many UserHealthConditions to update.
     */
    limit?: number
  }

  /**
   * UserHealthCondition updateManyAndReturn
   */
  export type UserHealthConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * The data used to update UserHealthConditions.
     */
    data: XOR<UserHealthConditionUpdateManyMutationInput, UserHealthConditionUncheckedUpdateManyInput>
    /**
     * Filter which UserHealthConditions to update
     */
    where?: UserHealthConditionWhereInput
    /**
     * Limit how many UserHealthConditions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserHealthCondition upsert
   */
  export type UserHealthConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserHealthCondition to update in case it exists.
     */
    where: UserHealthConditionWhereUniqueInput
    /**
     * In case the UserHealthCondition found by the `where` argument doesn't exist, create a new UserHealthCondition with this data.
     */
    create: XOR<UserHealthConditionCreateInput, UserHealthConditionUncheckedCreateInput>
    /**
     * In case the UserHealthCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserHealthConditionUpdateInput, UserHealthConditionUncheckedUpdateInput>
  }

  /**
   * UserHealthCondition delete
   */
  export type UserHealthConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
    /**
     * Filter which UserHealthCondition to delete.
     */
    where: UserHealthConditionWhereUniqueInput
  }

  /**
   * UserHealthCondition deleteMany
   */
  export type UserHealthConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserHealthConditions to delete
     */
    where?: UserHealthConditionWhereInput
    /**
     * Limit how many UserHealthConditions to delete.
     */
    limit?: number
  }

  /**
   * UserHealthCondition without action
   */
  export type UserHealthConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserHealthCondition
     */
    select?: UserHealthConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserHealthCondition
     */
    omit?: UserHealthConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserHealthConditionInclude<ExtArgs> | null
  }


  /**
   * Model Allergen
   */

  export type AggregateAllergen = {
    _count: AllergenCountAggregateOutputType | null
    _min: AllergenMinAggregateOutputType | null
    _max: AllergenMaxAggregateOutputType | null
  }

  export type AllergenMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.AllergenCategory | null
  }

  export type AllergenMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.AllergenCategory | null
  }

  export type AllergenCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    _all: number
  }


  export type AllergenMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type AllergenMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type AllergenCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    _all?: true
  }

  export type AllergenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergen to aggregate.
     */
    where?: AllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergens to fetch.
     */
    orderBy?: AllergenOrderByWithRelationInput | AllergenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Allergens
    **/
    _count?: true | AllergenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllergenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllergenMaxAggregateInputType
  }

  export type GetAllergenAggregateType<T extends AllergenAggregateArgs> = {
        [P in keyof T & keyof AggregateAllergen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllergen[P]>
      : GetScalarType<T[P], AggregateAllergen[P]>
  }




  export type AllergenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergenWhereInput
    orderBy?: AllergenOrderByWithAggregationInput | AllergenOrderByWithAggregationInput[]
    by: AllergenScalarFieldEnum[] | AllergenScalarFieldEnum
    having?: AllergenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllergenCountAggregateInputType | true
    _min?: AllergenMinAggregateInputType
    _max?: AllergenMaxAggregateInputType
  }

  export type AllergenGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: $Enums.AllergenCategory
    _count: AllergenCountAggregateOutputType | null
    _min: AllergenMinAggregateOutputType | null
    _max: AllergenMaxAggregateOutputType | null
  }

  type GetAllergenGroupByPayload<T extends AllergenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllergenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllergenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllergenGroupByOutputType[P]>
            : GetScalarType<T[P], AllergenGroupByOutputType[P]>
        }
      >
    >


  export type AllergenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    users?: boolean | Allergen$usersArgs<ExtArgs>
    _count?: boolean | AllergenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergen"]>

  export type AllergenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["allergen"]>

  export type AllergenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["allergen"]>

  export type AllergenSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }

  export type AllergenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category", ExtArgs["result"]["allergen"]>
  export type AllergenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Allergen$usersArgs<ExtArgs>
    _count?: boolean | AllergenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AllergenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AllergenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AllergenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Allergen"
    objects: {
      users: Prisma.$UserAllergyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: $Enums.AllergenCategory
    }, ExtArgs["result"]["allergen"]>
    composites: {}
  }

  type AllergenGetPayload<S extends boolean | null | undefined | AllergenDefaultArgs> = $Result.GetResult<Prisma.$AllergenPayload, S>

  type AllergenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AllergenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AllergenCountAggregateInputType | true
    }

  export interface AllergenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Allergen'], meta: { name: 'Allergen' } }
    /**
     * Find zero or one Allergen that matches the filter.
     * @param {AllergenFindUniqueArgs} args - Arguments to find a Allergen
     * @example
     * // Get one Allergen
     * const allergen = await prisma.allergen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllergenFindUniqueArgs>(args: SelectSubset<T, AllergenFindUniqueArgs<ExtArgs>>): Prisma__AllergenClient<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Allergen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AllergenFindUniqueOrThrowArgs} args - Arguments to find a Allergen
     * @example
     * // Get one Allergen
     * const allergen = await prisma.allergen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllergenFindUniqueOrThrowArgs>(args: SelectSubset<T, AllergenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllergenClient<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Allergen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergenFindFirstArgs} args - Arguments to find a Allergen
     * @example
     * // Get one Allergen
     * const allergen = await prisma.allergen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllergenFindFirstArgs>(args?: SelectSubset<T, AllergenFindFirstArgs<ExtArgs>>): Prisma__AllergenClient<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Allergen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergenFindFirstOrThrowArgs} args - Arguments to find a Allergen
     * @example
     * // Get one Allergen
     * const allergen = await prisma.allergen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllergenFindFirstOrThrowArgs>(args?: SelectSubset<T, AllergenFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllergenClient<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Allergens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Allergens
     * const allergens = await prisma.allergen.findMany()
     * 
     * // Get first 10 Allergens
     * const allergens = await prisma.allergen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allergenWithIdOnly = await prisma.allergen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllergenFindManyArgs>(args?: SelectSubset<T, AllergenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Allergen.
     * @param {AllergenCreateArgs} args - Arguments to create a Allergen.
     * @example
     * // Create one Allergen
     * const Allergen = await prisma.allergen.create({
     *   data: {
     *     // ... data to create a Allergen
     *   }
     * })
     * 
     */
    create<T extends AllergenCreateArgs>(args: SelectSubset<T, AllergenCreateArgs<ExtArgs>>): Prisma__AllergenClient<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Allergens.
     * @param {AllergenCreateManyArgs} args - Arguments to create many Allergens.
     * @example
     * // Create many Allergens
     * const allergen = await prisma.allergen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllergenCreateManyArgs>(args?: SelectSubset<T, AllergenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Allergens and returns the data saved in the database.
     * @param {AllergenCreateManyAndReturnArgs} args - Arguments to create many Allergens.
     * @example
     * // Create many Allergens
     * const allergen = await prisma.allergen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Allergens and only return the `id`
     * const allergenWithIdOnly = await prisma.allergen.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllergenCreateManyAndReturnArgs>(args?: SelectSubset<T, AllergenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Allergen.
     * @param {AllergenDeleteArgs} args - Arguments to delete one Allergen.
     * @example
     * // Delete one Allergen
     * const Allergen = await prisma.allergen.delete({
     *   where: {
     *     // ... filter to delete one Allergen
     *   }
     * })
     * 
     */
    delete<T extends AllergenDeleteArgs>(args: SelectSubset<T, AllergenDeleteArgs<ExtArgs>>): Prisma__AllergenClient<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Allergen.
     * @param {AllergenUpdateArgs} args - Arguments to update one Allergen.
     * @example
     * // Update one Allergen
     * const allergen = await prisma.allergen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllergenUpdateArgs>(args: SelectSubset<T, AllergenUpdateArgs<ExtArgs>>): Prisma__AllergenClient<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Allergens.
     * @param {AllergenDeleteManyArgs} args - Arguments to filter Allergens to delete.
     * @example
     * // Delete a few Allergens
     * const { count } = await prisma.allergen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllergenDeleteManyArgs>(args?: SelectSubset<T, AllergenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allergens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Allergens
     * const allergen = await prisma.allergen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllergenUpdateManyArgs>(args: SelectSubset<T, AllergenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allergens and returns the data updated in the database.
     * @param {AllergenUpdateManyAndReturnArgs} args - Arguments to update many Allergens.
     * @example
     * // Update many Allergens
     * const allergen = await prisma.allergen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Allergens and only return the `id`
     * const allergenWithIdOnly = await prisma.allergen.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AllergenUpdateManyAndReturnArgs>(args: SelectSubset<T, AllergenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Allergen.
     * @param {AllergenUpsertArgs} args - Arguments to update or create a Allergen.
     * @example
     * // Update or create a Allergen
     * const allergen = await prisma.allergen.upsert({
     *   create: {
     *     // ... data to create a Allergen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Allergen we want to update
     *   }
     * })
     */
    upsert<T extends AllergenUpsertArgs>(args: SelectSubset<T, AllergenUpsertArgs<ExtArgs>>): Prisma__AllergenClient<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Allergens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergenCountArgs} args - Arguments to filter Allergens to count.
     * @example
     * // Count the number of Allergens
     * const count = await prisma.allergen.count({
     *   where: {
     *     // ... the filter for the Allergens we want to count
     *   }
     * })
    **/
    count<T extends AllergenCountArgs>(
      args?: Subset<T, AllergenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllergenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Allergen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllergenAggregateArgs>(args: Subset<T, AllergenAggregateArgs>): Prisma.PrismaPromise<GetAllergenAggregateType<T>>

    /**
     * Group by Allergen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllergenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllergenGroupByArgs['orderBy'] }
        : { orderBy?: AllergenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllergenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllergenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Allergen model
   */
  readonly fields: AllergenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Allergen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllergenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Allergen$usersArgs<ExtArgs> = {}>(args?: Subset<T, Allergen$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Allergen model
   */
  interface AllergenFieldRefs {
    readonly id: FieldRef<"Allergen", 'String'>
    readonly name: FieldRef<"Allergen", 'String'>
    readonly description: FieldRef<"Allergen", 'String'>
    readonly category: FieldRef<"Allergen", 'AllergenCategory'>
  }
    

  // Custom InputTypes
  /**
   * Allergen findUnique
   */
  export type AllergenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
    /**
     * Filter, which Allergen to fetch.
     */
    where: AllergenWhereUniqueInput
  }

  /**
   * Allergen findUniqueOrThrow
   */
  export type AllergenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
    /**
     * Filter, which Allergen to fetch.
     */
    where: AllergenWhereUniqueInput
  }

  /**
   * Allergen findFirst
   */
  export type AllergenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
    /**
     * Filter, which Allergen to fetch.
     */
    where?: AllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergens to fetch.
     */
    orderBy?: AllergenOrderByWithRelationInput | AllergenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergens.
     */
    cursor?: AllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergens.
     */
    distinct?: AllergenScalarFieldEnum | AllergenScalarFieldEnum[]
  }

  /**
   * Allergen findFirstOrThrow
   */
  export type AllergenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
    /**
     * Filter, which Allergen to fetch.
     */
    where?: AllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergens to fetch.
     */
    orderBy?: AllergenOrderByWithRelationInput | AllergenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergens.
     */
    cursor?: AllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergens.
     */
    distinct?: AllergenScalarFieldEnum | AllergenScalarFieldEnum[]
  }

  /**
   * Allergen findMany
   */
  export type AllergenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
    /**
     * Filter, which Allergens to fetch.
     */
    where?: AllergenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergens to fetch.
     */
    orderBy?: AllergenOrderByWithRelationInput | AllergenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Allergens.
     */
    cursor?: AllergenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergens.
     */
    skip?: number
    distinct?: AllergenScalarFieldEnum | AllergenScalarFieldEnum[]
  }

  /**
   * Allergen create
   */
  export type AllergenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
    /**
     * The data needed to create a Allergen.
     */
    data: XOR<AllergenCreateInput, AllergenUncheckedCreateInput>
  }

  /**
   * Allergen createMany
   */
  export type AllergenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Allergens.
     */
    data: AllergenCreateManyInput | AllergenCreateManyInput[]
  }

  /**
   * Allergen createManyAndReturn
   */
  export type AllergenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * The data used to create many Allergens.
     */
    data: AllergenCreateManyInput | AllergenCreateManyInput[]
  }

  /**
   * Allergen update
   */
  export type AllergenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
    /**
     * The data needed to update a Allergen.
     */
    data: XOR<AllergenUpdateInput, AllergenUncheckedUpdateInput>
    /**
     * Choose, which Allergen to update.
     */
    where: AllergenWhereUniqueInput
  }

  /**
   * Allergen updateMany
   */
  export type AllergenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Allergens.
     */
    data: XOR<AllergenUpdateManyMutationInput, AllergenUncheckedUpdateManyInput>
    /**
     * Filter which Allergens to update
     */
    where?: AllergenWhereInput
    /**
     * Limit how many Allergens to update.
     */
    limit?: number
  }

  /**
   * Allergen updateManyAndReturn
   */
  export type AllergenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * The data used to update Allergens.
     */
    data: XOR<AllergenUpdateManyMutationInput, AllergenUncheckedUpdateManyInput>
    /**
     * Filter which Allergens to update
     */
    where?: AllergenWhereInput
    /**
     * Limit how many Allergens to update.
     */
    limit?: number
  }

  /**
   * Allergen upsert
   */
  export type AllergenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
    /**
     * The filter to search for the Allergen to update in case it exists.
     */
    where: AllergenWhereUniqueInput
    /**
     * In case the Allergen found by the `where` argument doesn't exist, create a new Allergen with this data.
     */
    create: XOR<AllergenCreateInput, AllergenUncheckedCreateInput>
    /**
     * In case the Allergen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllergenUpdateInput, AllergenUncheckedUpdateInput>
  }

  /**
   * Allergen delete
   */
  export type AllergenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
    /**
     * Filter which Allergen to delete.
     */
    where: AllergenWhereUniqueInput
  }

  /**
   * Allergen deleteMany
   */
  export type AllergenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergens to delete
     */
    where?: AllergenWhereInput
    /**
     * Limit how many Allergens to delete.
     */
    limit?: number
  }

  /**
   * Allergen.users
   */
  export type Allergen$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    where?: UserAllergyWhereInput
    orderBy?: UserAllergyOrderByWithRelationInput | UserAllergyOrderByWithRelationInput[]
    cursor?: UserAllergyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAllergyScalarFieldEnum | UserAllergyScalarFieldEnum[]
  }

  /**
   * Allergen without action
   */
  export type AllergenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergen
     */
    select?: AllergenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergen
     */
    omit?: AllergenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergenInclude<ExtArgs> | null
  }


  /**
   * Model UserAllergy
   */

  export type AggregateUserAllergy = {
    _count: UserAllergyCountAggregateOutputType | null
    _min: UserAllergyMinAggregateOutputType | null
    _max: UserAllergyMaxAggregateOutputType | null
  }

  export type UserAllergyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    allergenId: string | null
    severity: $Enums.Severity | null
  }

  export type UserAllergyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    allergenId: string | null
    severity: $Enums.Severity | null
  }

  export type UserAllergyCountAggregateOutputType = {
    id: number
    userId: number
    allergenId: number
    severity: number
    _all: number
  }


  export type UserAllergyMinAggregateInputType = {
    id?: true
    userId?: true
    allergenId?: true
    severity?: true
  }

  export type UserAllergyMaxAggregateInputType = {
    id?: true
    userId?: true
    allergenId?: true
    severity?: true
  }

  export type UserAllergyCountAggregateInputType = {
    id?: true
    userId?: true
    allergenId?: true
    severity?: true
    _all?: true
  }

  export type UserAllergyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAllergy to aggregate.
     */
    where?: UserAllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAllergies to fetch.
     */
    orderBy?: UserAllergyOrderByWithRelationInput | UserAllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAllergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAllergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAllergies
    **/
    _count?: true | UserAllergyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAllergyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAllergyMaxAggregateInputType
  }

  export type GetUserAllergyAggregateType<T extends UserAllergyAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAllergy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAllergy[P]>
      : GetScalarType<T[P], AggregateUserAllergy[P]>
  }




  export type UserAllergyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAllergyWhereInput
    orderBy?: UserAllergyOrderByWithAggregationInput | UserAllergyOrderByWithAggregationInput[]
    by: UserAllergyScalarFieldEnum[] | UserAllergyScalarFieldEnum
    having?: UserAllergyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAllergyCountAggregateInputType | true
    _min?: UserAllergyMinAggregateInputType
    _max?: UserAllergyMaxAggregateInputType
  }

  export type UserAllergyGroupByOutputType = {
    id: string
    userId: string
    allergenId: string
    severity: $Enums.Severity
    _count: UserAllergyCountAggregateOutputType | null
    _min: UserAllergyMinAggregateOutputType | null
    _max: UserAllergyMaxAggregateOutputType | null
  }

  type GetUserAllergyGroupByPayload<T extends UserAllergyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAllergyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAllergyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAllergyGroupByOutputType[P]>
            : GetScalarType<T[P], UserAllergyGroupByOutputType[P]>
        }
      >
    >


  export type UserAllergySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    allergenId?: boolean
    severity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    allergen?: boolean | AllergenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAllergy"]>

  export type UserAllergySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    allergenId?: boolean
    severity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    allergen?: boolean | AllergenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAllergy"]>

  export type UserAllergySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    allergenId?: boolean
    severity?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    allergen?: boolean | AllergenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAllergy"]>

  export type UserAllergySelectScalar = {
    id?: boolean
    userId?: boolean
    allergenId?: boolean
    severity?: boolean
  }

  export type UserAllergyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "allergenId" | "severity", ExtArgs["result"]["userAllergy"]>
  export type UserAllergyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    allergen?: boolean | AllergenDefaultArgs<ExtArgs>
  }
  export type UserAllergyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    allergen?: boolean | AllergenDefaultArgs<ExtArgs>
  }
  export type UserAllergyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    allergen?: boolean | AllergenDefaultArgs<ExtArgs>
  }

  export type $UserAllergyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAllergy"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      allergen: Prisma.$AllergenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      allergenId: string
      severity: $Enums.Severity
    }, ExtArgs["result"]["userAllergy"]>
    composites: {}
  }

  type UserAllergyGetPayload<S extends boolean | null | undefined | UserAllergyDefaultArgs> = $Result.GetResult<Prisma.$UserAllergyPayload, S>

  type UserAllergyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAllergyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAllergyCountAggregateInputType | true
    }

  export interface UserAllergyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAllergy'], meta: { name: 'UserAllergy' } }
    /**
     * Find zero or one UserAllergy that matches the filter.
     * @param {UserAllergyFindUniqueArgs} args - Arguments to find a UserAllergy
     * @example
     * // Get one UserAllergy
     * const userAllergy = await prisma.userAllergy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAllergyFindUniqueArgs>(args: SelectSubset<T, UserAllergyFindUniqueArgs<ExtArgs>>): Prisma__UserAllergyClient<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAllergy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAllergyFindUniqueOrThrowArgs} args - Arguments to find a UserAllergy
     * @example
     * // Get one UserAllergy
     * const userAllergy = await prisma.userAllergy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAllergyFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAllergyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAllergyClient<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAllergy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAllergyFindFirstArgs} args - Arguments to find a UserAllergy
     * @example
     * // Get one UserAllergy
     * const userAllergy = await prisma.userAllergy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAllergyFindFirstArgs>(args?: SelectSubset<T, UserAllergyFindFirstArgs<ExtArgs>>): Prisma__UserAllergyClient<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAllergy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAllergyFindFirstOrThrowArgs} args - Arguments to find a UserAllergy
     * @example
     * // Get one UserAllergy
     * const userAllergy = await prisma.userAllergy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAllergyFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAllergyFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAllergyClient<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAllergies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAllergyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAllergies
     * const userAllergies = await prisma.userAllergy.findMany()
     * 
     * // Get first 10 UserAllergies
     * const userAllergies = await prisma.userAllergy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAllergyWithIdOnly = await prisma.userAllergy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAllergyFindManyArgs>(args?: SelectSubset<T, UserAllergyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAllergy.
     * @param {UserAllergyCreateArgs} args - Arguments to create a UserAllergy.
     * @example
     * // Create one UserAllergy
     * const UserAllergy = await prisma.userAllergy.create({
     *   data: {
     *     // ... data to create a UserAllergy
     *   }
     * })
     * 
     */
    create<T extends UserAllergyCreateArgs>(args: SelectSubset<T, UserAllergyCreateArgs<ExtArgs>>): Prisma__UserAllergyClient<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAllergies.
     * @param {UserAllergyCreateManyArgs} args - Arguments to create many UserAllergies.
     * @example
     * // Create many UserAllergies
     * const userAllergy = await prisma.userAllergy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAllergyCreateManyArgs>(args?: SelectSubset<T, UserAllergyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAllergies and returns the data saved in the database.
     * @param {UserAllergyCreateManyAndReturnArgs} args - Arguments to create many UserAllergies.
     * @example
     * // Create many UserAllergies
     * const userAllergy = await prisma.userAllergy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAllergies and only return the `id`
     * const userAllergyWithIdOnly = await prisma.userAllergy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAllergyCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAllergyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAllergy.
     * @param {UserAllergyDeleteArgs} args - Arguments to delete one UserAllergy.
     * @example
     * // Delete one UserAllergy
     * const UserAllergy = await prisma.userAllergy.delete({
     *   where: {
     *     // ... filter to delete one UserAllergy
     *   }
     * })
     * 
     */
    delete<T extends UserAllergyDeleteArgs>(args: SelectSubset<T, UserAllergyDeleteArgs<ExtArgs>>): Prisma__UserAllergyClient<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAllergy.
     * @param {UserAllergyUpdateArgs} args - Arguments to update one UserAllergy.
     * @example
     * // Update one UserAllergy
     * const userAllergy = await prisma.userAllergy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAllergyUpdateArgs>(args: SelectSubset<T, UserAllergyUpdateArgs<ExtArgs>>): Prisma__UserAllergyClient<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAllergies.
     * @param {UserAllergyDeleteManyArgs} args - Arguments to filter UserAllergies to delete.
     * @example
     * // Delete a few UserAllergies
     * const { count } = await prisma.userAllergy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAllergyDeleteManyArgs>(args?: SelectSubset<T, UserAllergyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAllergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAllergyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAllergies
     * const userAllergy = await prisma.userAllergy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAllergyUpdateManyArgs>(args: SelectSubset<T, UserAllergyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAllergies and returns the data updated in the database.
     * @param {UserAllergyUpdateManyAndReturnArgs} args - Arguments to update many UserAllergies.
     * @example
     * // Update many UserAllergies
     * const userAllergy = await prisma.userAllergy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAllergies and only return the `id`
     * const userAllergyWithIdOnly = await prisma.userAllergy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAllergyUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAllergyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAllergy.
     * @param {UserAllergyUpsertArgs} args - Arguments to update or create a UserAllergy.
     * @example
     * // Update or create a UserAllergy
     * const userAllergy = await prisma.userAllergy.upsert({
     *   create: {
     *     // ... data to create a UserAllergy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAllergy we want to update
     *   }
     * })
     */
    upsert<T extends UserAllergyUpsertArgs>(args: SelectSubset<T, UserAllergyUpsertArgs<ExtArgs>>): Prisma__UserAllergyClient<$Result.GetResult<Prisma.$UserAllergyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAllergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAllergyCountArgs} args - Arguments to filter UserAllergies to count.
     * @example
     * // Count the number of UserAllergies
     * const count = await prisma.userAllergy.count({
     *   where: {
     *     // ... the filter for the UserAllergies we want to count
     *   }
     * })
    **/
    count<T extends UserAllergyCountArgs>(
      args?: Subset<T, UserAllergyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAllergyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAllergy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAllergyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAllergyAggregateArgs>(args: Subset<T, UserAllergyAggregateArgs>): Prisma.PrismaPromise<GetUserAllergyAggregateType<T>>

    /**
     * Group by UserAllergy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAllergyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAllergyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAllergyGroupByArgs['orderBy'] }
        : { orderBy?: UserAllergyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAllergyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAllergyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAllergy model
   */
  readonly fields: UserAllergyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAllergy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAllergyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    allergen<T extends AllergenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AllergenDefaultArgs<ExtArgs>>): Prisma__AllergenClient<$Result.GetResult<Prisma.$AllergenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAllergy model
   */
  interface UserAllergyFieldRefs {
    readonly id: FieldRef<"UserAllergy", 'String'>
    readonly userId: FieldRef<"UserAllergy", 'String'>
    readonly allergenId: FieldRef<"UserAllergy", 'String'>
    readonly severity: FieldRef<"UserAllergy", 'Severity'>
  }
    

  // Custom InputTypes
  /**
   * UserAllergy findUnique
   */
  export type UserAllergyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    /**
     * Filter, which UserAllergy to fetch.
     */
    where: UserAllergyWhereUniqueInput
  }

  /**
   * UserAllergy findUniqueOrThrow
   */
  export type UserAllergyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    /**
     * Filter, which UserAllergy to fetch.
     */
    where: UserAllergyWhereUniqueInput
  }

  /**
   * UserAllergy findFirst
   */
  export type UserAllergyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    /**
     * Filter, which UserAllergy to fetch.
     */
    where?: UserAllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAllergies to fetch.
     */
    orderBy?: UserAllergyOrderByWithRelationInput | UserAllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAllergies.
     */
    cursor?: UserAllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAllergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAllergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAllergies.
     */
    distinct?: UserAllergyScalarFieldEnum | UserAllergyScalarFieldEnum[]
  }

  /**
   * UserAllergy findFirstOrThrow
   */
  export type UserAllergyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    /**
     * Filter, which UserAllergy to fetch.
     */
    where?: UserAllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAllergies to fetch.
     */
    orderBy?: UserAllergyOrderByWithRelationInput | UserAllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAllergies.
     */
    cursor?: UserAllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAllergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAllergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAllergies.
     */
    distinct?: UserAllergyScalarFieldEnum | UserAllergyScalarFieldEnum[]
  }

  /**
   * UserAllergy findMany
   */
  export type UserAllergyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    /**
     * Filter, which UserAllergies to fetch.
     */
    where?: UserAllergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAllergies to fetch.
     */
    orderBy?: UserAllergyOrderByWithRelationInput | UserAllergyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAllergies.
     */
    cursor?: UserAllergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAllergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAllergies.
     */
    skip?: number
    distinct?: UserAllergyScalarFieldEnum | UserAllergyScalarFieldEnum[]
  }

  /**
   * UserAllergy create
   */
  export type UserAllergyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAllergy.
     */
    data: XOR<UserAllergyCreateInput, UserAllergyUncheckedCreateInput>
  }

  /**
   * UserAllergy createMany
   */
  export type UserAllergyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAllergies.
     */
    data: UserAllergyCreateManyInput | UserAllergyCreateManyInput[]
  }

  /**
   * UserAllergy createManyAndReturn
   */
  export type UserAllergyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * The data used to create many UserAllergies.
     */
    data: UserAllergyCreateManyInput | UserAllergyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAllergy update
   */
  export type UserAllergyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAllergy.
     */
    data: XOR<UserAllergyUpdateInput, UserAllergyUncheckedUpdateInput>
    /**
     * Choose, which UserAllergy to update.
     */
    where: UserAllergyWhereUniqueInput
  }

  /**
   * UserAllergy updateMany
   */
  export type UserAllergyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAllergies.
     */
    data: XOR<UserAllergyUpdateManyMutationInput, UserAllergyUncheckedUpdateManyInput>
    /**
     * Filter which UserAllergies to update
     */
    where?: UserAllergyWhereInput
    /**
     * Limit how many UserAllergies to update.
     */
    limit?: number
  }

  /**
   * UserAllergy updateManyAndReturn
   */
  export type UserAllergyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * The data used to update UserAllergies.
     */
    data: XOR<UserAllergyUpdateManyMutationInput, UserAllergyUncheckedUpdateManyInput>
    /**
     * Filter which UserAllergies to update
     */
    where?: UserAllergyWhereInput
    /**
     * Limit how many UserAllergies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAllergy upsert
   */
  export type UserAllergyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAllergy to update in case it exists.
     */
    where: UserAllergyWhereUniqueInput
    /**
     * In case the UserAllergy found by the `where` argument doesn't exist, create a new UserAllergy with this data.
     */
    create: XOR<UserAllergyCreateInput, UserAllergyUncheckedCreateInput>
    /**
     * In case the UserAllergy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAllergyUpdateInput, UserAllergyUncheckedUpdateInput>
  }

  /**
   * UserAllergy delete
   */
  export type UserAllergyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
    /**
     * Filter which UserAllergy to delete.
     */
    where: UserAllergyWhereUniqueInput
  }

  /**
   * UserAllergy deleteMany
   */
  export type UserAllergyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAllergies to delete
     */
    where?: UserAllergyWhereInput
    /**
     * Limit how many UserAllergies to delete.
     */
    limit?: number
  }

  /**
   * UserAllergy without action
   */
  export type UserAllergyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAllergy
     */
    select?: UserAllergySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAllergy
     */
    omit?: UserAllergyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAllergyInclude<ExtArgs> | null
  }


  /**
   * Model Appliance
   */

  export type AggregateAppliance = {
    _count: ApplianceCountAggregateOutputType | null
    _min: ApplianceMinAggregateOutputType | null
    _max: ApplianceMaxAggregateOutputType | null
  }

  export type ApplianceMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    category: string | null
  }

  export type ApplianceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    category: string | null
  }

  export type ApplianceCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    category: number
    _all: number
  }


  export type ApplianceMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    category?: true
  }

  export type ApplianceMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    category?: true
  }

  export type ApplianceCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    category?: true
    _all?: true
  }

  export type ApplianceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appliance to aggregate.
     */
    where?: ApplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appliances to fetch.
     */
    orderBy?: ApplianceOrderByWithRelationInput | ApplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appliances
    **/
    _count?: true | ApplianceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplianceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplianceMaxAggregateInputType
  }

  export type GetApplianceAggregateType<T extends ApplianceAggregateArgs> = {
        [P in keyof T & keyof AggregateAppliance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppliance[P]>
      : GetScalarType<T[P], AggregateAppliance[P]>
  }




  export type ApplianceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplianceWhereInput
    orderBy?: ApplianceOrderByWithAggregationInput | ApplianceOrderByWithAggregationInput[]
    by: ApplianceScalarFieldEnum[] | ApplianceScalarFieldEnum
    having?: ApplianceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplianceCountAggregateInputType | true
    _min?: ApplianceMinAggregateInputType
    _max?: ApplianceMaxAggregateInputType
  }

  export type ApplianceGroupByOutputType = {
    id: string
    name: string
    displayName: string
    category: string
    _count: ApplianceCountAggregateOutputType | null
    _min: ApplianceMinAggregateOutputType | null
    _max: ApplianceMaxAggregateOutputType | null
  }

  type GetApplianceGroupByPayload<T extends ApplianceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplianceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplianceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplianceGroupByOutputType[P]>
            : GetScalarType<T[P], ApplianceGroupByOutputType[P]>
        }
      >
    >


  export type ApplianceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    category?: boolean
    users?: boolean | Appliance$usersArgs<ExtArgs>
    _count?: boolean | ApplianceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appliance"]>

  export type ApplianceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    category?: boolean
  }, ExtArgs["result"]["appliance"]>

  export type ApplianceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    category?: boolean
  }, ExtArgs["result"]["appliance"]>

  export type ApplianceSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    category?: boolean
  }

  export type ApplianceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "displayName" | "category", ExtArgs["result"]["appliance"]>
  export type ApplianceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Appliance$usersArgs<ExtArgs>
    _count?: boolean | ApplianceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApplianceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ApplianceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AppliancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appliance"
    objects: {
      users: Prisma.$UserAppliancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      category: string
    }, ExtArgs["result"]["appliance"]>
    composites: {}
  }

  type ApplianceGetPayload<S extends boolean | null | undefined | ApplianceDefaultArgs> = $Result.GetResult<Prisma.$AppliancePayload, S>

  type ApplianceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplianceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplianceCountAggregateInputType | true
    }

  export interface ApplianceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appliance'], meta: { name: 'Appliance' } }
    /**
     * Find zero or one Appliance that matches the filter.
     * @param {ApplianceFindUniqueArgs} args - Arguments to find a Appliance
     * @example
     * // Get one Appliance
     * const appliance = await prisma.appliance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplianceFindUniqueArgs>(args: SelectSubset<T, ApplianceFindUniqueArgs<ExtArgs>>): Prisma__ApplianceClient<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appliance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplianceFindUniqueOrThrowArgs} args - Arguments to find a Appliance
     * @example
     * // Get one Appliance
     * const appliance = await prisma.appliance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplianceFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplianceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplianceClient<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appliance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplianceFindFirstArgs} args - Arguments to find a Appliance
     * @example
     * // Get one Appliance
     * const appliance = await prisma.appliance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplianceFindFirstArgs>(args?: SelectSubset<T, ApplianceFindFirstArgs<ExtArgs>>): Prisma__ApplianceClient<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appliance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplianceFindFirstOrThrowArgs} args - Arguments to find a Appliance
     * @example
     * // Get one Appliance
     * const appliance = await prisma.appliance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplianceFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplianceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplianceClient<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appliances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplianceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appliances
     * const appliances = await prisma.appliance.findMany()
     * 
     * // Get first 10 Appliances
     * const appliances = await prisma.appliance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const applianceWithIdOnly = await prisma.appliance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApplianceFindManyArgs>(args?: SelectSubset<T, ApplianceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appliance.
     * @param {ApplianceCreateArgs} args - Arguments to create a Appliance.
     * @example
     * // Create one Appliance
     * const Appliance = await prisma.appliance.create({
     *   data: {
     *     // ... data to create a Appliance
     *   }
     * })
     * 
     */
    create<T extends ApplianceCreateArgs>(args: SelectSubset<T, ApplianceCreateArgs<ExtArgs>>): Prisma__ApplianceClient<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appliances.
     * @param {ApplianceCreateManyArgs} args - Arguments to create many Appliances.
     * @example
     * // Create many Appliances
     * const appliance = await prisma.appliance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplianceCreateManyArgs>(args?: SelectSubset<T, ApplianceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appliances and returns the data saved in the database.
     * @param {ApplianceCreateManyAndReturnArgs} args - Arguments to create many Appliances.
     * @example
     * // Create many Appliances
     * const appliance = await prisma.appliance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appliances and only return the `id`
     * const applianceWithIdOnly = await prisma.appliance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplianceCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplianceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appliance.
     * @param {ApplianceDeleteArgs} args - Arguments to delete one Appliance.
     * @example
     * // Delete one Appliance
     * const Appliance = await prisma.appliance.delete({
     *   where: {
     *     // ... filter to delete one Appliance
     *   }
     * })
     * 
     */
    delete<T extends ApplianceDeleteArgs>(args: SelectSubset<T, ApplianceDeleteArgs<ExtArgs>>): Prisma__ApplianceClient<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appliance.
     * @param {ApplianceUpdateArgs} args - Arguments to update one Appliance.
     * @example
     * // Update one Appliance
     * const appliance = await prisma.appliance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplianceUpdateArgs>(args: SelectSubset<T, ApplianceUpdateArgs<ExtArgs>>): Prisma__ApplianceClient<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appliances.
     * @param {ApplianceDeleteManyArgs} args - Arguments to filter Appliances to delete.
     * @example
     * // Delete a few Appliances
     * const { count } = await prisma.appliance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplianceDeleteManyArgs>(args?: SelectSubset<T, ApplianceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplianceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appliances
     * const appliance = await prisma.appliance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplianceUpdateManyArgs>(args: SelectSubset<T, ApplianceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appliances and returns the data updated in the database.
     * @param {ApplianceUpdateManyAndReturnArgs} args - Arguments to update many Appliances.
     * @example
     * // Update many Appliances
     * const appliance = await prisma.appliance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appliances and only return the `id`
     * const applianceWithIdOnly = await prisma.appliance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApplianceUpdateManyAndReturnArgs>(args: SelectSubset<T, ApplianceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appliance.
     * @param {ApplianceUpsertArgs} args - Arguments to update or create a Appliance.
     * @example
     * // Update or create a Appliance
     * const appliance = await prisma.appliance.upsert({
     *   create: {
     *     // ... data to create a Appliance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appliance we want to update
     *   }
     * })
     */
    upsert<T extends ApplianceUpsertArgs>(args: SelectSubset<T, ApplianceUpsertArgs<ExtArgs>>): Prisma__ApplianceClient<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplianceCountArgs} args - Arguments to filter Appliances to count.
     * @example
     * // Count the number of Appliances
     * const count = await prisma.appliance.count({
     *   where: {
     *     // ... the filter for the Appliances we want to count
     *   }
     * })
    **/
    count<T extends ApplianceCountArgs>(
      args?: Subset<T, ApplianceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplianceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplianceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplianceAggregateArgs>(args: Subset<T, ApplianceAggregateArgs>): Prisma.PrismaPromise<GetApplianceAggregateType<T>>

    /**
     * Group by Appliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplianceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplianceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplianceGroupByArgs['orderBy'] }
        : { orderBy?: ApplianceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplianceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplianceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appliance model
   */
  readonly fields: ApplianceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appliance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplianceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Appliance$usersArgs<ExtArgs> = {}>(args?: Subset<T, Appliance$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appliance model
   */
  interface ApplianceFieldRefs {
    readonly id: FieldRef<"Appliance", 'String'>
    readonly name: FieldRef<"Appliance", 'String'>
    readonly displayName: FieldRef<"Appliance", 'String'>
    readonly category: FieldRef<"Appliance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Appliance findUnique
   */
  export type ApplianceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
    /**
     * Filter, which Appliance to fetch.
     */
    where: ApplianceWhereUniqueInput
  }

  /**
   * Appliance findUniqueOrThrow
   */
  export type ApplianceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
    /**
     * Filter, which Appliance to fetch.
     */
    where: ApplianceWhereUniqueInput
  }

  /**
   * Appliance findFirst
   */
  export type ApplianceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
    /**
     * Filter, which Appliance to fetch.
     */
    where?: ApplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appliances to fetch.
     */
    orderBy?: ApplianceOrderByWithRelationInput | ApplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appliances.
     */
    cursor?: ApplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appliances.
     */
    distinct?: ApplianceScalarFieldEnum | ApplianceScalarFieldEnum[]
  }

  /**
   * Appliance findFirstOrThrow
   */
  export type ApplianceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
    /**
     * Filter, which Appliance to fetch.
     */
    where?: ApplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appliances to fetch.
     */
    orderBy?: ApplianceOrderByWithRelationInput | ApplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appliances.
     */
    cursor?: ApplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appliances.
     */
    distinct?: ApplianceScalarFieldEnum | ApplianceScalarFieldEnum[]
  }

  /**
   * Appliance findMany
   */
  export type ApplianceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
    /**
     * Filter, which Appliances to fetch.
     */
    where?: ApplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appliances to fetch.
     */
    orderBy?: ApplianceOrderByWithRelationInput | ApplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appliances.
     */
    cursor?: ApplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appliances.
     */
    skip?: number
    distinct?: ApplianceScalarFieldEnum | ApplianceScalarFieldEnum[]
  }

  /**
   * Appliance create
   */
  export type ApplianceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
    /**
     * The data needed to create a Appliance.
     */
    data: XOR<ApplianceCreateInput, ApplianceUncheckedCreateInput>
  }

  /**
   * Appliance createMany
   */
  export type ApplianceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appliances.
     */
    data: ApplianceCreateManyInput | ApplianceCreateManyInput[]
  }

  /**
   * Appliance createManyAndReturn
   */
  export type ApplianceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * The data used to create many Appliances.
     */
    data: ApplianceCreateManyInput | ApplianceCreateManyInput[]
  }

  /**
   * Appliance update
   */
  export type ApplianceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
    /**
     * The data needed to update a Appliance.
     */
    data: XOR<ApplianceUpdateInput, ApplianceUncheckedUpdateInput>
    /**
     * Choose, which Appliance to update.
     */
    where: ApplianceWhereUniqueInput
  }

  /**
   * Appliance updateMany
   */
  export type ApplianceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appliances.
     */
    data: XOR<ApplianceUpdateManyMutationInput, ApplianceUncheckedUpdateManyInput>
    /**
     * Filter which Appliances to update
     */
    where?: ApplianceWhereInput
    /**
     * Limit how many Appliances to update.
     */
    limit?: number
  }

  /**
   * Appliance updateManyAndReturn
   */
  export type ApplianceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * The data used to update Appliances.
     */
    data: XOR<ApplianceUpdateManyMutationInput, ApplianceUncheckedUpdateManyInput>
    /**
     * Filter which Appliances to update
     */
    where?: ApplianceWhereInput
    /**
     * Limit how many Appliances to update.
     */
    limit?: number
  }

  /**
   * Appliance upsert
   */
  export type ApplianceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
    /**
     * The filter to search for the Appliance to update in case it exists.
     */
    where: ApplianceWhereUniqueInput
    /**
     * In case the Appliance found by the `where` argument doesn't exist, create a new Appliance with this data.
     */
    create: XOR<ApplianceCreateInput, ApplianceUncheckedCreateInput>
    /**
     * In case the Appliance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplianceUpdateInput, ApplianceUncheckedUpdateInput>
  }

  /**
   * Appliance delete
   */
  export type ApplianceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
    /**
     * Filter which Appliance to delete.
     */
    where: ApplianceWhereUniqueInput
  }

  /**
   * Appliance deleteMany
   */
  export type ApplianceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appliances to delete
     */
    where?: ApplianceWhereInput
    /**
     * Limit how many Appliances to delete.
     */
    limit?: number
  }

  /**
   * Appliance.users
   */
  export type Appliance$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    where?: UserApplianceWhereInput
    orderBy?: UserApplianceOrderByWithRelationInput | UserApplianceOrderByWithRelationInput[]
    cursor?: UserApplianceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserApplianceScalarFieldEnum | UserApplianceScalarFieldEnum[]
  }

  /**
   * Appliance without action
   */
  export type ApplianceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appliance
     */
    select?: ApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appliance
     */
    omit?: ApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplianceInclude<ExtArgs> | null
  }


  /**
   * Model UserAppliance
   */

  export type AggregateUserAppliance = {
    _count: UserApplianceCountAggregateOutputType | null
    _avg: UserApplianceAvgAggregateOutputType | null
    _sum: UserApplianceSumAggregateOutputType | null
    _min: UserApplianceMinAggregateOutputType | null
    _max: UserApplianceMaxAggregateOutputType | null
  }

  export type UserApplianceAvgAggregateOutputType = {
    usageFrequency: number | null
  }

  export type UserApplianceSumAggregateOutputType = {
    usageFrequency: number | null
  }

  export type UserApplianceMinAggregateOutputType = {
    id: string | null
    userPreferencesId: string | null
    applianceId: string | null
    usageFrequency: number | null
  }

  export type UserApplianceMaxAggregateOutputType = {
    id: string | null
    userPreferencesId: string | null
    applianceId: string | null
    usageFrequency: number | null
  }

  export type UserApplianceCountAggregateOutputType = {
    id: number
    userPreferencesId: number
    applianceId: number
    usageFrequency: number
    _all: number
  }


  export type UserApplianceAvgAggregateInputType = {
    usageFrequency?: true
  }

  export type UserApplianceSumAggregateInputType = {
    usageFrequency?: true
  }

  export type UserApplianceMinAggregateInputType = {
    id?: true
    userPreferencesId?: true
    applianceId?: true
    usageFrequency?: true
  }

  export type UserApplianceMaxAggregateInputType = {
    id?: true
    userPreferencesId?: true
    applianceId?: true
    usageFrequency?: true
  }

  export type UserApplianceCountAggregateInputType = {
    id?: true
    userPreferencesId?: true
    applianceId?: true
    usageFrequency?: true
    _all?: true
  }

  export type UserApplianceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAppliance to aggregate.
     */
    where?: UserApplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAppliances to fetch.
     */
    orderBy?: UserApplianceOrderByWithRelationInput | UserApplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserApplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAppliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAppliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAppliances
    **/
    _count?: true | UserApplianceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserApplianceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserApplianceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserApplianceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserApplianceMaxAggregateInputType
  }

  export type GetUserApplianceAggregateType<T extends UserApplianceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAppliance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAppliance[P]>
      : GetScalarType<T[P], AggregateUserAppliance[P]>
  }




  export type UserApplianceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApplianceWhereInput
    orderBy?: UserApplianceOrderByWithAggregationInput | UserApplianceOrderByWithAggregationInput[]
    by: UserApplianceScalarFieldEnum[] | UserApplianceScalarFieldEnum
    having?: UserApplianceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserApplianceCountAggregateInputType | true
    _avg?: UserApplianceAvgAggregateInputType
    _sum?: UserApplianceSumAggregateInputType
    _min?: UserApplianceMinAggregateInputType
    _max?: UserApplianceMaxAggregateInputType
  }

  export type UserApplianceGroupByOutputType = {
    id: string
    userPreferencesId: string
    applianceId: string
    usageFrequency: number
    _count: UserApplianceCountAggregateOutputType | null
    _avg: UserApplianceAvgAggregateOutputType | null
    _sum: UserApplianceSumAggregateOutputType | null
    _min: UserApplianceMinAggregateOutputType | null
    _max: UserApplianceMaxAggregateOutputType | null
  }

  type GetUserApplianceGroupByPayload<T extends UserApplianceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserApplianceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserApplianceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserApplianceGroupByOutputType[P]>
            : GetScalarType<T[P], UserApplianceGroupByOutputType[P]>
        }
      >
    >


  export type UserApplianceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPreferencesId?: boolean
    applianceId?: boolean
    usageFrequency?: boolean
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
    appliance?: boolean | ApplianceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAppliance"]>

  export type UserApplianceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPreferencesId?: boolean
    applianceId?: boolean
    usageFrequency?: boolean
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
    appliance?: boolean | ApplianceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAppliance"]>

  export type UserApplianceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPreferencesId?: boolean
    applianceId?: boolean
    usageFrequency?: boolean
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
    appliance?: boolean | ApplianceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAppliance"]>

  export type UserApplianceSelectScalar = {
    id?: boolean
    userPreferencesId?: boolean
    applianceId?: boolean
    usageFrequency?: boolean
  }

  export type UserApplianceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userPreferencesId" | "applianceId" | "usageFrequency", ExtArgs["result"]["userAppliance"]>
  export type UserApplianceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
    appliance?: boolean | ApplianceDefaultArgs<ExtArgs>
  }
  export type UserApplianceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
    appliance?: boolean | ApplianceDefaultArgs<ExtArgs>
  }
  export type UserApplianceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
    appliance?: boolean | ApplianceDefaultArgs<ExtArgs>
  }

  export type $UserAppliancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAppliance"
    objects: {
      userPreferences: Prisma.$UserPreferencesPayload<ExtArgs>
      appliance: Prisma.$AppliancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userPreferencesId: string
      applianceId: string
      usageFrequency: number
    }, ExtArgs["result"]["userAppliance"]>
    composites: {}
  }

  type UserApplianceGetPayload<S extends boolean | null | undefined | UserApplianceDefaultArgs> = $Result.GetResult<Prisma.$UserAppliancePayload, S>

  type UserApplianceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserApplianceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserApplianceCountAggregateInputType | true
    }

  export interface UserApplianceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAppliance'], meta: { name: 'UserAppliance' } }
    /**
     * Find zero or one UserAppliance that matches the filter.
     * @param {UserApplianceFindUniqueArgs} args - Arguments to find a UserAppliance
     * @example
     * // Get one UserAppliance
     * const userAppliance = await prisma.userAppliance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserApplianceFindUniqueArgs>(args: SelectSubset<T, UserApplianceFindUniqueArgs<ExtArgs>>): Prisma__UserApplianceClient<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAppliance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserApplianceFindUniqueOrThrowArgs} args - Arguments to find a UserAppliance
     * @example
     * // Get one UserAppliance
     * const userAppliance = await prisma.userAppliance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserApplianceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserApplianceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserApplianceClient<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAppliance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplianceFindFirstArgs} args - Arguments to find a UserAppliance
     * @example
     * // Get one UserAppliance
     * const userAppliance = await prisma.userAppliance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserApplianceFindFirstArgs>(args?: SelectSubset<T, UserApplianceFindFirstArgs<ExtArgs>>): Prisma__UserApplianceClient<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAppliance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplianceFindFirstOrThrowArgs} args - Arguments to find a UserAppliance
     * @example
     * // Get one UserAppliance
     * const userAppliance = await prisma.userAppliance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserApplianceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserApplianceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserApplianceClient<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAppliances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplianceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAppliances
     * const userAppliances = await prisma.userAppliance.findMany()
     * 
     * // Get first 10 UserAppliances
     * const userAppliances = await prisma.userAppliance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userApplianceWithIdOnly = await prisma.userAppliance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserApplianceFindManyArgs>(args?: SelectSubset<T, UserApplianceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAppliance.
     * @param {UserApplianceCreateArgs} args - Arguments to create a UserAppliance.
     * @example
     * // Create one UserAppliance
     * const UserAppliance = await prisma.userAppliance.create({
     *   data: {
     *     // ... data to create a UserAppliance
     *   }
     * })
     * 
     */
    create<T extends UserApplianceCreateArgs>(args: SelectSubset<T, UserApplianceCreateArgs<ExtArgs>>): Prisma__UserApplianceClient<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAppliances.
     * @param {UserApplianceCreateManyArgs} args - Arguments to create many UserAppliances.
     * @example
     * // Create many UserAppliances
     * const userAppliance = await prisma.userAppliance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserApplianceCreateManyArgs>(args?: SelectSubset<T, UserApplianceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAppliances and returns the data saved in the database.
     * @param {UserApplianceCreateManyAndReturnArgs} args - Arguments to create many UserAppliances.
     * @example
     * // Create many UserAppliances
     * const userAppliance = await prisma.userAppliance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAppliances and only return the `id`
     * const userApplianceWithIdOnly = await prisma.userAppliance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserApplianceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserApplianceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAppliance.
     * @param {UserApplianceDeleteArgs} args - Arguments to delete one UserAppliance.
     * @example
     * // Delete one UserAppliance
     * const UserAppliance = await prisma.userAppliance.delete({
     *   where: {
     *     // ... filter to delete one UserAppliance
     *   }
     * })
     * 
     */
    delete<T extends UserApplianceDeleteArgs>(args: SelectSubset<T, UserApplianceDeleteArgs<ExtArgs>>): Prisma__UserApplianceClient<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAppliance.
     * @param {UserApplianceUpdateArgs} args - Arguments to update one UserAppliance.
     * @example
     * // Update one UserAppliance
     * const userAppliance = await prisma.userAppliance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserApplianceUpdateArgs>(args: SelectSubset<T, UserApplianceUpdateArgs<ExtArgs>>): Prisma__UserApplianceClient<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAppliances.
     * @param {UserApplianceDeleteManyArgs} args - Arguments to filter UserAppliances to delete.
     * @example
     * // Delete a few UserAppliances
     * const { count } = await prisma.userAppliance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserApplianceDeleteManyArgs>(args?: SelectSubset<T, UserApplianceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAppliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplianceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAppliances
     * const userAppliance = await prisma.userAppliance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserApplianceUpdateManyArgs>(args: SelectSubset<T, UserApplianceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAppliances and returns the data updated in the database.
     * @param {UserApplianceUpdateManyAndReturnArgs} args - Arguments to update many UserAppliances.
     * @example
     * // Update many UserAppliances
     * const userAppliance = await prisma.userAppliance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAppliances and only return the `id`
     * const userApplianceWithIdOnly = await prisma.userAppliance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserApplianceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserApplianceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAppliance.
     * @param {UserApplianceUpsertArgs} args - Arguments to update or create a UserAppliance.
     * @example
     * // Update or create a UserAppliance
     * const userAppliance = await prisma.userAppliance.upsert({
     *   create: {
     *     // ... data to create a UserAppliance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAppliance we want to update
     *   }
     * })
     */
    upsert<T extends UserApplianceUpsertArgs>(args: SelectSubset<T, UserApplianceUpsertArgs<ExtArgs>>): Prisma__UserApplianceClient<$Result.GetResult<Prisma.$UserAppliancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAppliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplianceCountArgs} args - Arguments to filter UserAppliances to count.
     * @example
     * // Count the number of UserAppliances
     * const count = await prisma.userAppliance.count({
     *   where: {
     *     // ... the filter for the UserAppliances we want to count
     *   }
     * })
    **/
    count<T extends UserApplianceCountArgs>(
      args?: Subset<T, UserApplianceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserApplianceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAppliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplianceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserApplianceAggregateArgs>(args: Subset<T, UserApplianceAggregateArgs>): Prisma.PrismaPromise<GetUserApplianceAggregateType<T>>

    /**
     * Group by UserAppliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplianceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserApplianceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserApplianceGroupByArgs['orderBy'] }
        : { orderBy?: UserApplianceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserApplianceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserApplianceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAppliance model
   */
  readonly fields: UserApplianceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAppliance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserApplianceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userPreferences<T extends UserPreferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPreferencesDefaultArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appliance<T extends ApplianceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplianceDefaultArgs<ExtArgs>>): Prisma__ApplianceClient<$Result.GetResult<Prisma.$AppliancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAppliance model
   */
  interface UserApplianceFieldRefs {
    readonly id: FieldRef<"UserAppliance", 'String'>
    readonly userPreferencesId: FieldRef<"UserAppliance", 'String'>
    readonly applianceId: FieldRef<"UserAppliance", 'String'>
    readonly usageFrequency: FieldRef<"UserAppliance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserAppliance findUnique
   */
  export type UserApplianceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    /**
     * Filter, which UserAppliance to fetch.
     */
    where: UserApplianceWhereUniqueInput
  }

  /**
   * UserAppliance findUniqueOrThrow
   */
  export type UserApplianceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    /**
     * Filter, which UserAppliance to fetch.
     */
    where: UserApplianceWhereUniqueInput
  }

  /**
   * UserAppliance findFirst
   */
  export type UserApplianceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    /**
     * Filter, which UserAppliance to fetch.
     */
    where?: UserApplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAppliances to fetch.
     */
    orderBy?: UserApplianceOrderByWithRelationInput | UserApplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAppliances.
     */
    cursor?: UserApplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAppliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAppliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAppliances.
     */
    distinct?: UserApplianceScalarFieldEnum | UserApplianceScalarFieldEnum[]
  }

  /**
   * UserAppliance findFirstOrThrow
   */
  export type UserApplianceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    /**
     * Filter, which UserAppliance to fetch.
     */
    where?: UserApplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAppliances to fetch.
     */
    orderBy?: UserApplianceOrderByWithRelationInput | UserApplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAppliances.
     */
    cursor?: UserApplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAppliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAppliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAppliances.
     */
    distinct?: UserApplianceScalarFieldEnum | UserApplianceScalarFieldEnum[]
  }

  /**
   * UserAppliance findMany
   */
  export type UserApplianceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    /**
     * Filter, which UserAppliances to fetch.
     */
    where?: UserApplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAppliances to fetch.
     */
    orderBy?: UserApplianceOrderByWithRelationInput | UserApplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAppliances.
     */
    cursor?: UserApplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAppliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAppliances.
     */
    skip?: number
    distinct?: UserApplianceScalarFieldEnum | UserApplianceScalarFieldEnum[]
  }

  /**
   * UserAppliance create
   */
  export type UserApplianceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAppliance.
     */
    data: XOR<UserApplianceCreateInput, UserApplianceUncheckedCreateInput>
  }

  /**
   * UserAppliance createMany
   */
  export type UserApplianceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAppliances.
     */
    data: UserApplianceCreateManyInput | UserApplianceCreateManyInput[]
  }

  /**
   * UserAppliance createManyAndReturn
   */
  export type UserApplianceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * The data used to create many UserAppliances.
     */
    data: UserApplianceCreateManyInput | UserApplianceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAppliance update
   */
  export type UserApplianceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAppliance.
     */
    data: XOR<UserApplianceUpdateInput, UserApplianceUncheckedUpdateInput>
    /**
     * Choose, which UserAppliance to update.
     */
    where: UserApplianceWhereUniqueInput
  }

  /**
   * UserAppliance updateMany
   */
  export type UserApplianceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAppliances.
     */
    data: XOR<UserApplianceUpdateManyMutationInput, UserApplianceUncheckedUpdateManyInput>
    /**
     * Filter which UserAppliances to update
     */
    where?: UserApplianceWhereInput
    /**
     * Limit how many UserAppliances to update.
     */
    limit?: number
  }

  /**
   * UserAppliance updateManyAndReturn
   */
  export type UserApplianceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * The data used to update UserAppliances.
     */
    data: XOR<UserApplianceUpdateManyMutationInput, UserApplianceUncheckedUpdateManyInput>
    /**
     * Filter which UserAppliances to update
     */
    where?: UserApplianceWhereInput
    /**
     * Limit how many UserAppliances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAppliance upsert
   */
  export type UserApplianceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAppliance to update in case it exists.
     */
    where: UserApplianceWhereUniqueInput
    /**
     * In case the UserAppliance found by the `where` argument doesn't exist, create a new UserAppliance with this data.
     */
    create: XOR<UserApplianceCreateInput, UserApplianceUncheckedCreateInput>
    /**
     * In case the UserAppliance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserApplianceUpdateInput, UserApplianceUncheckedUpdateInput>
  }

  /**
   * UserAppliance delete
   */
  export type UserApplianceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
    /**
     * Filter which UserAppliance to delete.
     */
    where: UserApplianceWhereUniqueInput
  }

  /**
   * UserAppliance deleteMany
   */
  export type UserApplianceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAppliances to delete
     */
    where?: UserApplianceWhereInput
    /**
     * Limit how many UserAppliances to delete.
     */
    limit?: number
  }

  /**
   * UserAppliance without action
   */
  export type UserApplianceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAppliance
     */
    select?: UserApplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAppliance
     */
    omit?: UserApplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplianceInclude<ExtArgs> | null
  }


  /**
   * Model UserBehavior
   */

  export type AggregateUserBehavior = {
    _count: UserBehaviorCountAggregateOutputType | null
    _avg: UserBehaviorAvgAggregateOutputType | null
    _sum: UserBehaviorSumAggregateOutputType | null
    _min: UserBehaviorMinAggregateOutputType | null
    _max: UserBehaviorMaxAggregateOutputType | null
  }

  export type UserBehaviorAvgAggregateOutputType = {
    portionControlMotivation: number | null
    socialEatingPattern: number | null
    healthConditionPriority: number | null
  }

  export type UserBehaviorSumAggregateOutputType = {
    portionControlMotivation: number | null
    socialEatingPattern: number | null
    healthConditionPriority: number | null
  }

  export type UserBehaviorMinAggregateOutputType = {
    id: string | null
    userPreferencesId: string | null
    portionControlMotivation: number | null
    habitChangeReadiness: string | null
    socialEatingPattern: number | null
    successTrackingPreference: string | null
    activityLevel: string | null
    healthConditionPriority: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBehaviorMaxAggregateOutputType = {
    id: string | null
    userPreferencesId: string | null
    portionControlMotivation: number | null
    habitChangeReadiness: string | null
    socialEatingPattern: number | null
    successTrackingPreference: string | null
    activityLevel: string | null
    healthConditionPriority: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBehaviorCountAggregateOutputType = {
    id: number
    userPreferencesId: number
    portionControlMotivation: number
    habitChangeReadiness: number
    socialEatingPattern: number
    successTrackingPreference: number
    activityLevel: number
    healthConditionPriority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserBehaviorAvgAggregateInputType = {
    portionControlMotivation?: true
    socialEatingPattern?: true
    healthConditionPriority?: true
  }

  export type UserBehaviorSumAggregateInputType = {
    portionControlMotivation?: true
    socialEatingPattern?: true
    healthConditionPriority?: true
  }

  export type UserBehaviorMinAggregateInputType = {
    id?: true
    userPreferencesId?: true
    portionControlMotivation?: true
    habitChangeReadiness?: true
    socialEatingPattern?: true
    successTrackingPreference?: true
    activityLevel?: true
    healthConditionPriority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBehaviorMaxAggregateInputType = {
    id?: true
    userPreferencesId?: true
    portionControlMotivation?: true
    habitChangeReadiness?: true
    socialEatingPattern?: true
    successTrackingPreference?: true
    activityLevel?: true
    healthConditionPriority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBehaviorCountAggregateInputType = {
    id?: true
    userPreferencesId?: true
    portionControlMotivation?: true
    habitChangeReadiness?: true
    socialEatingPattern?: true
    successTrackingPreference?: true
    activityLevel?: true
    healthConditionPriority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserBehaviorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBehavior to aggregate.
     */
    where?: UserBehaviorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBehaviors to fetch.
     */
    orderBy?: UserBehaviorOrderByWithRelationInput | UserBehaviorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBehaviorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBehaviors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBehaviors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBehaviors
    **/
    _count?: true | UserBehaviorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBehaviorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBehaviorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBehaviorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBehaviorMaxAggregateInputType
  }

  export type GetUserBehaviorAggregateType<T extends UserBehaviorAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBehavior]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBehavior[P]>
      : GetScalarType<T[P], AggregateUserBehavior[P]>
  }




  export type UserBehaviorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBehaviorWhereInput
    orderBy?: UserBehaviorOrderByWithAggregationInput | UserBehaviorOrderByWithAggregationInput[]
    by: UserBehaviorScalarFieldEnum[] | UserBehaviorScalarFieldEnum
    having?: UserBehaviorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBehaviorCountAggregateInputType | true
    _avg?: UserBehaviorAvgAggregateInputType
    _sum?: UserBehaviorSumAggregateInputType
    _min?: UserBehaviorMinAggregateInputType
    _max?: UserBehaviorMaxAggregateInputType
  }

  export type UserBehaviorGroupByOutputType = {
    id: string
    userPreferencesId: string
    portionControlMotivation: number
    habitChangeReadiness: string | null
    socialEatingPattern: number
    successTrackingPreference: string
    activityLevel: string
    healthConditionPriority: number
    createdAt: Date
    updatedAt: Date
    _count: UserBehaviorCountAggregateOutputType | null
    _avg: UserBehaviorAvgAggregateOutputType | null
    _sum: UserBehaviorSumAggregateOutputType | null
    _min: UserBehaviorMinAggregateOutputType | null
    _max: UserBehaviorMaxAggregateOutputType | null
  }

  type GetUserBehaviorGroupByPayload<T extends UserBehaviorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBehaviorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBehaviorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBehaviorGroupByOutputType[P]>
            : GetScalarType<T[P], UserBehaviorGroupByOutputType[P]>
        }
      >
    >


  export type UserBehaviorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPreferencesId?: boolean
    portionControlMotivation?: boolean
    habitChangeReadiness?: boolean
    socialEatingPattern?: boolean
    successTrackingPreference?: boolean
    activityLevel?: boolean
    healthConditionPriority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBehavior"]>

  export type UserBehaviorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPreferencesId?: boolean
    portionControlMotivation?: boolean
    habitChangeReadiness?: boolean
    socialEatingPattern?: boolean
    successTrackingPreference?: boolean
    activityLevel?: boolean
    healthConditionPriority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBehavior"]>

  export type UserBehaviorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userPreferencesId?: boolean
    portionControlMotivation?: boolean
    habitChangeReadiness?: boolean
    socialEatingPattern?: boolean
    successTrackingPreference?: boolean
    activityLevel?: boolean
    healthConditionPriority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBehavior"]>

  export type UserBehaviorSelectScalar = {
    id?: boolean
    userPreferencesId?: boolean
    portionControlMotivation?: boolean
    habitChangeReadiness?: boolean
    socialEatingPattern?: boolean
    successTrackingPreference?: boolean
    activityLevel?: boolean
    healthConditionPriority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserBehaviorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userPreferencesId" | "portionControlMotivation" | "habitChangeReadiness" | "socialEatingPattern" | "successTrackingPreference" | "activityLevel" | "healthConditionPriority" | "createdAt" | "updatedAt", ExtArgs["result"]["userBehavior"]>
  export type UserBehaviorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
  }
  export type UserBehaviorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
  }
  export type UserBehaviorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userPreferences?: boolean | UserPreferencesDefaultArgs<ExtArgs>
  }

  export type $UserBehaviorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBehavior"
    objects: {
      userPreferences: Prisma.$UserPreferencesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userPreferencesId: string
      portionControlMotivation: number
      habitChangeReadiness: string | null
      socialEatingPattern: number
      successTrackingPreference: string
      activityLevel: string
      healthConditionPriority: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userBehavior"]>
    composites: {}
  }

  type UserBehaviorGetPayload<S extends boolean | null | undefined | UserBehaviorDefaultArgs> = $Result.GetResult<Prisma.$UserBehaviorPayload, S>

  type UserBehaviorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBehaviorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBehaviorCountAggregateInputType | true
    }

  export interface UserBehaviorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBehavior'], meta: { name: 'UserBehavior' } }
    /**
     * Find zero or one UserBehavior that matches the filter.
     * @param {UserBehaviorFindUniqueArgs} args - Arguments to find a UserBehavior
     * @example
     * // Get one UserBehavior
     * const userBehavior = await prisma.userBehavior.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBehaviorFindUniqueArgs>(args: SelectSubset<T, UserBehaviorFindUniqueArgs<ExtArgs>>): Prisma__UserBehaviorClient<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBehavior that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBehaviorFindUniqueOrThrowArgs} args - Arguments to find a UserBehavior
     * @example
     * // Get one UserBehavior
     * const userBehavior = await prisma.userBehavior.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBehaviorFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBehaviorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBehaviorClient<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBehavior that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBehaviorFindFirstArgs} args - Arguments to find a UserBehavior
     * @example
     * // Get one UserBehavior
     * const userBehavior = await prisma.userBehavior.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBehaviorFindFirstArgs>(args?: SelectSubset<T, UserBehaviorFindFirstArgs<ExtArgs>>): Prisma__UserBehaviorClient<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBehavior that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBehaviorFindFirstOrThrowArgs} args - Arguments to find a UserBehavior
     * @example
     * // Get one UserBehavior
     * const userBehavior = await prisma.userBehavior.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBehaviorFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBehaviorFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBehaviorClient<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBehaviors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBehaviorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBehaviors
     * const userBehaviors = await prisma.userBehavior.findMany()
     * 
     * // Get first 10 UserBehaviors
     * const userBehaviors = await prisma.userBehavior.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBehaviorWithIdOnly = await prisma.userBehavior.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBehaviorFindManyArgs>(args?: SelectSubset<T, UserBehaviorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBehavior.
     * @param {UserBehaviorCreateArgs} args - Arguments to create a UserBehavior.
     * @example
     * // Create one UserBehavior
     * const UserBehavior = await prisma.userBehavior.create({
     *   data: {
     *     // ... data to create a UserBehavior
     *   }
     * })
     * 
     */
    create<T extends UserBehaviorCreateArgs>(args: SelectSubset<T, UserBehaviorCreateArgs<ExtArgs>>): Prisma__UserBehaviorClient<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBehaviors.
     * @param {UserBehaviorCreateManyArgs} args - Arguments to create many UserBehaviors.
     * @example
     * // Create many UserBehaviors
     * const userBehavior = await prisma.userBehavior.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBehaviorCreateManyArgs>(args?: SelectSubset<T, UserBehaviorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBehaviors and returns the data saved in the database.
     * @param {UserBehaviorCreateManyAndReturnArgs} args - Arguments to create many UserBehaviors.
     * @example
     * // Create many UserBehaviors
     * const userBehavior = await prisma.userBehavior.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBehaviors and only return the `id`
     * const userBehaviorWithIdOnly = await prisma.userBehavior.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBehaviorCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBehaviorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBehavior.
     * @param {UserBehaviorDeleteArgs} args - Arguments to delete one UserBehavior.
     * @example
     * // Delete one UserBehavior
     * const UserBehavior = await prisma.userBehavior.delete({
     *   where: {
     *     // ... filter to delete one UserBehavior
     *   }
     * })
     * 
     */
    delete<T extends UserBehaviorDeleteArgs>(args: SelectSubset<T, UserBehaviorDeleteArgs<ExtArgs>>): Prisma__UserBehaviorClient<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBehavior.
     * @param {UserBehaviorUpdateArgs} args - Arguments to update one UserBehavior.
     * @example
     * // Update one UserBehavior
     * const userBehavior = await prisma.userBehavior.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBehaviorUpdateArgs>(args: SelectSubset<T, UserBehaviorUpdateArgs<ExtArgs>>): Prisma__UserBehaviorClient<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBehaviors.
     * @param {UserBehaviorDeleteManyArgs} args - Arguments to filter UserBehaviors to delete.
     * @example
     * // Delete a few UserBehaviors
     * const { count } = await prisma.userBehavior.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBehaviorDeleteManyArgs>(args?: SelectSubset<T, UserBehaviorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBehaviors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBehaviorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBehaviors
     * const userBehavior = await prisma.userBehavior.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBehaviorUpdateManyArgs>(args: SelectSubset<T, UserBehaviorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBehaviors and returns the data updated in the database.
     * @param {UserBehaviorUpdateManyAndReturnArgs} args - Arguments to update many UserBehaviors.
     * @example
     * // Update many UserBehaviors
     * const userBehavior = await prisma.userBehavior.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBehaviors and only return the `id`
     * const userBehaviorWithIdOnly = await prisma.userBehavior.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBehaviorUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBehaviorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBehavior.
     * @param {UserBehaviorUpsertArgs} args - Arguments to update or create a UserBehavior.
     * @example
     * // Update or create a UserBehavior
     * const userBehavior = await prisma.userBehavior.upsert({
     *   create: {
     *     // ... data to create a UserBehavior
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBehavior we want to update
     *   }
     * })
     */
    upsert<T extends UserBehaviorUpsertArgs>(args: SelectSubset<T, UserBehaviorUpsertArgs<ExtArgs>>): Prisma__UserBehaviorClient<$Result.GetResult<Prisma.$UserBehaviorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBehaviors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBehaviorCountArgs} args - Arguments to filter UserBehaviors to count.
     * @example
     * // Count the number of UserBehaviors
     * const count = await prisma.userBehavior.count({
     *   where: {
     *     // ... the filter for the UserBehaviors we want to count
     *   }
     * })
    **/
    count<T extends UserBehaviorCountArgs>(
      args?: Subset<T, UserBehaviorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBehaviorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBehavior.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBehaviorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBehaviorAggregateArgs>(args: Subset<T, UserBehaviorAggregateArgs>): Prisma.PrismaPromise<GetUserBehaviorAggregateType<T>>

    /**
     * Group by UserBehavior.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBehaviorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBehaviorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBehaviorGroupByArgs['orderBy'] }
        : { orderBy?: UserBehaviorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBehaviorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBehaviorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBehavior model
   */
  readonly fields: UserBehaviorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBehavior.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBehaviorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userPreferences<T extends UserPreferencesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserPreferencesDefaultArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBehavior model
   */
  interface UserBehaviorFieldRefs {
    readonly id: FieldRef<"UserBehavior", 'String'>
    readonly userPreferencesId: FieldRef<"UserBehavior", 'String'>
    readonly portionControlMotivation: FieldRef<"UserBehavior", 'Int'>
    readonly habitChangeReadiness: FieldRef<"UserBehavior", 'String'>
    readonly socialEatingPattern: FieldRef<"UserBehavior", 'Int'>
    readonly successTrackingPreference: FieldRef<"UserBehavior", 'String'>
    readonly activityLevel: FieldRef<"UserBehavior", 'String'>
    readonly healthConditionPriority: FieldRef<"UserBehavior", 'Int'>
    readonly createdAt: FieldRef<"UserBehavior", 'DateTime'>
    readonly updatedAt: FieldRef<"UserBehavior", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBehavior findUnique
   */
  export type UserBehaviorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBehavior to fetch.
     */
    where: UserBehaviorWhereUniqueInput
  }

  /**
   * UserBehavior findUniqueOrThrow
   */
  export type UserBehaviorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBehavior to fetch.
     */
    where: UserBehaviorWhereUniqueInput
  }

  /**
   * UserBehavior findFirst
   */
  export type UserBehaviorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBehavior to fetch.
     */
    where?: UserBehaviorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBehaviors to fetch.
     */
    orderBy?: UserBehaviorOrderByWithRelationInput | UserBehaviorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBehaviors.
     */
    cursor?: UserBehaviorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBehaviors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBehaviors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBehaviors.
     */
    distinct?: UserBehaviorScalarFieldEnum | UserBehaviorScalarFieldEnum[]
  }

  /**
   * UserBehavior findFirstOrThrow
   */
  export type UserBehaviorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBehavior to fetch.
     */
    where?: UserBehaviorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBehaviors to fetch.
     */
    orderBy?: UserBehaviorOrderByWithRelationInput | UserBehaviorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBehaviors.
     */
    cursor?: UserBehaviorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBehaviors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBehaviors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBehaviors.
     */
    distinct?: UserBehaviorScalarFieldEnum | UserBehaviorScalarFieldEnum[]
  }

  /**
   * UserBehavior findMany
   */
  export type UserBehaviorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    /**
     * Filter, which UserBehaviors to fetch.
     */
    where?: UserBehaviorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBehaviors to fetch.
     */
    orderBy?: UserBehaviorOrderByWithRelationInput | UserBehaviorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBehaviors.
     */
    cursor?: UserBehaviorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBehaviors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBehaviors.
     */
    skip?: number
    distinct?: UserBehaviorScalarFieldEnum | UserBehaviorScalarFieldEnum[]
  }

  /**
   * UserBehavior create
   */
  export type UserBehaviorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBehavior.
     */
    data: XOR<UserBehaviorCreateInput, UserBehaviorUncheckedCreateInput>
  }

  /**
   * UserBehavior createMany
   */
  export type UserBehaviorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBehaviors.
     */
    data: UserBehaviorCreateManyInput | UserBehaviorCreateManyInput[]
  }

  /**
   * UserBehavior createManyAndReturn
   */
  export type UserBehaviorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * The data used to create many UserBehaviors.
     */
    data: UserBehaviorCreateManyInput | UserBehaviorCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBehavior update
   */
  export type UserBehaviorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBehavior.
     */
    data: XOR<UserBehaviorUpdateInput, UserBehaviorUncheckedUpdateInput>
    /**
     * Choose, which UserBehavior to update.
     */
    where: UserBehaviorWhereUniqueInput
  }

  /**
   * UserBehavior updateMany
   */
  export type UserBehaviorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBehaviors.
     */
    data: XOR<UserBehaviorUpdateManyMutationInput, UserBehaviorUncheckedUpdateManyInput>
    /**
     * Filter which UserBehaviors to update
     */
    where?: UserBehaviorWhereInput
    /**
     * Limit how many UserBehaviors to update.
     */
    limit?: number
  }

  /**
   * UserBehavior updateManyAndReturn
   */
  export type UserBehaviorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * The data used to update UserBehaviors.
     */
    data: XOR<UserBehaviorUpdateManyMutationInput, UserBehaviorUncheckedUpdateManyInput>
    /**
     * Filter which UserBehaviors to update
     */
    where?: UserBehaviorWhereInput
    /**
     * Limit how many UserBehaviors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBehavior upsert
   */
  export type UserBehaviorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBehavior to update in case it exists.
     */
    where: UserBehaviorWhereUniqueInput
    /**
     * In case the UserBehavior found by the `where` argument doesn't exist, create a new UserBehavior with this data.
     */
    create: XOR<UserBehaviorCreateInput, UserBehaviorUncheckedCreateInput>
    /**
     * In case the UserBehavior was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBehaviorUpdateInput, UserBehaviorUncheckedUpdateInput>
  }

  /**
   * UserBehavior delete
   */
  export type UserBehaviorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
    /**
     * Filter which UserBehavior to delete.
     */
    where: UserBehaviorWhereUniqueInput
  }

  /**
   * UserBehavior deleteMany
   */
  export type UserBehaviorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBehaviors to delete
     */
    where?: UserBehaviorWhereInput
    /**
     * Limit how many UserBehaviors to delete.
     */
    limit?: number
  }

  /**
   * UserBehavior without action
   */
  export type UserBehaviorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBehavior
     */
    select?: UserBehaviorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBehavior
     */
    omit?: UserBehaviorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBehaviorInclude<ExtArgs> | null
  }


  /**
   * Model SpiceBlend
   */

  export type AggregateSpiceBlend = {
    _count: SpiceBlendCountAggregateOutputType | null
    _avg: SpiceBlendAvgAggregateOutputType | null
    _sum: SpiceBlendSumAggregateOutputType | null
    _min: SpiceBlendMinAggregateOutputType | null
    _max: SpiceBlendMaxAggregateOutputType | null
  }

  export type SpiceBlendAvgAggregateOutputType = {
    effectiveDoseGrams: number | null
  }

  export type SpiceBlendSumAggregateOutputType = {
    effectiveDoseGrams: number | null
  }

  export type SpiceBlendMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    activeCompounds: string | null
    clinicalEvidence: string | null
    primaryBenefit: string | null
    effectiveDoseGrams: number | null
    bioavailabilityHack: string | null
    quickApplications: string | null
  }

  export type SpiceBlendMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    activeCompounds: string | null
    clinicalEvidence: string | null
    primaryBenefit: string | null
    effectiveDoseGrams: number | null
    bioavailabilityHack: string | null
    quickApplications: string | null
  }

  export type SpiceBlendCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    activeCompounds: number
    clinicalEvidence: number
    primaryBenefit: number
    effectiveDoseGrams: number
    bioavailabilityHack: number
    quickApplications: number
    _all: number
  }


  export type SpiceBlendAvgAggregateInputType = {
    effectiveDoseGrams?: true
  }

  export type SpiceBlendSumAggregateInputType = {
    effectiveDoseGrams?: true
  }

  export type SpiceBlendMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    activeCompounds?: true
    clinicalEvidence?: true
    primaryBenefit?: true
    effectiveDoseGrams?: true
    bioavailabilityHack?: true
    quickApplications?: true
  }

  export type SpiceBlendMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    activeCompounds?: true
    clinicalEvidence?: true
    primaryBenefit?: true
    effectiveDoseGrams?: true
    bioavailabilityHack?: true
    quickApplications?: true
  }

  export type SpiceBlendCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    activeCompounds?: true
    clinicalEvidence?: true
    primaryBenefit?: true
    effectiveDoseGrams?: true
    bioavailabilityHack?: true
    quickApplications?: true
    _all?: true
  }

  export type SpiceBlendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpiceBlend to aggregate.
     */
    where?: SpiceBlendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiceBlends to fetch.
     */
    orderBy?: SpiceBlendOrderByWithRelationInput | SpiceBlendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpiceBlendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiceBlends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiceBlends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpiceBlends
    **/
    _count?: true | SpiceBlendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpiceBlendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpiceBlendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpiceBlendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpiceBlendMaxAggregateInputType
  }

  export type GetSpiceBlendAggregateType<T extends SpiceBlendAggregateArgs> = {
        [P in keyof T & keyof AggregateSpiceBlend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpiceBlend[P]>
      : GetScalarType<T[P], AggregateSpiceBlend[P]>
  }




  export type SpiceBlendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpiceBlendWhereInput
    orderBy?: SpiceBlendOrderByWithAggregationInput | SpiceBlendOrderByWithAggregationInput[]
    by: SpiceBlendScalarFieldEnum[] | SpiceBlendScalarFieldEnum
    having?: SpiceBlendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpiceBlendCountAggregateInputType | true
    _avg?: SpiceBlendAvgAggregateInputType
    _sum?: SpiceBlendSumAggregateInputType
    _min?: SpiceBlendMinAggregateInputType
    _max?: SpiceBlendMaxAggregateInputType
  }

  export type SpiceBlendGroupByOutputType = {
    id: string
    name: string
    displayName: string
    activeCompounds: string
    clinicalEvidence: string
    primaryBenefit: string
    effectiveDoseGrams: number
    bioavailabilityHack: string | null
    quickApplications: string
    _count: SpiceBlendCountAggregateOutputType | null
    _avg: SpiceBlendAvgAggregateOutputType | null
    _sum: SpiceBlendSumAggregateOutputType | null
    _min: SpiceBlendMinAggregateOutputType | null
    _max: SpiceBlendMaxAggregateOutputType | null
  }

  type GetSpiceBlendGroupByPayload<T extends SpiceBlendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpiceBlendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpiceBlendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpiceBlendGroupByOutputType[P]>
            : GetScalarType<T[P], SpiceBlendGroupByOutputType[P]>
        }
      >
    >


  export type SpiceBlendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    activeCompounds?: boolean
    clinicalEvidence?: boolean
    primaryBenefit?: boolean
    effectiveDoseGrams?: boolean
    bioavailabilityHack?: boolean
    quickApplications?: boolean
    recipes?: boolean | SpiceBlend$recipesArgs<ExtArgs>
    _count?: boolean | SpiceBlendCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spiceBlend"]>

  export type SpiceBlendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    activeCompounds?: boolean
    clinicalEvidence?: boolean
    primaryBenefit?: boolean
    effectiveDoseGrams?: boolean
    bioavailabilityHack?: boolean
    quickApplications?: boolean
  }, ExtArgs["result"]["spiceBlend"]>

  export type SpiceBlendSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    activeCompounds?: boolean
    clinicalEvidence?: boolean
    primaryBenefit?: boolean
    effectiveDoseGrams?: boolean
    bioavailabilityHack?: boolean
    quickApplications?: boolean
  }, ExtArgs["result"]["spiceBlend"]>

  export type SpiceBlendSelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    activeCompounds?: boolean
    clinicalEvidence?: boolean
    primaryBenefit?: boolean
    effectiveDoseGrams?: boolean
    bioavailabilityHack?: boolean
    quickApplications?: boolean
  }

  export type SpiceBlendOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "displayName" | "activeCompounds" | "clinicalEvidence" | "primaryBenefit" | "effectiveDoseGrams" | "bioavailabilityHack" | "quickApplications", ExtArgs["result"]["spiceBlend"]>
  export type SpiceBlendInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | SpiceBlend$recipesArgs<ExtArgs>
    _count?: boolean | SpiceBlendCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpiceBlendIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SpiceBlendIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpiceBlendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpiceBlend"
    objects: {
      recipes: Prisma.$RecipeSpiceBlendPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      displayName: string
      activeCompounds: string
      clinicalEvidence: string
      primaryBenefit: string
      effectiveDoseGrams: number
      bioavailabilityHack: string | null
      quickApplications: string
    }, ExtArgs["result"]["spiceBlend"]>
    composites: {}
  }

  type SpiceBlendGetPayload<S extends boolean | null | undefined | SpiceBlendDefaultArgs> = $Result.GetResult<Prisma.$SpiceBlendPayload, S>

  type SpiceBlendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpiceBlendFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpiceBlendCountAggregateInputType | true
    }

  export interface SpiceBlendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpiceBlend'], meta: { name: 'SpiceBlend' } }
    /**
     * Find zero or one SpiceBlend that matches the filter.
     * @param {SpiceBlendFindUniqueArgs} args - Arguments to find a SpiceBlend
     * @example
     * // Get one SpiceBlend
     * const spiceBlend = await prisma.spiceBlend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpiceBlendFindUniqueArgs>(args: SelectSubset<T, SpiceBlendFindUniqueArgs<ExtArgs>>): Prisma__SpiceBlendClient<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpiceBlend that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpiceBlendFindUniqueOrThrowArgs} args - Arguments to find a SpiceBlend
     * @example
     * // Get one SpiceBlend
     * const spiceBlend = await prisma.spiceBlend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpiceBlendFindUniqueOrThrowArgs>(args: SelectSubset<T, SpiceBlendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpiceBlendClient<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpiceBlend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiceBlendFindFirstArgs} args - Arguments to find a SpiceBlend
     * @example
     * // Get one SpiceBlend
     * const spiceBlend = await prisma.spiceBlend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpiceBlendFindFirstArgs>(args?: SelectSubset<T, SpiceBlendFindFirstArgs<ExtArgs>>): Prisma__SpiceBlendClient<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpiceBlend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiceBlendFindFirstOrThrowArgs} args - Arguments to find a SpiceBlend
     * @example
     * // Get one SpiceBlend
     * const spiceBlend = await prisma.spiceBlend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpiceBlendFindFirstOrThrowArgs>(args?: SelectSubset<T, SpiceBlendFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpiceBlendClient<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpiceBlends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiceBlendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpiceBlends
     * const spiceBlends = await prisma.spiceBlend.findMany()
     * 
     * // Get first 10 SpiceBlends
     * const spiceBlends = await prisma.spiceBlend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spiceBlendWithIdOnly = await prisma.spiceBlend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpiceBlendFindManyArgs>(args?: SelectSubset<T, SpiceBlendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpiceBlend.
     * @param {SpiceBlendCreateArgs} args - Arguments to create a SpiceBlend.
     * @example
     * // Create one SpiceBlend
     * const SpiceBlend = await prisma.spiceBlend.create({
     *   data: {
     *     // ... data to create a SpiceBlend
     *   }
     * })
     * 
     */
    create<T extends SpiceBlendCreateArgs>(args: SelectSubset<T, SpiceBlendCreateArgs<ExtArgs>>): Prisma__SpiceBlendClient<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpiceBlends.
     * @param {SpiceBlendCreateManyArgs} args - Arguments to create many SpiceBlends.
     * @example
     * // Create many SpiceBlends
     * const spiceBlend = await prisma.spiceBlend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpiceBlendCreateManyArgs>(args?: SelectSubset<T, SpiceBlendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpiceBlends and returns the data saved in the database.
     * @param {SpiceBlendCreateManyAndReturnArgs} args - Arguments to create many SpiceBlends.
     * @example
     * // Create many SpiceBlends
     * const spiceBlend = await prisma.spiceBlend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpiceBlends and only return the `id`
     * const spiceBlendWithIdOnly = await prisma.spiceBlend.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpiceBlendCreateManyAndReturnArgs>(args?: SelectSubset<T, SpiceBlendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpiceBlend.
     * @param {SpiceBlendDeleteArgs} args - Arguments to delete one SpiceBlend.
     * @example
     * // Delete one SpiceBlend
     * const SpiceBlend = await prisma.spiceBlend.delete({
     *   where: {
     *     // ... filter to delete one SpiceBlend
     *   }
     * })
     * 
     */
    delete<T extends SpiceBlendDeleteArgs>(args: SelectSubset<T, SpiceBlendDeleteArgs<ExtArgs>>): Prisma__SpiceBlendClient<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpiceBlend.
     * @param {SpiceBlendUpdateArgs} args - Arguments to update one SpiceBlend.
     * @example
     * // Update one SpiceBlend
     * const spiceBlend = await prisma.spiceBlend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpiceBlendUpdateArgs>(args: SelectSubset<T, SpiceBlendUpdateArgs<ExtArgs>>): Prisma__SpiceBlendClient<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpiceBlends.
     * @param {SpiceBlendDeleteManyArgs} args - Arguments to filter SpiceBlends to delete.
     * @example
     * // Delete a few SpiceBlends
     * const { count } = await prisma.spiceBlend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpiceBlendDeleteManyArgs>(args?: SelectSubset<T, SpiceBlendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpiceBlends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiceBlendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpiceBlends
     * const spiceBlend = await prisma.spiceBlend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpiceBlendUpdateManyArgs>(args: SelectSubset<T, SpiceBlendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpiceBlends and returns the data updated in the database.
     * @param {SpiceBlendUpdateManyAndReturnArgs} args - Arguments to update many SpiceBlends.
     * @example
     * // Update many SpiceBlends
     * const spiceBlend = await prisma.spiceBlend.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpiceBlends and only return the `id`
     * const spiceBlendWithIdOnly = await prisma.spiceBlend.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpiceBlendUpdateManyAndReturnArgs>(args: SelectSubset<T, SpiceBlendUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpiceBlend.
     * @param {SpiceBlendUpsertArgs} args - Arguments to update or create a SpiceBlend.
     * @example
     * // Update or create a SpiceBlend
     * const spiceBlend = await prisma.spiceBlend.upsert({
     *   create: {
     *     // ... data to create a SpiceBlend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpiceBlend we want to update
     *   }
     * })
     */
    upsert<T extends SpiceBlendUpsertArgs>(args: SelectSubset<T, SpiceBlendUpsertArgs<ExtArgs>>): Prisma__SpiceBlendClient<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpiceBlends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiceBlendCountArgs} args - Arguments to filter SpiceBlends to count.
     * @example
     * // Count the number of SpiceBlends
     * const count = await prisma.spiceBlend.count({
     *   where: {
     *     // ... the filter for the SpiceBlends we want to count
     *   }
     * })
    **/
    count<T extends SpiceBlendCountArgs>(
      args?: Subset<T, SpiceBlendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpiceBlendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpiceBlend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiceBlendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpiceBlendAggregateArgs>(args: Subset<T, SpiceBlendAggregateArgs>): Prisma.PrismaPromise<GetSpiceBlendAggregateType<T>>

    /**
     * Group by SpiceBlend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpiceBlendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpiceBlendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpiceBlendGroupByArgs['orderBy'] }
        : { orderBy?: SpiceBlendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpiceBlendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpiceBlendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpiceBlend model
   */
  readonly fields: SpiceBlendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpiceBlend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpiceBlendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipes<T extends SpiceBlend$recipesArgs<ExtArgs> = {}>(args?: Subset<T, SpiceBlend$recipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpiceBlend model
   */
  interface SpiceBlendFieldRefs {
    readonly id: FieldRef<"SpiceBlend", 'String'>
    readonly name: FieldRef<"SpiceBlend", 'String'>
    readonly displayName: FieldRef<"SpiceBlend", 'String'>
    readonly activeCompounds: FieldRef<"SpiceBlend", 'String'>
    readonly clinicalEvidence: FieldRef<"SpiceBlend", 'String'>
    readonly primaryBenefit: FieldRef<"SpiceBlend", 'String'>
    readonly effectiveDoseGrams: FieldRef<"SpiceBlend", 'Float'>
    readonly bioavailabilityHack: FieldRef<"SpiceBlend", 'String'>
    readonly quickApplications: FieldRef<"SpiceBlend", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpiceBlend findUnique
   */
  export type SpiceBlendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which SpiceBlend to fetch.
     */
    where: SpiceBlendWhereUniqueInput
  }

  /**
   * SpiceBlend findUniqueOrThrow
   */
  export type SpiceBlendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which SpiceBlend to fetch.
     */
    where: SpiceBlendWhereUniqueInput
  }

  /**
   * SpiceBlend findFirst
   */
  export type SpiceBlendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which SpiceBlend to fetch.
     */
    where?: SpiceBlendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiceBlends to fetch.
     */
    orderBy?: SpiceBlendOrderByWithRelationInput | SpiceBlendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpiceBlends.
     */
    cursor?: SpiceBlendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiceBlends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiceBlends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpiceBlends.
     */
    distinct?: SpiceBlendScalarFieldEnum | SpiceBlendScalarFieldEnum[]
  }

  /**
   * SpiceBlend findFirstOrThrow
   */
  export type SpiceBlendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which SpiceBlend to fetch.
     */
    where?: SpiceBlendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiceBlends to fetch.
     */
    orderBy?: SpiceBlendOrderByWithRelationInput | SpiceBlendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpiceBlends.
     */
    cursor?: SpiceBlendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiceBlends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiceBlends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpiceBlends.
     */
    distinct?: SpiceBlendScalarFieldEnum | SpiceBlendScalarFieldEnum[]
  }

  /**
   * SpiceBlend findMany
   */
  export type SpiceBlendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which SpiceBlends to fetch.
     */
    where?: SpiceBlendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpiceBlends to fetch.
     */
    orderBy?: SpiceBlendOrderByWithRelationInput | SpiceBlendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpiceBlends.
     */
    cursor?: SpiceBlendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpiceBlends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpiceBlends.
     */
    skip?: number
    distinct?: SpiceBlendScalarFieldEnum | SpiceBlendScalarFieldEnum[]
  }

  /**
   * SpiceBlend create
   */
  export type SpiceBlendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
    /**
     * The data needed to create a SpiceBlend.
     */
    data: XOR<SpiceBlendCreateInput, SpiceBlendUncheckedCreateInput>
  }

  /**
   * SpiceBlend createMany
   */
  export type SpiceBlendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpiceBlends.
     */
    data: SpiceBlendCreateManyInput | SpiceBlendCreateManyInput[]
  }

  /**
   * SpiceBlend createManyAndReturn
   */
  export type SpiceBlendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * The data used to create many SpiceBlends.
     */
    data: SpiceBlendCreateManyInput | SpiceBlendCreateManyInput[]
  }

  /**
   * SpiceBlend update
   */
  export type SpiceBlendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
    /**
     * The data needed to update a SpiceBlend.
     */
    data: XOR<SpiceBlendUpdateInput, SpiceBlendUncheckedUpdateInput>
    /**
     * Choose, which SpiceBlend to update.
     */
    where: SpiceBlendWhereUniqueInput
  }

  /**
   * SpiceBlend updateMany
   */
  export type SpiceBlendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpiceBlends.
     */
    data: XOR<SpiceBlendUpdateManyMutationInput, SpiceBlendUncheckedUpdateManyInput>
    /**
     * Filter which SpiceBlends to update
     */
    where?: SpiceBlendWhereInput
    /**
     * Limit how many SpiceBlends to update.
     */
    limit?: number
  }

  /**
   * SpiceBlend updateManyAndReturn
   */
  export type SpiceBlendUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * The data used to update SpiceBlends.
     */
    data: XOR<SpiceBlendUpdateManyMutationInput, SpiceBlendUncheckedUpdateManyInput>
    /**
     * Filter which SpiceBlends to update
     */
    where?: SpiceBlendWhereInput
    /**
     * Limit how many SpiceBlends to update.
     */
    limit?: number
  }

  /**
   * SpiceBlend upsert
   */
  export type SpiceBlendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
    /**
     * The filter to search for the SpiceBlend to update in case it exists.
     */
    where: SpiceBlendWhereUniqueInput
    /**
     * In case the SpiceBlend found by the `where` argument doesn't exist, create a new SpiceBlend with this data.
     */
    create: XOR<SpiceBlendCreateInput, SpiceBlendUncheckedCreateInput>
    /**
     * In case the SpiceBlend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpiceBlendUpdateInput, SpiceBlendUncheckedUpdateInput>
  }

  /**
   * SpiceBlend delete
   */
  export type SpiceBlendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
    /**
     * Filter which SpiceBlend to delete.
     */
    where: SpiceBlendWhereUniqueInput
  }

  /**
   * SpiceBlend deleteMany
   */
  export type SpiceBlendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpiceBlends to delete
     */
    where?: SpiceBlendWhereInput
    /**
     * Limit how many SpiceBlends to delete.
     */
    limit?: number
  }

  /**
   * SpiceBlend.recipes
   */
  export type SpiceBlend$recipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    where?: RecipeSpiceBlendWhereInput
    orderBy?: RecipeSpiceBlendOrderByWithRelationInput | RecipeSpiceBlendOrderByWithRelationInput[]
    cursor?: RecipeSpiceBlendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeSpiceBlendScalarFieldEnum | RecipeSpiceBlendScalarFieldEnum[]
  }

  /**
   * SpiceBlend without action
   */
  export type SpiceBlendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpiceBlend
     */
    select?: SpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpiceBlend
     */
    omit?: SpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpiceBlendInclude<ExtArgs> | null
  }


  /**
   * Model RecipeSpiceBlend
   */

  export type AggregateRecipeSpiceBlend = {
    _count: RecipeSpiceBlendCountAggregateOutputType | null
    _avg: RecipeSpiceBlendAvgAggregateOutputType | null
    _sum: RecipeSpiceBlendSumAggregateOutputType | null
    _min: RecipeSpiceBlendMinAggregateOutputType | null
    _max: RecipeSpiceBlendMaxAggregateOutputType | null
  }

  export type RecipeSpiceBlendAvgAggregateOutputType = {
    amountGrams: number | null
  }

  export type RecipeSpiceBlendSumAggregateOutputType = {
    amountGrams: number | null
  }

  export type RecipeSpiceBlendMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    spiceBlendId: string | null
    amountGrams: number | null
  }

  export type RecipeSpiceBlendMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    spiceBlendId: string | null
    amountGrams: number | null
  }

  export type RecipeSpiceBlendCountAggregateOutputType = {
    id: number
    recipeId: number
    spiceBlendId: number
    amountGrams: number
    _all: number
  }


  export type RecipeSpiceBlendAvgAggregateInputType = {
    amountGrams?: true
  }

  export type RecipeSpiceBlendSumAggregateInputType = {
    amountGrams?: true
  }

  export type RecipeSpiceBlendMinAggregateInputType = {
    id?: true
    recipeId?: true
    spiceBlendId?: true
    amountGrams?: true
  }

  export type RecipeSpiceBlendMaxAggregateInputType = {
    id?: true
    recipeId?: true
    spiceBlendId?: true
    amountGrams?: true
  }

  export type RecipeSpiceBlendCountAggregateInputType = {
    id?: true
    recipeId?: true
    spiceBlendId?: true
    amountGrams?: true
    _all?: true
  }

  export type RecipeSpiceBlendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeSpiceBlend to aggregate.
     */
    where?: RecipeSpiceBlendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeSpiceBlends to fetch.
     */
    orderBy?: RecipeSpiceBlendOrderByWithRelationInput | RecipeSpiceBlendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeSpiceBlendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeSpiceBlends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeSpiceBlends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeSpiceBlends
    **/
    _count?: true | RecipeSpiceBlendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeSpiceBlendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSpiceBlendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeSpiceBlendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeSpiceBlendMaxAggregateInputType
  }

  export type GetRecipeSpiceBlendAggregateType<T extends RecipeSpiceBlendAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeSpiceBlend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeSpiceBlend[P]>
      : GetScalarType<T[P], AggregateRecipeSpiceBlend[P]>
  }




  export type RecipeSpiceBlendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeSpiceBlendWhereInput
    orderBy?: RecipeSpiceBlendOrderByWithAggregationInput | RecipeSpiceBlendOrderByWithAggregationInput[]
    by: RecipeSpiceBlendScalarFieldEnum[] | RecipeSpiceBlendScalarFieldEnum
    having?: RecipeSpiceBlendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeSpiceBlendCountAggregateInputType | true
    _avg?: RecipeSpiceBlendAvgAggregateInputType
    _sum?: RecipeSpiceBlendSumAggregateInputType
    _min?: RecipeSpiceBlendMinAggregateInputType
    _max?: RecipeSpiceBlendMaxAggregateInputType
  }

  export type RecipeSpiceBlendGroupByOutputType = {
    id: string
    recipeId: string
    spiceBlendId: string
    amountGrams: number
    _count: RecipeSpiceBlendCountAggregateOutputType | null
    _avg: RecipeSpiceBlendAvgAggregateOutputType | null
    _sum: RecipeSpiceBlendSumAggregateOutputType | null
    _min: RecipeSpiceBlendMinAggregateOutputType | null
    _max: RecipeSpiceBlendMaxAggregateOutputType | null
  }

  type GetRecipeSpiceBlendGroupByPayload<T extends RecipeSpiceBlendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeSpiceBlendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeSpiceBlendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeSpiceBlendGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeSpiceBlendGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSpiceBlendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    spiceBlendId?: boolean
    amountGrams?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    spiceBlend?: boolean | SpiceBlendDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeSpiceBlend"]>

  export type RecipeSpiceBlendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    spiceBlendId?: boolean
    amountGrams?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    spiceBlend?: boolean | SpiceBlendDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeSpiceBlend"]>

  export type RecipeSpiceBlendSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    spiceBlendId?: boolean
    amountGrams?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    spiceBlend?: boolean | SpiceBlendDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeSpiceBlend"]>

  export type RecipeSpiceBlendSelectScalar = {
    id?: boolean
    recipeId?: boolean
    spiceBlendId?: boolean
    amountGrams?: boolean
  }

  export type RecipeSpiceBlendOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "spiceBlendId" | "amountGrams", ExtArgs["result"]["recipeSpiceBlend"]>
  export type RecipeSpiceBlendInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    spiceBlend?: boolean | SpiceBlendDefaultArgs<ExtArgs>
  }
  export type RecipeSpiceBlendIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    spiceBlend?: boolean | SpiceBlendDefaultArgs<ExtArgs>
  }
  export type RecipeSpiceBlendIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    spiceBlend?: boolean | SpiceBlendDefaultArgs<ExtArgs>
  }

  export type $RecipeSpiceBlendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeSpiceBlend"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      spiceBlend: Prisma.$SpiceBlendPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      spiceBlendId: string
      amountGrams: number
    }, ExtArgs["result"]["recipeSpiceBlend"]>
    composites: {}
  }

  type RecipeSpiceBlendGetPayload<S extends boolean | null | undefined | RecipeSpiceBlendDefaultArgs> = $Result.GetResult<Prisma.$RecipeSpiceBlendPayload, S>

  type RecipeSpiceBlendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeSpiceBlendFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeSpiceBlendCountAggregateInputType | true
    }

  export interface RecipeSpiceBlendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeSpiceBlend'], meta: { name: 'RecipeSpiceBlend' } }
    /**
     * Find zero or one RecipeSpiceBlend that matches the filter.
     * @param {RecipeSpiceBlendFindUniqueArgs} args - Arguments to find a RecipeSpiceBlend
     * @example
     * // Get one RecipeSpiceBlend
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeSpiceBlendFindUniqueArgs>(args: SelectSubset<T, RecipeSpiceBlendFindUniqueArgs<ExtArgs>>): Prisma__RecipeSpiceBlendClient<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeSpiceBlend that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeSpiceBlendFindUniqueOrThrowArgs} args - Arguments to find a RecipeSpiceBlend
     * @example
     * // Get one RecipeSpiceBlend
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeSpiceBlendFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeSpiceBlendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeSpiceBlendClient<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeSpiceBlend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeSpiceBlendFindFirstArgs} args - Arguments to find a RecipeSpiceBlend
     * @example
     * // Get one RecipeSpiceBlend
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeSpiceBlendFindFirstArgs>(args?: SelectSubset<T, RecipeSpiceBlendFindFirstArgs<ExtArgs>>): Prisma__RecipeSpiceBlendClient<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeSpiceBlend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeSpiceBlendFindFirstOrThrowArgs} args - Arguments to find a RecipeSpiceBlend
     * @example
     * // Get one RecipeSpiceBlend
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeSpiceBlendFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeSpiceBlendFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeSpiceBlendClient<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeSpiceBlends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeSpiceBlendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeSpiceBlends
     * const recipeSpiceBlends = await prisma.recipeSpiceBlend.findMany()
     * 
     * // Get first 10 RecipeSpiceBlends
     * const recipeSpiceBlends = await prisma.recipeSpiceBlend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeSpiceBlendWithIdOnly = await prisma.recipeSpiceBlend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeSpiceBlendFindManyArgs>(args?: SelectSubset<T, RecipeSpiceBlendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeSpiceBlend.
     * @param {RecipeSpiceBlendCreateArgs} args - Arguments to create a RecipeSpiceBlend.
     * @example
     * // Create one RecipeSpiceBlend
     * const RecipeSpiceBlend = await prisma.recipeSpiceBlend.create({
     *   data: {
     *     // ... data to create a RecipeSpiceBlend
     *   }
     * })
     * 
     */
    create<T extends RecipeSpiceBlendCreateArgs>(args: SelectSubset<T, RecipeSpiceBlendCreateArgs<ExtArgs>>): Prisma__RecipeSpiceBlendClient<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeSpiceBlends.
     * @param {RecipeSpiceBlendCreateManyArgs} args - Arguments to create many RecipeSpiceBlends.
     * @example
     * // Create many RecipeSpiceBlends
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeSpiceBlendCreateManyArgs>(args?: SelectSubset<T, RecipeSpiceBlendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeSpiceBlends and returns the data saved in the database.
     * @param {RecipeSpiceBlendCreateManyAndReturnArgs} args - Arguments to create many RecipeSpiceBlends.
     * @example
     * // Create many RecipeSpiceBlends
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeSpiceBlends and only return the `id`
     * const recipeSpiceBlendWithIdOnly = await prisma.recipeSpiceBlend.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeSpiceBlendCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeSpiceBlendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeSpiceBlend.
     * @param {RecipeSpiceBlendDeleteArgs} args - Arguments to delete one RecipeSpiceBlend.
     * @example
     * // Delete one RecipeSpiceBlend
     * const RecipeSpiceBlend = await prisma.recipeSpiceBlend.delete({
     *   where: {
     *     // ... filter to delete one RecipeSpiceBlend
     *   }
     * })
     * 
     */
    delete<T extends RecipeSpiceBlendDeleteArgs>(args: SelectSubset<T, RecipeSpiceBlendDeleteArgs<ExtArgs>>): Prisma__RecipeSpiceBlendClient<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeSpiceBlend.
     * @param {RecipeSpiceBlendUpdateArgs} args - Arguments to update one RecipeSpiceBlend.
     * @example
     * // Update one RecipeSpiceBlend
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeSpiceBlendUpdateArgs>(args: SelectSubset<T, RecipeSpiceBlendUpdateArgs<ExtArgs>>): Prisma__RecipeSpiceBlendClient<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeSpiceBlends.
     * @param {RecipeSpiceBlendDeleteManyArgs} args - Arguments to filter RecipeSpiceBlends to delete.
     * @example
     * // Delete a few RecipeSpiceBlends
     * const { count } = await prisma.recipeSpiceBlend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeSpiceBlendDeleteManyArgs>(args?: SelectSubset<T, RecipeSpiceBlendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeSpiceBlends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeSpiceBlendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeSpiceBlends
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeSpiceBlendUpdateManyArgs>(args: SelectSubset<T, RecipeSpiceBlendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeSpiceBlends and returns the data updated in the database.
     * @param {RecipeSpiceBlendUpdateManyAndReturnArgs} args - Arguments to update many RecipeSpiceBlends.
     * @example
     * // Update many RecipeSpiceBlends
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeSpiceBlends and only return the `id`
     * const recipeSpiceBlendWithIdOnly = await prisma.recipeSpiceBlend.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeSpiceBlendUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeSpiceBlendUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeSpiceBlend.
     * @param {RecipeSpiceBlendUpsertArgs} args - Arguments to update or create a RecipeSpiceBlend.
     * @example
     * // Update or create a RecipeSpiceBlend
     * const recipeSpiceBlend = await prisma.recipeSpiceBlend.upsert({
     *   create: {
     *     // ... data to create a RecipeSpiceBlend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeSpiceBlend we want to update
     *   }
     * })
     */
    upsert<T extends RecipeSpiceBlendUpsertArgs>(args: SelectSubset<T, RecipeSpiceBlendUpsertArgs<ExtArgs>>): Prisma__RecipeSpiceBlendClient<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeSpiceBlends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeSpiceBlendCountArgs} args - Arguments to filter RecipeSpiceBlends to count.
     * @example
     * // Count the number of RecipeSpiceBlends
     * const count = await prisma.recipeSpiceBlend.count({
     *   where: {
     *     // ... the filter for the RecipeSpiceBlends we want to count
     *   }
     * })
    **/
    count<T extends RecipeSpiceBlendCountArgs>(
      args?: Subset<T, RecipeSpiceBlendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeSpiceBlendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeSpiceBlend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeSpiceBlendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeSpiceBlendAggregateArgs>(args: Subset<T, RecipeSpiceBlendAggregateArgs>): Prisma.PrismaPromise<GetRecipeSpiceBlendAggregateType<T>>

    /**
     * Group by RecipeSpiceBlend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeSpiceBlendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeSpiceBlendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeSpiceBlendGroupByArgs['orderBy'] }
        : { orderBy?: RecipeSpiceBlendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeSpiceBlendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeSpiceBlendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeSpiceBlend model
   */
  readonly fields: RecipeSpiceBlendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeSpiceBlend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeSpiceBlendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    spiceBlend<T extends SpiceBlendDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpiceBlendDefaultArgs<ExtArgs>>): Prisma__SpiceBlendClient<$Result.GetResult<Prisma.$SpiceBlendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeSpiceBlend model
   */
  interface RecipeSpiceBlendFieldRefs {
    readonly id: FieldRef<"RecipeSpiceBlend", 'String'>
    readonly recipeId: FieldRef<"RecipeSpiceBlend", 'String'>
    readonly spiceBlendId: FieldRef<"RecipeSpiceBlend", 'String'>
    readonly amountGrams: FieldRef<"RecipeSpiceBlend", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * RecipeSpiceBlend findUnique
   */
  export type RecipeSpiceBlendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which RecipeSpiceBlend to fetch.
     */
    where: RecipeSpiceBlendWhereUniqueInput
  }

  /**
   * RecipeSpiceBlend findUniqueOrThrow
   */
  export type RecipeSpiceBlendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which RecipeSpiceBlend to fetch.
     */
    where: RecipeSpiceBlendWhereUniqueInput
  }

  /**
   * RecipeSpiceBlend findFirst
   */
  export type RecipeSpiceBlendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which RecipeSpiceBlend to fetch.
     */
    where?: RecipeSpiceBlendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeSpiceBlends to fetch.
     */
    orderBy?: RecipeSpiceBlendOrderByWithRelationInput | RecipeSpiceBlendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeSpiceBlends.
     */
    cursor?: RecipeSpiceBlendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeSpiceBlends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeSpiceBlends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeSpiceBlends.
     */
    distinct?: RecipeSpiceBlendScalarFieldEnum | RecipeSpiceBlendScalarFieldEnum[]
  }

  /**
   * RecipeSpiceBlend findFirstOrThrow
   */
  export type RecipeSpiceBlendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which RecipeSpiceBlend to fetch.
     */
    where?: RecipeSpiceBlendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeSpiceBlends to fetch.
     */
    orderBy?: RecipeSpiceBlendOrderByWithRelationInput | RecipeSpiceBlendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeSpiceBlends.
     */
    cursor?: RecipeSpiceBlendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeSpiceBlends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeSpiceBlends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeSpiceBlends.
     */
    distinct?: RecipeSpiceBlendScalarFieldEnum | RecipeSpiceBlendScalarFieldEnum[]
  }

  /**
   * RecipeSpiceBlend findMany
   */
  export type RecipeSpiceBlendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    /**
     * Filter, which RecipeSpiceBlends to fetch.
     */
    where?: RecipeSpiceBlendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeSpiceBlends to fetch.
     */
    orderBy?: RecipeSpiceBlendOrderByWithRelationInput | RecipeSpiceBlendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeSpiceBlends.
     */
    cursor?: RecipeSpiceBlendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeSpiceBlends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeSpiceBlends.
     */
    skip?: number
    distinct?: RecipeSpiceBlendScalarFieldEnum | RecipeSpiceBlendScalarFieldEnum[]
  }

  /**
   * RecipeSpiceBlend create
   */
  export type RecipeSpiceBlendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeSpiceBlend.
     */
    data: XOR<RecipeSpiceBlendCreateInput, RecipeSpiceBlendUncheckedCreateInput>
  }

  /**
   * RecipeSpiceBlend createMany
   */
  export type RecipeSpiceBlendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeSpiceBlends.
     */
    data: RecipeSpiceBlendCreateManyInput | RecipeSpiceBlendCreateManyInput[]
  }

  /**
   * RecipeSpiceBlend createManyAndReturn
   */
  export type RecipeSpiceBlendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeSpiceBlends.
     */
    data: RecipeSpiceBlendCreateManyInput | RecipeSpiceBlendCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeSpiceBlend update
   */
  export type RecipeSpiceBlendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeSpiceBlend.
     */
    data: XOR<RecipeSpiceBlendUpdateInput, RecipeSpiceBlendUncheckedUpdateInput>
    /**
     * Choose, which RecipeSpiceBlend to update.
     */
    where: RecipeSpiceBlendWhereUniqueInput
  }

  /**
   * RecipeSpiceBlend updateMany
   */
  export type RecipeSpiceBlendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeSpiceBlends.
     */
    data: XOR<RecipeSpiceBlendUpdateManyMutationInput, RecipeSpiceBlendUncheckedUpdateManyInput>
    /**
     * Filter which RecipeSpiceBlends to update
     */
    where?: RecipeSpiceBlendWhereInput
    /**
     * Limit how many RecipeSpiceBlends to update.
     */
    limit?: number
  }

  /**
   * RecipeSpiceBlend updateManyAndReturn
   */
  export type RecipeSpiceBlendUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * The data used to update RecipeSpiceBlends.
     */
    data: XOR<RecipeSpiceBlendUpdateManyMutationInput, RecipeSpiceBlendUncheckedUpdateManyInput>
    /**
     * Filter which RecipeSpiceBlends to update
     */
    where?: RecipeSpiceBlendWhereInput
    /**
     * Limit how many RecipeSpiceBlends to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeSpiceBlend upsert
   */
  export type RecipeSpiceBlendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeSpiceBlend to update in case it exists.
     */
    where: RecipeSpiceBlendWhereUniqueInput
    /**
     * In case the RecipeSpiceBlend found by the `where` argument doesn't exist, create a new RecipeSpiceBlend with this data.
     */
    create: XOR<RecipeSpiceBlendCreateInput, RecipeSpiceBlendUncheckedCreateInput>
    /**
     * In case the RecipeSpiceBlend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeSpiceBlendUpdateInput, RecipeSpiceBlendUncheckedUpdateInput>
  }

  /**
   * RecipeSpiceBlend delete
   */
  export type RecipeSpiceBlendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    /**
     * Filter which RecipeSpiceBlend to delete.
     */
    where: RecipeSpiceBlendWhereUniqueInput
  }

  /**
   * RecipeSpiceBlend deleteMany
   */
  export type RecipeSpiceBlendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeSpiceBlends to delete
     */
    where?: RecipeSpiceBlendWhereInput
    /**
     * Limit how many RecipeSpiceBlends to delete.
     */
    limit?: number
  }

  /**
   * RecipeSpiceBlend without action
   */
  export type RecipeSpiceBlendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    servings: number | null
    prepTimeMinutes: number | null
    cookTimeMinutes: number | null
    totalTimeMinutes: number | null
    complexity: number | null
  }

  export type RecipeSumAggregateOutputType = {
    servings: number | null
    prepTimeMinutes: number | null
    cookTimeMinutes: number | null
    totalTimeMinutes: number | null
    complexity: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    servings: number | null
    createdAt: Date | null
    updatedAt: Date | null
    prepTimeMinutes: number | null
    cookTimeMinutes: number | null
    totalTimeMinutes: number | null
    complexity: number | null
    costTier: string | null
    requiredAppliances: string | null
    goalTags: string | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    servings: number | null
    createdAt: Date | null
    updatedAt: Date | null
    prepTimeMinutes: number | null
    cookTimeMinutes: number | null
    totalTimeMinutes: number | null
    complexity: number | null
    costTier: string | null
    requiredAppliances: string | null
    goalTags: string | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    servings: number
    createdAt: number
    updatedAt: number
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity: number
    costTier: number
    requiredAppliances: number
    goalTags: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    servings?: true
    prepTimeMinutes?: true
    cookTimeMinutes?: true
    totalTimeMinutes?: true
    complexity?: true
  }

  export type RecipeSumAggregateInputType = {
    servings?: true
    prepTimeMinutes?: true
    cookTimeMinutes?: true
    totalTimeMinutes?: true
    complexity?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    servings?: true
    createdAt?: true
    updatedAt?: true
    prepTimeMinutes?: true
    cookTimeMinutes?: true
    totalTimeMinutes?: true
    complexity?: true
    costTier?: true
    requiredAppliances?: true
    goalTags?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    servings?: true
    createdAt?: true
    updatedAt?: true
    prepTimeMinutes?: true
    cookTimeMinutes?: true
    totalTimeMinutes?: true
    complexity?: true
    costTier?: true
    requiredAppliances?: true
    goalTags?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    servings?: true
    createdAt?: true
    updatedAt?: true
    prepTimeMinutes?: true
    cookTimeMinutes?: true
    totalTimeMinutes?: true
    complexity?: true
    costTier?: true
    requiredAppliances?: true
    goalTags?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    servings: number
    createdAt: Date
    updatedAt: Date
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity: number
    costTier: string
    requiredAppliances: string
    goalTags: string
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    servings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepTimeMinutes?: boolean
    cookTimeMinutes?: boolean
    totalTimeMinutes?: boolean
    complexity?: boolean
    costTier?: boolean
    requiredAppliances?: boolean
    goalTags?: boolean
    ingredients?: boolean | Recipe$ingredientsArgs<ExtArgs>
    instructions?: boolean | Recipe$instructionsArgs<ExtArgs>
    medicalTags?: boolean | Recipe$medicalTagsArgs<ExtArgs>
    dietaryTags?: boolean | Recipe$dietaryTagsArgs<ExtArgs>
    practicalTags?: boolean | Recipe$practicalTagsArgs<ExtArgs>
    nutritionalTags?: boolean | Recipe$nutritionalTagsArgs<ExtArgs>
    spiceBlends?: boolean | Recipe$spiceBlendsArgs<ExtArgs>
    nutritionalInfo?: boolean | Recipe$nutritionalInfoArgs<ExtArgs>
    favorites?: boolean | Recipe$favoritesArgs<ExtArgs>
    mealPlanItems?: boolean | Recipe$mealPlanItemsArgs<ExtArgs>
    feedbacks?: boolean | Recipe$feedbacksArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    servings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepTimeMinutes?: boolean
    cookTimeMinutes?: boolean
    totalTimeMinutes?: boolean
    complexity?: boolean
    costTier?: boolean
    requiredAppliances?: boolean
    goalTags?: boolean
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    servings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepTimeMinutes?: boolean
    cookTimeMinutes?: boolean
    totalTimeMinutes?: boolean
    complexity?: boolean
    costTier?: boolean
    requiredAppliances?: boolean
    goalTags?: boolean
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    servings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prepTimeMinutes?: boolean
    cookTimeMinutes?: boolean
    totalTimeMinutes?: boolean
    complexity?: boolean
    costTier?: boolean
    requiredAppliances?: boolean
    goalTags?: boolean
  }

  export type RecipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "servings" | "createdAt" | "updatedAt" | "prepTimeMinutes" | "cookTimeMinutes" | "totalTimeMinutes" | "complexity" | "costTier" | "requiredAppliances" | "goalTags", ExtArgs["result"]["recipe"]>
  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredients?: boolean | Recipe$ingredientsArgs<ExtArgs>
    instructions?: boolean | Recipe$instructionsArgs<ExtArgs>
    medicalTags?: boolean | Recipe$medicalTagsArgs<ExtArgs>
    dietaryTags?: boolean | Recipe$dietaryTagsArgs<ExtArgs>
    practicalTags?: boolean | Recipe$practicalTagsArgs<ExtArgs>
    nutritionalTags?: boolean | Recipe$nutritionalTagsArgs<ExtArgs>
    spiceBlends?: boolean | Recipe$spiceBlendsArgs<ExtArgs>
    nutritionalInfo?: boolean | Recipe$nutritionalInfoArgs<ExtArgs>
    favorites?: boolean | Recipe$favoritesArgs<ExtArgs>
    mealPlanItems?: boolean | Recipe$mealPlanItemsArgs<ExtArgs>
    feedbacks?: boolean | Recipe$feedbacksArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RecipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      ingredients: Prisma.$RecipeIngredientPayload<ExtArgs>[]
      instructions: Prisma.$RecipeInstructionPayload<ExtArgs>[]
      medicalTags: Prisma.$RecipeMedicalTagPayload<ExtArgs>[]
      dietaryTags: Prisma.$RecipeDietaryTagPayload<ExtArgs>[]
      practicalTags: Prisma.$RecipePracticalTagPayload<ExtArgs>[]
      nutritionalTags: Prisma.$RecipeNutritionalTagPayload<ExtArgs>[]
      spiceBlends: Prisma.$RecipeSpiceBlendPayload<ExtArgs>[]
      nutritionalInfo: Prisma.$NutritionalInfoPayload<ExtArgs> | null
      favorites: Prisma.$UserFavoriteRecipePayload<ExtArgs>[]
      mealPlanItems: Prisma.$MealPlanItemPayload<ExtArgs>[]
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      servings: number
      createdAt: Date
      updatedAt: Date
      prepTimeMinutes: number
      cookTimeMinutes: number
      totalTimeMinutes: number
      complexity: number
      costTier: string
      requiredAppliances: string
      goalTags: string
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipes and returns the data saved in the database.
     * @param {RecipeCreateManyAndReturnArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes and returns the data updated in the database.
     * @param {RecipeUpdateManyAndReturnArgs} args - Arguments to update many Recipes.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ingredients<T extends Recipe$ingredientsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$ingredientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instructions<T extends Recipe$instructionsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$instructionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalTags<T extends Recipe$medicalTagsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$medicalTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dietaryTags<T extends Recipe$dietaryTagsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$dietaryTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    practicalTags<T extends Recipe$practicalTagsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$practicalTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nutritionalTags<T extends Recipe$nutritionalTagsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$nutritionalTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spiceBlends<T extends Recipe$spiceBlendsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$spiceBlendsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeSpiceBlendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nutritionalInfo<T extends Recipe$nutritionalInfoArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$nutritionalInfoArgs<ExtArgs>>): Prisma__NutritionalInfoClient<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    favorites<T extends Recipe$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mealPlanItems<T extends Recipe$mealPlanItemsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$mealPlanItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends Recipe$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly description: FieldRef<"Recipe", 'String'>
    readonly servings: FieldRef<"Recipe", 'Int'>
    readonly createdAt: FieldRef<"Recipe", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipe", 'DateTime'>
    readonly prepTimeMinutes: FieldRef<"Recipe", 'Int'>
    readonly cookTimeMinutes: FieldRef<"Recipe", 'Int'>
    readonly totalTimeMinutes: FieldRef<"Recipe", 'Int'>
    readonly complexity: FieldRef<"Recipe", 'Int'>
    readonly costTier: FieldRef<"Recipe", 'String'>
    readonly requiredAppliances: FieldRef<"Recipe", 'String'>
    readonly goalTags: FieldRef<"Recipe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
  }

  /**
   * Recipe createManyAndReturn
   */
  export type RecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to update.
     */
    limit?: number
  }

  /**
   * Recipe updateManyAndReturn
   */
  export type RecipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to update.
     */
    limit?: number
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
    /**
     * Limit how many Recipes to delete.
     */
    limit?: number
  }

  /**
   * Recipe.ingredients
   */
  export type Recipe$ingredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    cursor?: RecipeIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * Recipe.instructions
   */
  export type Recipe$instructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    where?: RecipeInstructionWhereInput
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    cursor?: RecipeInstructionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeInstructionScalarFieldEnum | RecipeInstructionScalarFieldEnum[]
  }

  /**
   * Recipe.medicalTags
   */
  export type Recipe$medicalTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    where?: RecipeMedicalTagWhereInput
    orderBy?: RecipeMedicalTagOrderByWithRelationInput | RecipeMedicalTagOrderByWithRelationInput[]
    cursor?: RecipeMedicalTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeMedicalTagScalarFieldEnum | RecipeMedicalTagScalarFieldEnum[]
  }

  /**
   * Recipe.dietaryTags
   */
  export type Recipe$dietaryTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    where?: RecipeDietaryTagWhereInput
    orderBy?: RecipeDietaryTagOrderByWithRelationInput | RecipeDietaryTagOrderByWithRelationInput[]
    cursor?: RecipeDietaryTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeDietaryTagScalarFieldEnum | RecipeDietaryTagScalarFieldEnum[]
  }

  /**
   * Recipe.practicalTags
   */
  export type Recipe$practicalTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    where?: RecipePracticalTagWhereInput
    orderBy?: RecipePracticalTagOrderByWithRelationInput | RecipePracticalTagOrderByWithRelationInput[]
    cursor?: RecipePracticalTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipePracticalTagScalarFieldEnum | RecipePracticalTagScalarFieldEnum[]
  }

  /**
   * Recipe.nutritionalTags
   */
  export type Recipe$nutritionalTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    where?: RecipeNutritionalTagWhereInput
    orderBy?: RecipeNutritionalTagOrderByWithRelationInput | RecipeNutritionalTagOrderByWithRelationInput[]
    cursor?: RecipeNutritionalTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeNutritionalTagScalarFieldEnum | RecipeNutritionalTagScalarFieldEnum[]
  }

  /**
   * Recipe.spiceBlends
   */
  export type Recipe$spiceBlendsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeSpiceBlend
     */
    select?: RecipeSpiceBlendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeSpiceBlend
     */
    omit?: RecipeSpiceBlendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeSpiceBlendInclude<ExtArgs> | null
    where?: RecipeSpiceBlendWhereInput
    orderBy?: RecipeSpiceBlendOrderByWithRelationInput | RecipeSpiceBlendOrderByWithRelationInput[]
    cursor?: RecipeSpiceBlendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeSpiceBlendScalarFieldEnum | RecipeSpiceBlendScalarFieldEnum[]
  }

  /**
   * Recipe.nutritionalInfo
   */
  export type Recipe$nutritionalInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    where?: NutritionalInfoWhereInput
  }

  /**
   * Recipe.favorites
   */
  export type Recipe$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    where?: UserFavoriteRecipeWhereInput
    orderBy?: UserFavoriteRecipeOrderByWithRelationInput | UserFavoriteRecipeOrderByWithRelationInput[]
    cursor?: UserFavoriteRecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteRecipeScalarFieldEnum | UserFavoriteRecipeScalarFieldEnum[]
  }

  /**
   * Recipe.mealPlanItems
   */
  export type Recipe$mealPlanItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    where?: MealPlanItemWhereInput
    orderBy?: MealPlanItemOrderByWithRelationInput | MealPlanItemOrderByWithRelationInput[]
    cursor?: MealPlanItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MealPlanItemScalarFieldEnum | MealPlanItemScalarFieldEnum[]
  }

  /**
   * Recipe.feedbacks
   */
  export type Recipe$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Recipe
     */
    omit?: RecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model RecipeIngredient
   */

  export type AggregateRecipeIngredient = {
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  export type RecipeIngredientAvgAggregateOutputType = {
    amount: number | null
  }

  export type RecipeIngredientSumAggregateOutputType = {
    amount: number | null
  }

  export type RecipeIngredientMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    name: string | null
    amount: number | null
    unit: string | null
    notes: string | null
  }

  export type RecipeIngredientMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    name: string | null
    amount: number | null
    unit: string | null
    notes: string | null
  }

  export type RecipeIngredientCountAggregateOutputType = {
    id: number
    recipeId: number
    name: number
    amount: number
    unit: number
    notes: number
    _all: number
  }


  export type RecipeIngredientAvgAggregateInputType = {
    amount?: true
  }

  export type RecipeIngredientSumAggregateInputType = {
    amount?: true
  }

  export type RecipeIngredientMinAggregateInputType = {
    id?: true
    recipeId?: true
    name?: true
    amount?: true
    unit?: true
    notes?: true
  }

  export type RecipeIngredientMaxAggregateInputType = {
    id?: true
    recipeId?: true
    name?: true
    amount?: true
    unit?: true
    notes?: true
  }

  export type RecipeIngredientCountAggregateInputType = {
    id?: true
    recipeId?: true
    name?: true
    amount?: true
    unit?: true
    notes?: true
    _all?: true
  }

  export type RecipeIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredient to aggregate.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeIngredients
    **/
    _count?: true | RecipeIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type GetRecipeIngredientAggregateType<T extends RecipeIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeIngredient[P]>
      : GetScalarType<T[P], AggregateRecipeIngredient[P]>
  }




  export type RecipeIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithAggregationInput | RecipeIngredientOrderByWithAggregationInput[]
    by: RecipeIngredientScalarFieldEnum[] | RecipeIngredientScalarFieldEnum
    having?: RecipeIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeIngredientCountAggregateInputType | true
    _avg?: RecipeIngredientAvgAggregateInputType
    _sum?: RecipeIngredientSumAggregateInputType
    _min?: RecipeIngredientMinAggregateInputType
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type RecipeIngredientGroupByOutputType = {
    id: string
    recipeId: string
    name: string
    amount: number
    unit: string
    notes: string | null
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  type GetRecipeIngredientGroupByPayload<T extends RecipeIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
        }
      >
    >


  export type RecipeIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    notes?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    notes?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    notes?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectScalar = {
    id?: boolean
    recipeId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    notes?: boolean
  }

  export type RecipeIngredientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "name" | "amount" | "unit" | "notes", ExtArgs["result"]["recipeIngredient"]>
  export type RecipeIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type RecipeIngredientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type RecipeIngredientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $RecipeIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeIngredient"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      name: string
      amount: number
      unit: string
      notes: string | null
    }, ExtArgs["result"]["recipeIngredient"]>
    composites: {}
  }

  type RecipeIngredientGetPayload<S extends boolean | null | undefined | RecipeIngredientDefaultArgs> = $Result.GetResult<Prisma.$RecipeIngredientPayload, S>

  type RecipeIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeIngredientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeIngredientCountAggregateInputType | true
    }

  export interface RecipeIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeIngredient'], meta: { name: 'RecipeIngredient' } }
    /**
     * Find zero or one RecipeIngredient that matches the filter.
     * @param {RecipeIngredientFindUniqueArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeIngredientFindUniqueArgs>(args: SelectSubset<T, RecipeIngredientFindUniqueArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeIngredient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeIngredientFindUniqueOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeIngredientFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeIngredientFindFirstArgs>(args?: SelectSubset<T, RecipeIngredientFindFirstArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeIngredientFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeIngredientFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany()
     * 
     * // Get first 10 RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeIngredientWithIdOnly = await prisma.recipeIngredient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeIngredientFindManyArgs>(args?: SelectSubset<T, RecipeIngredientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeIngredient.
     * @param {RecipeIngredientCreateArgs} args - Arguments to create a RecipeIngredient.
     * @example
     * // Create one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.create({
     *   data: {
     *     // ... data to create a RecipeIngredient
     *   }
     * })
     * 
     */
    create<T extends RecipeIngredientCreateArgs>(args: SelectSubset<T, RecipeIngredientCreateArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeIngredients.
     * @param {RecipeIngredientCreateManyArgs} args - Arguments to create many RecipeIngredients.
     * @example
     * // Create many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeIngredientCreateManyArgs>(args?: SelectSubset<T, RecipeIngredientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeIngredients and returns the data saved in the database.
     * @param {RecipeIngredientCreateManyAndReturnArgs} args - Arguments to create many RecipeIngredients.
     * @example
     * // Create many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeIngredients and only return the `id`
     * const recipeIngredientWithIdOnly = await prisma.recipeIngredient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeIngredientCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeIngredientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeIngredient.
     * @param {RecipeIngredientDeleteArgs} args - Arguments to delete one RecipeIngredient.
     * @example
     * // Delete one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.delete({
     *   where: {
     *     // ... filter to delete one RecipeIngredient
     *   }
     * })
     * 
     */
    delete<T extends RecipeIngredientDeleteArgs>(args: SelectSubset<T, RecipeIngredientDeleteArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeIngredient.
     * @param {RecipeIngredientUpdateArgs} args - Arguments to update one RecipeIngredient.
     * @example
     * // Update one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeIngredientUpdateArgs>(args: SelectSubset<T, RecipeIngredientUpdateArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeIngredients.
     * @param {RecipeIngredientDeleteManyArgs} args - Arguments to filter RecipeIngredients to delete.
     * @example
     * // Delete a few RecipeIngredients
     * const { count } = await prisma.recipeIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeIngredientDeleteManyArgs>(args?: SelectSubset<T, RecipeIngredientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeIngredientUpdateManyArgs>(args: SelectSubset<T, RecipeIngredientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeIngredients and returns the data updated in the database.
     * @param {RecipeIngredientUpdateManyAndReturnArgs} args - Arguments to update many RecipeIngredients.
     * @example
     * // Update many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeIngredients and only return the `id`
     * const recipeIngredientWithIdOnly = await prisma.recipeIngredient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeIngredientUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeIngredientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeIngredient.
     * @param {RecipeIngredientUpsertArgs} args - Arguments to update or create a RecipeIngredient.
     * @example
     * // Update or create a RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.upsert({
     *   create: {
     *     // ... data to create a RecipeIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeIngredient we want to update
     *   }
     * })
     */
    upsert<T extends RecipeIngredientUpsertArgs>(args: SelectSubset<T, RecipeIngredientUpsertArgs<ExtArgs>>): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientCountArgs} args - Arguments to filter RecipeIngredients to count.
     * @example
     * // Count the number of RecipeIngredients
     * const count = await prisma.recipeIngredient.count({
     *   where: {
     *     // ... the filter for the RecipeIngredients we want to count
     *   }
     * })
    **/
    count<T extends RecipeIngredientCountArgs>(
      args?: Subset<T, RecipeIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeIngredientAggregateArgs>(args: Subset<T, RecipeIngredientAggregateArgs>): Prisma.PrismaPromise<GetRecipeIngredientAggregateType<T>>

    /**
     * Group by RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeIngredientGroupByArgs['orderBy'] }
        : { orderBy?: RecipeIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeIngredient model
   */
  readonly fields: RecipeIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeIngredient model
   */
  interface RecipeIngredientFieldRefs {
    readonly id: FieldRef<"RecipeIngredient", 'String'>
    readonly recipeId: FieldRef<"RecipeIngredient", 'String'>
    readonly name: FieldRef<"RecipeIngredient", 'String'>
    readonly amount: FieldRef<"RecipeIngredient", 'Float'>
    readonly unit: FieldRef<"RecipeIngredient", 'String'>
    readonly notes: FieldRef<"RecipeIngredient", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecipeIngredient findUnique
   */
  export type RecipeIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient findUniqueOrThrow
   */
  export type RecipeIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient findFirst
   */
  export type RecipeIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient findFirstOrThrow
   */
  export type RecipeIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient findMany
   */
  export type RecipeIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredients to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }

  /**
   * RecipeIngredient create
   */
  export type RecipeIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeIngredient.
     */
    data: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
  }

  /**
   * RecipeIngredient createMany
   */
  export type RecipeIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeIngredients.
     */
    data: RecipeIngredientCreateManyInput | RecipeIngredientCreateManyInput[]
  }

  /**
   * RecipeIngredient createManyAndReturn
   */
  export type RecipeIngredientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeIngredients.
     */
    data: RecipeIngredientCreateManyInput | RecipeIngredientCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeIngredient update
   */
  export type RecipeIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeIngredient.
     */
    data: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
    /**
     * Choose, which RecipeIngredient to update.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient updateMany
   */
  export type RecipeIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeIngredients.
     */
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyInput>
    /**
     * Filter which RecipeIngredients to update
     */
    where?: RecipeIngredientWhereInput
    /**
     * Limit how many RecipeIngredients to update.
     */
    limit?: number
  }

  /**
   * RecipeIngredient updateManyAndReturn
   */
  export type RecipeIngredientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * The data used to update RecipeIngredients.
     */
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyInput>
    /**
     * Filter which RecipeIngredients to update
     */
    where?: RecipeIngredientWhereInput
    /**
     * Limit how many RecipeIngredients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeIngredient upsert
   */
  export type RecipeIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeIngredient to update in case it exists.
     */
    where: RecipeIngredientWhereUniqueInput
    /**
     * In case the RecipeIngredient found by the `where` argument doesn't exist, create a new RecipeIngredient with this data.
     */
    create: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
    /**
     * In case the RecipeIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
  }

  /**
   * RecipeIngredient delete
   */
  export type RecipeIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter which RecipeIngredient to delete.
     */
    where: RecipeIngredientWhereUniqueInput
  }

  /**
   * RecipeIngredient deleteMany
   */
  export type RecipeIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredients to delete
     */
    where?: RecipeIngredientWhereInput
    /**
     * Limit how many RecipeIngredients to delete.
     */
    limit?: number
  }

  /**
   * RecipeIngredient without action
   */
  export type RecipeIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeIngredient
     */
    omit?: RecipeIngredientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
  }


  /**
   * Model RecipeInstruction
   */

  export type AggregateRecipeInstruction = {
    _count: RecipeInstructionCountAggregateOutputType | null
    _avg: RecipeInstructionAvgAggregateOutputType | null
    _sum: RecipeInstructionSumAggregateOutputType | null
    _min: RecipeInstructionMinAggregateOutputType | null
    _max: RecipeInstructionMaxAggregateOutputType | null
  }

  export type RecipeInstructionAvgAggregateOutputType = {
    stepNumber: number | null
  }

  export type RecipeInstructionSumAggregateOutputType = {
    stepNumber: number | null
  }

  export type RecipeInstructionMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    stepNumber: number | null
    instruction: string | null
  }

  export type RecipeInstructionMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    stepNumber: number | null
    instruction: string | null
  }

  export type RecipeInstructionCountAggregateOutputType = {
    id: number
    recipeId: number
    stepNumber: number
    instruction: number
    _all: number
  }


  export type RecipeInstructionAvgAggregateInputType = {
    stepNumber?: true
  }

  export type RecipeInstructionSumAggregateInputType = {
    stepNumber?: true
  }

  export type RecipeInstructionMinAggregateInputType = {
    id?: true
    recipeId?: true
    stepNumber?: true
    instruction?: true
  }

  export type RecipeInstructionMaxAggregateInputType = {
    id?: true
    recipeId?: true
    stepNumber?: true
    instruction?: true
  }

  export type RecipeInstructionCountAggregateInputType = {
    id?: true
    recipeId?: true
    stepNumber?: true
    instruction?: true
    _all?: true
  }

  export type RecipeInstructionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeInstruction to aggregate.
     */
    where?: RecipeInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInstructions to fetch.
     */
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeInstructions
    **/
    _count?: true | RecipeInstructionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeInstructionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeInstructionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeInstructionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeInstructionMaxAggregateInputType
  }

  export type GetRecipeInstructionAggregateType<T extends RecipeInstructionAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeInstruction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeInstruction[P]>
      : GetScalarType<T[P], AggregateRecipeInstruction[P]>
  }




  export type RecipeInstructionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeInstructionWhereInput
    orderBy?: RecipeInstructionOrderByWithAggregationInput | RecipeInstructionOrderByWithAggregationInput[]
    by: RecipeInstructionScalarFieldEnum[] | RecipeInstructionScalarFieldEnum
    having?: RecipeInstructionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeInstructionCountAggregateInputType | true
    _avg?: RecipeInstructionAvgAggregateInputType
    _sum?: RecipeInstructionSumAggregateInputType
    _min?: RecipeInstructionMinAggregateInputType
    _max?: RecipeInstructionMaxAggregateInputType
  }

  export type RecipeInstructionGroupByOutputType = {
    id: string
    recipeId: string
    stepNumber: number
    instruction: string
    _count: RecipeInstructionCountAggregateOutputType | null
    _avg: RecipeInstructionAvgAggregateOutputType | null
    _sum: RecipeInstructionSumAggregateOutputType | null
    _min: RecipeInstructionMinAggregateOutputType | null
    _max: RecipeInstructionMaxAggregateOutputType | null
  }

  type GetRecipeInstructionGroupByPayload<T extends RecipeInstructionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeInstructionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeInstructionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeInstructionGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeInstructionGroupByOutputType[P]>
        }
      >
    >


  export type RecipeInstructionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    stepNumber?: boolean
    instruction?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeInstruction"]>

  export type RecipeInstructionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    stepNumber?: boolean
    instruction?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeInstruction"]>

  export type RecipeInstructionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    stepNumber?: boolean
    instruction?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeInstruction"]>

  export type RecipeInstructionSelectScalar = {
    id?: boolean
    recipeId?: boolean
    stepNumber?: boolean
    instruction?: boolean
  }

  export type RecipeInstructionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "stepNumber" | "instruction", ExtArgs["result"]["recipeInstruction"]>
  export type RecipeInstructionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type RecipeInstructionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type RecipeInstructionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $RecipeInstructionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeInstruction"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      stepNumber: number
      instruction: string
    }, ExtArgs["result"]["recipeInstruction"]>
    composites: {}
  }

  type RecipeInstructionGetPayload<S extends boolean | null | undefined | RecipeInstructionDefaultArgs> = $Result.GetResult<Prisma.$RecipeInstructionPayload, S>

  type RecipeInstructionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeInstructionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeInstructionCountAggregateInputType | true
    }

  export interface RecipeInstructionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeInstruction'], meta: { name: 'RecipeInstruction' } }
    /**
     * Find zero or one RecipeInstruction that matches the filter.
     * @param {RecipeInstructionFindUniqueArgs} args - Arguments to find a RecipeInstruction
     * @example
     * // Get one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeInstructionFindUniqueArgs>(args: SelectSubset<T, RecipeInstructionFindUniqueArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeInstruction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeInstructionFindUniqueOrThrowArgs} args - Arguments to find a RecipeInstruction
     * @example
     * // Get one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeInstructionFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeInstructionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeInstruction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionFindFirstArgs} args - Arguments to find a RecipeInstruction
     * @example
     * // Get one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeInstructionFindFirstArgs>(args?: SelectSubset<T, RecipeInstructionFindFirstArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeInstruction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionFindFirstOrThrowArgs} args - Arguments to find a RecipeInstruction
     * @example
     * // Get one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeInstructionFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeInstructionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeInstructions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeInstructions
     * const recipeInstructions = await prisma.recipeInstruction.findMany()
     * 
     * // Get first 10 RecipeInstructions
     * const recipeInstructions = await prisma.recipeInstruction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeInstructionWithIdOnly = await prisma.recipeInstruction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeInstructionFindManyArgs>(args?: SelectSubset<T, RecipeInstructionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeInstruction.
     * @param {RecipeInstructionCreateArgs} args - Arguments to create a RecipeInstruction.
     * @example
     * // Create one RecipeInstruction
     * const RecipeInstruction = await prisma.recipeInstruction.create({
     *   data: {
     *     // ... data to create a RecipeInstruction
     *   }
     * })
     * 
     */
    create<T extends RecipeInstructionCreateArgs>(args: SelectSubset<T, RecipeInstructionCreateArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeInstructions.
     * @param {RecipeInstructionCreateManyArgs} args - Arguments to create many RecipeInstructions.
     * @example
     * // Create many RecipeInstructions
     * const recipeInstruction = await prisma.recipeInstruction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeInstructionCreateManyArgs>(args?: SelectSubset<T, RecipeInstructionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeInstructions and returns the data saved in the database.
     * @param {RecipeInstructionCreateManyAndReturnArgs} args - Arguments to create many RecipeInstructions.
     * @example
     * // Create many RecipeInstructions
     * const recipeInstruction = await prisma.recipeInstruction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeInstructions and only return the `id`
     * const recipeInstructionWithIdOnly = await prisma.recipeInstruction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeInstructionCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeInstructionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeInstruction.
     * @param {RecipeInstructionDeleteArgs} args - Arguments to delete one RecipeInstruction.
     * @example
     * // Delete one RecipeInstruction
     * const RecipeInstruction = await prisma.recipeInstruction.delete({
     *   where: {
     *     // ... filter to delete one RecipeInstruction
     *   }
     * })
     * 
     */
    delete<T extends RecipeInstructionDeleteArgs>(args: SelectSubset<T, RecipeInstructionDeleteArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeInstruction.
     * @param {RecipeInstructionUpdateArgs} args - Arguments to update one RecipeInstruction.
     * @example
     * // Update one RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeInstructionUpdateArgs>(args: SelectSubset<T, RecipeInstructionUpdateArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeInstructions.
     * @param {RecipeInstructionDeleteManyArgs} args - Arguments to filter RecipeInstructions to delete.
     * @example
     * // Delete a few RecipeInstructions
     * const { count } = await prisma.recipeInstruction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeInstructionDeleteManyArgs>(args?: SelectSubset<T, RecipeInstructionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeInstructions
     * const recipeInstruction = await prisma.recipeInstruction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeInstructionUpdateManyArgs>(args: SelectSubset<T, RecipeInstructionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeInstructions and returns the data updated in the database.
     * @param {RecipeInstructionUpdateManyAndReturnArgs} args - Arguments to update many RecipeInstructions.
     * @example
     * // Update many RecipeInstructions
     * const recipeInstruction = await prisma.recipeInstruction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeInstructions and only return the `id`
     * const recipeInstructionWithIdOnly = await prisma.recipeInstruction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeInstructionUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeInstructionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeInstruction.
     * @param {RecipeInstructionUpsertArgs} args - Arguments to update or create a RecipeInstruction.
     * @example
     * // Update or create a RecipeInstruction
     * const recipeInstruction = await prisma.recipeInstruction.upsert({
     *   create: {
     *     // ... data to create a RecipeInstruction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeInstruction we want to update
     *   }
     * })
     */
    upsert<T extends RecipeInstructionUpsertArgs>(args: SelectSubset<T, RecipeInstructionUpsertArgs<ExtArgs>>): Prisma__RecipeInstructionClient<$Result.GetResult<Prisma.$RecipeInstructionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeInstructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionCountArgs} args - Arguments to filter RecipeInstructions to count.
     * @example
     * // Count the number of RecipeInstructions
     * const count = await prisma.recipeInstruction.count({
     *   where: {
     *     // ... the filter for the RecipeInstructions we want to count
     *   }
     * })
    **/
    count<T extends RecipeInstructionCountArgs>(
      args?: Subset<T, RecipeInstructionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeInstructionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeInstruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeInstructionAggregateArgs>(args: Subset<T, RecipeInstructionAggregateArgs>): Prisma.PrismaPromise<GetRecipeInstructionAggregateType<T>>

    /**
     * Group by RecipeInstruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeInstructionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeInstructionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeInstructionGroupByArgs['orderBy'] }
        : { orderBy?: RecipeInstructionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeInstructionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeInstructionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeInstruction model
   */
  readonly fields: RecipeInstructionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeInstruction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeInstructionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeInstruction model
   */
  interface RecipeInstructionFieldRefs {
    readonly id: FieldRef<"RecipeInstruction", 'String'>
    readonly recipeId: FieldRef<"RecipeInstruction", 'String'>
    readonly stepNumber: FieldRef<"RecipeInstruction", 'Int'>
    readonly instruction: FieldRef<"RecipeInstruction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecipeInstruction findUnique
   */
  export type RecipeInstructionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstruction to fetch.
     */
    where: RecipeInstructionWhereUniqueInput
  }

  /**
   * RecipeInstruction findUniqueOrThrow
   */
  export type RecipeInstructionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstruction to fetch.
     */
    where: RecipeInstructionWhereUniqueInput
  }

  /**
   * RecipeInstruction findFirst
   */
  export type RecipeInstructionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstruction to fetch.
     */
    where?: RecipeInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInstructions to fetch.
     */
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeInstructions.
     */
    cursor?: RecipeInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeInstructions.
     */
    distinct?: RecipeInstructionScalarFieldEnum | RecipeInstructionScalarFieldEnum[]
  }

  /**
   * RecipeInstruction findFirstOrThrow
   */
  export type RecipeInstructionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstruction to fetch.
     */
    where?: RecipeInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInstructions to fetch.
     */
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeInstructions.
     */
    cursor?: RecipeInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInstructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeInstructions.
     */
    distinct?: RecipeInstructionScalarFieldEnum | RecipeInstructionScalarFieldEnum[]
  }

  /**
   * RecipeInstruction findMany
   */
  export type RecipeInstructionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter, which RecipeInstructions to fetch.
     */
    where?: RecipeInstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeInstructions to fetch.
     */
    orderBy?: RecipeInstructionOrderByWithRelationInput | RecipeInstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeInstructions.
     */
    cursor?: RecipeInstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeInstructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeInstructions.
     */
    skip?: number
    distinct?: RecipeInstructionScalarFieldEnum | RecipeInstructionScalarFieldEnum[]
  }

  /**
   * RecipeInstruction create
   */
  export type RecipeInstructionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeInstruction.
     */
    data: XOR<RecipeInstructionCreateInput, RecipeInstructionUncheckedCreateInput>
  }

  /**
   * RecipeInstruction createMany
   */
  export type RecipeInstructionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeInstructions.
     */
    data: RecipeInstructionCreateManyInput | RecipeInstructionCreateManyInput[]
  }

  /**
   * RecipeInstruction createManyAndReturn
   */
  export type RecipeInstructionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeInstructions.
     */
    data: RecipeInstructionCreateManyInput | RecipeInstructionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeInstruction update
   */
  export type RecipeInstructionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeInstruction.
     */
    data: XOR<RecipeInstructionUpdateInput, RecipeInstructionUncheckedUpdateInput>
    /**
     * Choose, which RecipeInstruction to update.
     */
    where: RecipeInstructionWhereUniqueInput
  }

  /**
   * RecipeInstruction updateMany
   */
  export type RecipeInstructionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeInstructions.
     */
    data: XOR<RecipeInstructionUpdateManyMutationInput, RecipeInstructionUncheckedUpdateManyInput>
    /**
     * Filter which RecipeInstructions to update
     */
    where?: RecipeInstructionWhereInput
    /**
     * Limit how many RecipeInstructions to update.
     */
    limit?: number
  }

  /**
   * RecipeInstruction updateManyAndReturn
   */
  export type RecipeInstructionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * The data used to update RecipeInstructions.
     */
    data: XOR<RecipeInstructionUpdateManyMutationInput, RecipeInstructionUncheckedUpdateManyInput>
    /**
     * Filter which RecipeInstructions to update
     */
    where?: RecipeInstructionWhereInput
    /**
     * Limit how many RecipeInstructions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeInstruction upsert
   */
  export type RecipeInstructionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeInstruction to update in case it exists.
     */
    where: RecipeInstructionWhereUniqueInput
    /**
     * In case the RecipeInstruction found by the `where` argument doesn't exist, create a new RecipeInstruction with this data.
     */
    create: XOR<RecipeInstructionCreateInput, RecipeInstructionUncheckedCreateInput>
    /**
     * In case the RecipeInstruction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeInstructionUpdateInput, RecipeInstructionUncheckedUpdateInput>
  }

  /**
   * RecipeInstruction delete
   */
  export type RecipeInstructionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
    /**
     * Filter which RecipeInstruction to delete.
     */
    where: RecipeInstructionWhereUniqueInput
  }

  /**
   * RecipeInstruction deleteMany
   */
  export type RecipeInstructionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeInstructions to delete
     */
    where?: RecipeInstructionWhereInput
    /**
     * Limit how many RecipeInstructions to delete.
     */
    limit?: number
  }

  /**
   * RecipeInstruction without action
   */
  export type RecipeInstructionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeInstruction
     */
    select?: RecipeInstructionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeInstruction
     */
    omit?: RecipeInstructionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInstructionInclude<ExtArgs> | null
  }


  /**
   * Model NutritionalInfo
   */

  export type AggregateNutritionalInfo = {
    _count: NutritionalInfoCountAggregateOutputType | null
    _avg: NutritionalInfoAvgAggregateOutputType | null
    _sum: NutritionalInfoSumAggregateOutputType | null
    _min: NutritionalInfoMinAggregateOutputType | null
    _max: NutritionalInfoMaxAggregateOutputType | null
  }

  export type NutritionalInfoAvgAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbohydrates: number | null
    fat: number | null
    fiber: number | null
    sugar: number | null
    sodium: number | null
    cholesterol: number | null
    vitaminC: number | null
    vitaminD: number | null
    calcium: number | null
    iron: number | null
    potassium: number | null
  }

  export type NutritionalInfoSumAggregateOutputType = {
    calories: number | null
    protein: number | null
    carbohydrates: number | null
    fat: number | null
    fiber: number | null
    sugar: number | null
    sodium: number | null
    cholesterol: number | null
    vitaminC: number | null
    vitaminD: number | null
    calcium: number | null
    iron: number | null
    potassium: number | null
  }

  export type NutritionalInfoMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    calories: number | null
    protein: number | null
    carbohydrates: number | null
    fat: number | null
    fiber: number | null
    sugar: number | null
    sodium: number | null
    cholesterol: number | null
    vitaminC: number | null
    vitaminD: number | null
    calcium: number | null
    iron: number | null
    potassium: number | null
  }

  export type NutritionalInfoMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    calories: number | null
    protein: number | null
    carbohydrates: number | null
    fat: number | null
    fiber: number | null
    sugar: number | null
    sodium: number | null
    cholesterol: number | null
    vitaminC: number | null
    vitaminD: number | null
    calcium: number | null
    iron: number | null
    potassium: number | null
  }

  export type NutritionalInfoCountAggregateOutputType = {
    id: number
    recipeId: number
    calories: number
    protein: number
    carbohydrates: number
    fat: number
    fiber: number
    sugar: number
    sodium: number
    cholesterol: number
    vitaminC: number
    vitaminD: number
    calcium: number
    iron: number
    potassium: number
    _all: number
  }


  export type NutritionalInfoAvgAggregateInputType = {
    calories?: true
    protein?: true
    carbohydrates?: true
    fat?: true
    fiber?: true
    sugar?: true
    sodium?: true
    cholesterol?: true
    vitaminC?: true
    vitaminD?: true
    calcium?: true
    iron?: true
    potassium?: true
  }

  export type NutritionalInfoSumAggregateInputType = {
    calories?: true
    protein?: true
    carbohydrates?: true
    fat?: true
    fiber?: true
    sugar?: true
    sodium?: true
    cholesterol?: true
    vitaminC?: true
    vitaminD?: true
    calcium?: true
    iron?: true
    potassium?: true
  }

  export type NutritionalInfoMinAggregateInputType = {
    id?: true
    recipeId?: true
    calories?: true
    protein?: true
    carbohydrates?: true
    fat?: true
    fiber?: true
    sugar?: true
    sodium?: true
    cholesterol?: true
    vitaminC?: true
    vitaminD?: true
    calcium?: true
    iron?: true
    potassium?: true
  }

  export type NutritionalInfoMaxAggregateInputType = {
    id?: true
    recipeId?: true
    calories?: true
    protein?: true
    carbohydrates?: true
    fat?: true
    fiber?: true
    sugar?: true
    sodium?: true
    cholesterol?: true
    vitaminC?: true
    vitaminD?: true
    calcium?: true
    iron?: true
    potassium?: true
  }

  export type NutritionalInfoCountAggregateInputType = {
    id?: true
    recipeId?: true
    calories?: true
    protein?: true
    carbohydrates?: true
    fat?: true
    fiber?: true
    sugar?: true
    sodium?: true
    cholesterol?: true
    vitaminC?: true
    vitaminD?: true
    calcium?: true
    iron?: true
    potassium?: true
    _all?: true
  }

  export type NutritionalInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionalInfo to aggregate.
     */
    where?: NutritionalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalInfos to fetch.
     */
    orderBy?: NutritionalInfoOrderByWithRelationInput | NutritionalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutritionalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionalInfos
    **/
    _count?: true | NutritionalInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutritionalInfoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutritionalInfoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionalInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionalInfoMaxAggregateInputType
  }

  export type GetNutritionalInfoAggregateType<T extends NutritionalInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionalInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionalInfo[P]>
      : GetScalarType<T[P], AggregateNutritionalInfo[P]>
  }




  export type NutritionalInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionalInfoWhereInput
    orderBy?: NutritionalInfoOrderByWithAggregationInput | NutritionalInfoOrderByWithAggregationInput[]
    by: NutritionalInfoScalarFieldEnum[] | NutritionalInfoScalarFieldEnum
    having?: NutritionalInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionalInfoCountAggregateInputType | true
    _avg?: NutritionalInfoAvgAggregateInputType
    _sum?: NutritionalInfoSumAggregateInputType
    _min?: NutritionalInfoMinAggregateInputType
    _max?: NutritionalInfoMaxAggregateInputType
  }

  export type NutritionalInfoGroupByOutputType = {
    id: string
    recipeId: string
    calories: number | null
    protein: number | null
    carbohydrates: number | null
    fat: number | null
    fiber: number | null
    sugar: number | null
    sodium: number | null
    cholesterol: number | null
    vitaminC: number | null
    vitaminD: number | null
    calcium: number | null
    iron: number | null
    potassium: number | null
    _count: NutritionalInfoCountAggregateOutputType | null
    _avg: NutritionalInfoAvgAggregateOutputType | null
    _sum: NutritionalInfoSumAggregateOutputType | null
    _min: NutritionalInfoMinAggregateOutputType | null
    _max: NutritionalInfoMaxAggregateOutputType | null
  }

  type GetNutritionalInfoGroupByPayload<T extends NutritionalInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionalInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionalInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionalInfoGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionalInfoGroupByOutputType[P]>
        }
      >
    >


  export type NutritionalInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    calories?: boolean
    protein?: boolean
    carbohydrates?: boolean
    fat?: boolean
    fiber?: boolean
    sugar?: boolean
    sodium?: boolean
    cholesterol?: boolean
    vitaminC?: boolean
    vitaminD?: boolean
    calcium?: boolean
    iron?: boolean
    potassium?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionalInfo"]>

  export type NutritionalInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    calories?: boolean
    protein?: boolean
    carbohydrates?: boolean
    fat?: boolean
    fiber?: boolean
    sugar?: boolean
    sodium?: boolean
    cholesterol?: boolean
    vitaminC?: boolean
    vitaminD?: boolean
    calcium?: boolean
    iron?: boolean
    potassium?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionalInfo"]>

  export type NutritionalInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    calories?: boolean
    protein?: boolean
    carbohydrates?: boolean
    fat?: boolean
    fiber?: boolean
    sugar?: boolean
    sodium?: boolean
    cholesterol?: boolean
    vitaminC?: boolean
    vitaminD?: boolean
    calcium?: boolean
    iron?: boolean
    potassium?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionalInfo"]>

  export type NutritionalInfoSelectScalar = {
    id?: boolean
    recipeId?: boolean
    calories?: boolean
    protein?: boolean
    carbohydrates?: boolean
    fat?: boolean
    fiber?: boolean
    sugar?: boolean
    sodium?: boolean
    cholesterol?: boolean
    vitaminC?: boolean
    vitaminD?: boolean
    calcium?: boolean
    iron?: boolean
    potassium?: boolean
  }

  export type NutritionalInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "calories" | "protein" | "carbohydrates" | "fat" | "fiber" | "sugar" | "sodium" | "cholesterol" | "vitaminC" | "vitaminD" | "calcium" | "iron" | "potassium", ExtArgs["result"]["nutritionalInfo"]>
  export type NutritionalInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type NutritionalInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type NutritionalInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $NutritionalInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutritionalInfo"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      calories: number | null
      protein: number | null
      carbohydrates: number | null
      fat: number | null
      fiber: number | null
      sugar: number | null
      sodium: number | null
      cholesterol: number | null
      vitaminC: number | null
      vitaminD: number | null
      calcium: number | null
      iron: number | null
      potassium: number | null
    }, ExtArgs["result"]["nutritionalInfo"]>
    composites: {}
  }

  type NutritionalInfoGetPayload<S extends boolean | null | undefined | NutritionalInfoDefaultArgs> = $Result.GetResult<Prisma.$NutritionalInfoPayload, S>

  type NutritionalInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NutritionalInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutritionalInfoCountAggregateInputType | true
    }

  export interface NutritionalInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutritionalInfo'], meta: { name: 'NutritionalInfo' } }
    /**
     * Find zero or one NutritionalInfo that matches the filter.
     * @param {NutritionalInfoFindUniqueArgs} args - Arguments to find a NutritionalInfo
     * @example
     * // Get one NutritionalInfo
     * const nutritionalInfo = await prisma.nutritionalInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutritionalInfoFindUniqueArgs>(args: SelectSubset<T, NutritionalInfoFindUniqueArgs<ExtArgs>>): Prisma__NutritionalInfoClient<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NutritionalInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NutritionalInfoFindUniqueOrThrowArgs} args - Arguments to find a NutritionalInfo
     * @example
     * // Get one NutritionalInfo
     * const nutritionalInfo = await prisma.nutritionalInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutritionalInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, NutritionalInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutritionalInfoClient<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalInfoFindFirstArgs} args - Arguments to find a NutritionalInfo
     * @example
     * // Get one NutritionalInfo
     * const nutritionalInfo = await prisma.nutritionalInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutritionalInfoFindFirstArgs>(args?: SelectSubset<T, NutritionalInfoFindFirstArgs<ExtArgs>>): Prisma__NutritionalInfoClient<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalInfoFindFirstOrThrowArgs} args - Arguments to find a NutritionalInfo
     * @example
     * // Get one NutritionalInfo
     * const nutritionalInfo = await prisma.nutritionalInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutritionalInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, NutritionalInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutritionalInfoClient<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NutritionalInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionalInfos
     * const nutritionalInfos = await prisma.nutritionalInfo.findMany()
     * 
     * // Get first 10 NutritionalInfos
     * const nutritionalInfos = await prisma.nutritionalInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionalInfoWithIdOnly = await prisma.nutritionalInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutritionalInfoFindManyArgs>(args?: SelectSubset<T, NutritionalInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NutritionalInfo.
     * @param {NutritionalInfoCreateArgs} args - Arguments to create a NutritionalInfo.
     * @example
     * // Create one NutritionalInfo
     * const NutritionalInfo = await prisma.nutritionalInfo.create({
     *   data: {
     *     // ... data to create a NutritionalInfo
     *   }
     * })
     * 
     */
    create<T extends NutritionalInfoCreateArgs>(args: SelectSubset<T, NutritionalInfoCreateArgs<ExtArgs>>): Prisma__NutritionalInfoClient<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NutritionalInfos.
     * @param {NutritionalInfoCreateManyArgs} args - Arguments to create many NutritionalInfos.
     * @example
     * // Create many NutritionalInfos
     * const nutritionalInfo = await prisma.nutritionalInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutritionalInfoCreateManyArgs>(args?: SelectSubset<T, NutritionalInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionalInfos and returns the data saved in the database.
     * @param {NutritionalInfoCreateManyAndReturnArgs} args - Arguments to create many NutritionalInfos.
     * @example
     * // Create many NutritionalInfos
     * const nutritionalInfo = await prisma.nutritionalInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionalInfos and only return the `id`
     * const nutritionalInfoWithIdOnly = await prisma.nutritionalInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutritionalInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, NutritionalInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NutritionalInfo.
     * @param {NutritionalInfoDeleteArgs} args - Arguments to delete one NutritionalInfo.
     * @example
     * // Delete one NutritionalInfo
     * const NutritionalInfo = await prisma.nutritionalInfo.delete({
     *   where: {
     *     // ... filter to delete one NutritionalInfo
     *   }
     * })
     * 
     */
    delete<T extends NutritionalInfoDeleteArgs>(args: SelectSubset<T, NutritionalInfoDeleteArgs<ExtArgs>>): Prisma__NutritionalInfoClient<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NutritionalInfo.
     * @param {NutritionalInfoUpdateArgs} args - Arguments to update one NutritionalInfo.
     * @example
     * // Update one NutritionalInfo
     * const nutritionalInfo = await prisma.nutritionalInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutritionalInfoUpdateArgs>(args: SelectSubset<T, NutritionalInfoUpdateArgs<ExtArgs>>): Prisma__NutritionalInfoClient<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NutritionalInfos.
     * @param {NutritionalInfoDeleteManyArgs} args - Arguments to filter NutritionalInfos to delete.
     * @example
     * // Delete a few NutritionalInfos
     * const { count } = await prisma.nutritionalInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutritionalInfoDeleteManyArgs>(args?: SelectSubset<T, NutritionalInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionalInfos
     * const nutritionalInfo = await prisma.nutritionalInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutritionalInfoUpdateManyArgs>(args: SelectSubset<T, NutritionalInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionalInfos and returns the data updated in the database.
     * @param {NutritionalInfoUpdateManyAndReturnArgs} args - Arguments to update many NutritionalInfos.
     * @example
     * // Update many NutritionalInfos
     * const nutritionalInfo = await prisma.nutritionalInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NutritionalInfos and only return the `id`
     * const nutritionalInfoWithIdOnly = await prisma.nutritionalInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NutritionalInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, NutritionalInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NutritionalInfo.
     * @param {NutritionalInfoUpsertArgs} args - Arguments to update or create a NutritionalInfo.
     * @example
     * // Update or create a NutritionalInfo
     * const nutritionalInfo = await prisma.nutritionalInfo.upsert({
     *   create: {
     *     // ... data to create a NutritionalInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionalInfo we want to update
     *   }
     * })
     */
    upsert<T extends NutritionalInfoUpsertArgs>(args: SelectSubset<T, NutritionalInfoUpsertArgs<ExtArgs>>): Prisma__NutritionalInfoClient<$Result.GetResult<Prisma.$NutritionalInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NutritionalInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalInfoCountArgs} args - Arguments to filter NutritionalInfos to count.
     * @example
     * // Count the number of NutritionalInfos
     * const count = await prisma.nutritionalInfo.count({
     *   where: {
     *     // ... the filter for the NutritionalInfos we want to count
     *   }
     * })
    **/
    count<T extends NutritionalInfoCountArgs>(
      args?: Subset<T, NutritionalInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionalInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionalInfoAggregateArgs>(args: Subset<T, NutritionalInfoAggregateArgs>): Prisma.PrismaPromise<GetNutritionalInfoAggregateType<T>>

    /**
     * Group by NutritionalInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionalInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionalInfoGroupByArgs['orderBy'] }
        : { orderBy?: NutritionalInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionalInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionalInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutritionalInfo model
   */
  readonly fields: NutritionalInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionalInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutritionalInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutritionalInfo model
   */
  interface NutritionalInfoFieldRefs {
    readonly id: FieldRef<"NutritionalInfo", 'String'>
    readonly recipeId: FieldRef<"NutritionalInfo", 'String'>
    readonly calories: FieldRef<"NutritionalInfo", 'Float'>
    readonly protein: FieldRef<"NutritionalInfo", 'Float'>
    readonly carbohydrates: FieldRef<"NutritionalInfo", 'Float'>
    readonly fat: FieldRef<"NutritionalInfo", 'Float'>
    readonly fiber: FieldRef<"NutritionalInfo", 'Float'>
    readonly sugar: FieldRef<"NutritionalInfo", 'Float'>
    readonly sodium: FieldRef<"NutritionalInfo", 'Float'>
    readonly cholesterol: FieldRef<"NutritionalInfo", 'Float'>
    readonly vitaminC: FieldRef<"NutritionalInfo", 'Float'>
    readonly vitaminD: FieldRef<"NutritionalInfo", 'Float'>
    readonly calcium: FieldRef<"NutritionalInfo", 'Float'>
    readonly iron: FieldRef<"NutritionalInfo", 'Float'>
    readonly potassium: FieldRef<"NutritionalInfo", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * NutritionalInfo findUnique
   */
  export type NutritionalInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalInfo to fetch.
     */
    where: NutritionalInfoWhereUniqueInput
  }

  /**
   * NutritionalInfo findUniqueOrThrow
   */
  export type NutritionalInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalInfo to fetch.
     */
    where: NutritionalInfoWhereUniqueInput
  }

  /**
   * NutritionalInfo findFirst
   */
  export type NutritionalInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalInfo to fetch.
     */
    where?: NutritionalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalInfos to fetch.
     */
    orderBy?: NutritionalInfoOrderByWithRelationInput | NutritionalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionalInfos.
     */
    cursor?: NutritionalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionalInfos.
     */
    distinct?: NutritionalInfoScalarFieldEnum | NutritionalInfoScalarFieldEnum[]
  }

  /**
   * NutritionalInfo findFirstOrThrow
   */
  export type NutritionalInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalInfo to fetch.
     */
    where?: NutritionalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalInfos to fetch.
     */
    orderBy?: NutritionalInfoOrderByWithRelationInput | NutritionalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionalInfos.
     */
    cursor?: NutritionalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionalInfos.
     */
    distinct?: NutritionalInfoScalarFieldEnum | NutritionalInfoScalarFieldEnum[]
  }

  /**
   * NutritionalInfo findMany
   */
  export type NutritionalInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalInfos to fetch.
     */
    where?: NutritionalInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalInfos to fetch.
     */
    orderBy?: NutritionalInfoOrderByWithRelationInput | NutritionalInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionalInfos.
     */
    cursor?: NutritionalInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalInfos.
     */
    skip?: number
    distinct?: NutritionalInfoScalarFieldEnum | NutritionalInfoScalarFieldEnum[]
  }

  /**
   * NutritionalInfo create
   */
  export type NutritionalInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a NutritionalInfo.
     */
    data: XOR<NutritionalInfoCreateInput, NutritionalInfoUncheckedCreateInput>
  }

  /**
   * NutritionalInfo createMany
   */
  export type NutritionalInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutritionalInfos.
     */
    data: NutritionalInfoCreateManyInput | NutritionalInfoCreateManyInput[]
  }

  /**
   * NutritionalInfo createManyAndReturn
   */
  export type NutritionalInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * The data used to create many NutritionalInfos.
     */
    data: NutritionalInfoCreateManyInput | NutritionalInfoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionalInfo update
   */
  export type NutritionalInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a NutritionalInfo.
     */
    data: XOR<NutritionalInfoUpdateInput, NutritionalInfoUncheckedUpdateInput>
    /**
     * Choose, which NutritionalInfo to update.
     */
    where: NutritionalInfoWhereUniqueInput
  }

  /**
   * NutritionalInfo updateMany
   */
  export type NutritionalInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutritionalInfos.
     */
    data: XOR<NutritionalInfoUpdateManyMutationInput, NutritionalInfoUncheckedUpdateManyInput>
    /**
     * Filter which NutritionalInfos to update
     */
    where?: NutritionalInfoWhereInput
    /**
     * Limit how many NutritionalInfos to update.
     */
    limit?: number
  }

  /**
   * NutritionalInfo updateManyAndReturn
   */
  export type NutritionalInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * The data used to update NutritionalInfos.
     */
    data: XOR<NutritionalInfoUpdateManyMutationInput, NutritionalInfoUncheckedUpdateManyInput>
    /**
     * Filter which NutritionalInfos to update
     */
    where?: NutritionalInfoWhereInput
    /**
     * Limit how many NutritionalInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NutritionalInfo upsert
   */
  export type NutritionalInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the NutritionalInfo to update in case it exists.
     */
    where: NutritionalInfoWhereUniqueInput
    /**
     * In case the NutritionalInfo found by the `where` argument doesn't exist, create a new NutritionalInfo with this data.
     */
    create: XOR<NutritionalInfoCreateInput, NutritionalInfoUncheckedCreateInput>
    /**
     * In case the NutritionalInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutritionalInfoUpdateInput, NutritionalInfoUncheckedUpdateInput>
  }

  /**
   * NutritionalInfo delete
   */
  export type NutritionalInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
    /**
     * Filter which NutritionalInfo to delete.
     */
    where: NutritionalInfoWhereUniqueInput
  }

  /**
   * NutritionalInfo deleteMany
   */
  export type NutritionalInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionalInfos to delete
     */
    where?: NutritionalInfoWhereInput
    /**
     * Limit how many NutritionalInfos to delete.
     */
    limit?: number
  }

  /**
   * NutritionalInfo without action
   */
  export type NutritionalInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalInfo
     */
    select?: NutritionalInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalInfo
     */
    omit?: NutritionalInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalInfoInclude<ExtArgs> | null
  }


  /**
   * Model MedicalTag
   */

  export type AggregateMedicalTag = {
    _count: MedicalTagCountAggregateOutputType | null
    _min: MedicalTagMinAggregateOutputType | null
    _max: MedicalTagMaxAggregateOutputType | null
  }

  export type MedicalTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    condition: string | null
  }

  export type MedicalTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    condition: string | null
  }

  export type MedicalTagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    condition: number
    _all: number
  }


  export type MedicalTagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    condition?: true
  }

  export type MedicalTagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    condition?: true
  }

  export type MedicalTagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    condition?: true
    _all?: true
  }

  export type MedicalTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalTag to aggregate.
     */
    where?: MedicalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalTags to fetch.
     */
    orderBy?: MedicalTagOrderByWithRelationInput | MedicalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalTags
    **/
    _count?: true | MedicalTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalTagMaxAggregateInputType
  }

  export type GetMedicalTagAggregateType<T extends MedicalTagAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalTag[P]>
      : GetScalarType<T[P], AggregateMedicalTag[P]>
  }




  export type MedicalTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalTagWhereInput
    orderBy?: MedicalTagOrderByWithAggregationInput | MedicalTagOrderByWithAggregationInput[]
    by: MedicalTagScalarFieldEnum[] | MedicalTagScalarFieldEnum
    having?: MedicalTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalTagCountAggregateInputType | true
    _min?: MedicalTagMinAggregateInputType
    _max?: MedicalTagMaxAggregateInputType
  }

  export type MedicalTagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    condition: string
    _count: MedicalTagCountAggregateOutputType | null
    _min: MedicalTagMinAggregateOutputType | null
    _max: MedicalTagMaxAggregateOutputType | null
  }

  type GetMedicalTagGroupByPayload<T extends MedicalTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalTagGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalTagGroupByOutputType[P]>
        }
      >
    >


  export type MedicalTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    condition?: boolean
    recipes?: boolean | MedicalTag$recipesArgs<ExtArgs>
    _count?: boolean | MedicalTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalTag"]>

  export type MedicalTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    condition?: boolean
  }, ExtArgs["result"]["medicalTag"]>

  export type MedicalTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    condition?: boolean
  }, ExtArgs["result"]["medicalTag"]>

  export type MedicalTagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    condition?: boolean
  }

  export type MedicalTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "condition", ExtArgs["result"]["medicalTag"]>
  export type MedicalTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | MedicalTag$recipesArgs<ExtArgs>
    _count?: boolean | MedicalTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicalTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MedicalTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MedicalTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalTag"
    objects: {
      recipes: Prisma.$RecipeMedicalTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      condition: string
    }, ExtArgs["result"]["medicalTag"]>
    composites: {}
  }

  type MedicalTagGetPayload<S extends boolean | null | undefined | MedicalTagDefaultArgs> = $Result.GetResult<Prisma.$MedicalTagPayload, S>

  type MedicalTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalTagCountAggregateInputType | true
    }

  export interface MedicalTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalTag'], meta: { name: 'MedicalTag' } }
    /**
     * Find zero or one MedicalTag that matches the filter.
     * @param {MedicalTagFindUniqueArgs} args - Arguments to find a MedicalTag
     * @example
     * // Get one MedicalTag
     * const medicalTag = await prisma.medicalTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalTagFindUniqueArgs>(args: SelectSubset<T, MedicalTagFindUniqueArgs<ExtArgs>>): Prisma__MedicalTagClient<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalTagFindUniqueOrThrowArgs} args - Arguments to find a MedicalTag
     * @example
     * // Get one MedicalTag
     * const medicalTag = await prisma.medicalTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalTagFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalTagClient<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalTagFindFirstArgs} args - Arguments to find a MedicalTag
     * @example
     * // Get one MedicalTag
     * const medicalTag = await prisma.medicalTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalTagFindFirstArgs>(args?: SelectSubset<T, MedicalTagFindFirstArgs<ExtArgs>>): Prisma__MedicalTagClient<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalTagFindFirstOrThrowArgs} args - Arguments to find a MedicalTag
     * @example
     * // Get one MedicalTag
     * const medicalTag = await prisma.medicalTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalTagFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalTagClient<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalTags
     * const medicalTags = await prisma.medicalTag.findMany()
     * 
     * // Get first 10 MedicalTags
     * const medicalTags = await prisma.medicalTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalTagWithIdOnly = await prisma.medicalTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalTagFindManyArgs>(args?: SelectSubset<T, MedicalTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalTag.
     * @param {MedicalTagCreateArgs} args - Arguments to create a MedicalTag.
     * @example
     * // Create one MedicalTag
     * const MedicalTag = await prisma.medicalTag.create({
     *   data: {
     *     // ... data to create a MedicalTag
     *   }
     * })
     * 
     */
    create<T extends MedicalTagCreateArgs>(args: SelectSubset<T, MedicalTagCreateArgs<ExtArgs>>): Prisma__MedicalTagClient<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalTags.
     * @param {MedicalTagCreateManyArgs} args - Arguments to create many MedicalTags.
     * @example
     * // Create many MedicalTags
     * const medicalTag = await prisma.medicalTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalTagCreateManyArgs>(args?: SelectSubset<T, MedicalTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalTags and returns the data saved in the database.
     * @param {MedicalTagCreateManyAndReturnArgs} args - Arguments to create many MedicalTags.
     * @example
     * // Create many MedicalTags
     * const medicalTag = await prisma.medicalTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalTags and only return the `id`
     * const medicalTagWithIdOnly = await prisma.medicalTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalTagCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalTag.
     * @param {MedicalTagDeleteArgs} args - Arguments to delete one MedicalTag.
     * @example
     * // Delete one MedicalTag
     * const MedicalTag = await prisma.medicalTag.delete({
     *   where: {
     *     // ... filter to delete one MedicalTag
     *   }
     * })
     * 
     */
    delete<T extends MedicalTagDeleteArgs>(args: SelectSubset<T, MedicalTagDeleteArgs<ExtArgs>>): Prisma__MedicalTagClient<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalTag.
     * @param {MedicalTagUpdateArgs} args - Arguments to update one MedicalTag.
     * @example
     * // Update one MedicalTag
     * const medicalTag = await prisma.medicalTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalTagUpdateArgs>(args: SelectSubset<T, MedicalTagUpdateArgs<ExtArgs>>): Prisma__MedicalTagClient<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalTags.
     * @param {MedicalTagDeleteManyArgs} args - Arguments to filter MedicalTags to delete.
     * @example
     * // Delete a few MedicalTags
     * const { count } = await prisma.medicalTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalTagDeleteManyArgs>(args?: SelectSubset<T, MedicalTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalTags
     * const medicalTag = await prisma.medicalTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalTagUpdateManyArgs>(args: SelectSubset<T, MedicalTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalTags and returns the data updated in the database.
     * @param {MedicalTagUpdateManyAndReturnArgs} args - Arguments to update many MedicalTags.
     * @example
     * // Update many MedicalTags
     * const medicalTag = await prisma.medicalTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalTags and only return the `id`
     * const medicalTagWithIdOnly = await prisma.medicalTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalTagUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalTag.
     * @param {MedicalTagUpsertArgs} args - Arguments to update or create a MedicalTag.
     * @example
     * // Update or create a MedicalTag
     * const medicalTag = await prisma.medicalTag.upsert({
     *   create: {
     *     // ... data to create a MedicalTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalTag we want to update
     *   }
     * })
     */
    upsert<T extends MedicalTagUpsertArgs>(args: SelectSubset<T, MedicalTagUpsertArgs<ExtArgs>>): Prisma__MedicalTagClient<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalTagCountArgs} args - Arguments to filter MedicalTags to count.
     * @example
     * // Count the number of MedicalTags
     * const count = await prisma.medicalTag.count({
     *   where: {
     *     // ... the filter for the MedicalTags we want to count
     *   }
     * })
    **/
    count<T extends MedicalTagCountArgs>(
      args?: Subset<T, MedicalTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalTagAggregateArgs>(args: Subset<T, MedicalTagAggregateArgs>): Prisma.PrismaPromise<GetMedicalTagAggregateType<T>>

    /**
     * Group by MedicalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalTagGroupByArgs['orderBy'] }
        : { orderBy?: MedicalTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalTag model
   */
  readonly fields: MedicalTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipes<T extends MedicalTag$recipesArgs<ExtArgs> = {}>(args?: Subset<T, MedicalTag$recipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalTag model
   */
  interface MedicalTagFieldRefs {
    readonly id: FieldRef<"MedicalTag", 'String'>
    readonly name: FieldRef<"MedicalTag", 'String'>
    readonly description: FieldRef<"MedicalTag", 'String'>
    readonly condition: FieldRef<"MedicalTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MedicalTag findUnique
   */
  export type MedicalTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which MedicalTag to fetch.
     */
    where: MedicalTagWhereUniqueInput
  }

  /**
   * MedicalTag findUniqueOrThrow
   */
  export type MedicalTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which MedicalTag to fetch.
     */
    where: MedicalTagWhereUniqueInput
  }

  /**
   * MedicalTag findFirst
   */
  export type MedicalTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which MedicalTag to fetch.
     */
    where?: MedicalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalTags to fetch.
     */
    orderBy?: MedicalTagOrderByWithRelationInput | MedicalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalTags.
     */
    cursor?: MedicalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalTags.
     */
    distinct?: MedicalTagScalarFieldEnum | MedicalTagScalarFieldEnum[]
  }

  /**
   * MedicalTag findFirstOrThrow
   */
  export type MedicalTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which MedicalTag to fetch.
     */
    where?: MedicalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalTags to fetch.
     */
    orderBy?: MedicalTagOrderByWithRelationInput | MedicalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalTags.
     */
    cursor?: MedicalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalTags.
     */
    distinct?: MedicalTagScalarFieldEnum | MedicalTagScalarFieldEnum[]
  }

  /**
   * MedicalTag findMany
   */
  export type MedicalTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which MedicalTags to fetch.
     */
    where?: MedicalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalTags to fetch.
     */
    orderBy?: MedicalTagOrderByWithRelationInput | MedicalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalTags.
     */
    cursor?: MedicalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalTags.
     */
    skip?: number
    distinct?: MedicalTagScalarFieldEnum | MedicalTagScalarFieldEnum[]
  }

  /**
   * MedicalTag create
   */
  export type MedicalTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalTag.
     */
    data: XOR<MedicalTagCreateInput, MedicalTagUncheckedCreateInput>
  }

  /**
   * MedicalTag createMany
   */
  export type MedicalTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalTags.
     */
    data: MedicalTagCreateManyInput | MedicalTagCreateManyInput[]
  }

  /**
   * MedicalTag createManyAndReturn
   */
  export type MedicalTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalTags.
     */
    data: MedicalTagCreateManyInput | MedicalTagCreateManyInput[]
  }

  /**
   * MedicalTag update
   */
  export type MedicalTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalTag.
     */
    data: XOR<MedicalTagUpdateInput, MedicalTagUncheckedUpdateInput>
    /**
     * Choose, which MedicalTag to update.
     */
    where: MedicalTagWhereUniqueInput
  }

  /**
   * MedicalTag updateMany
   */
  export type MedicalTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalTags.
     */
    data: XOR<MedicalTagUpdateManyMutationInput, MedicalTagUncheckedUpdateManyInput>
    /**
     * Filter which MedicalTags to update
     */
    where?: MedicalTagWhereInput
    /**
     * Limit how many MedicalTags to update.
     */
    limit?: number
  }

  /**
   * MedicalTag updateManyAndReturn
   */
  export type MedicalTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * The data used to update MedicalTags.
     */
    data: XOR<MedicalTagUpdateManyMutationInput, MedicalTagUncheckedUpdateManyInput>
    /**
     * Filter which MedicalTags to update
     */
    where?: MedicalTagWhereInput
    /**
     * Limit how many MedicalTags to update.
     */
    limit?: number
  }

  /**
   * MedicalTag upsert
   */
  export type MedicalTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalTag to update in case it exists.
     */
    where: MedicalTagWhereUniqueInput
    /**
     * In case the MedicalTag found by the `where` argument doesn't exist, create a new MedicalTag with this data.
     */
    create: XOR<MedicalTagCreateInput, MedicalTagUncheckedCreateInput>
    /**
     * In case the MedicalTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalTagUpdateInput, MedicalTagUncheckedUpdateInput>
  }

  /**
   * MedicalTag delete
   */
  export type MedicalTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
    /**
     * Filter which MedicalTag to delete.
     */
    where: MedicalTagWhereUniqueInput
  }

  /**
   * MedicalTag deleteMany
   */
  export type MedicalTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalTags to delete
     */
    where?: MedicalTagWhereInput
    /**
     * Limit how many MedicalTags to delete.
     */
    limit?: number
  }

  /**
   * MedicalTag.recipes
   */
  export type MedicalTag$recipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    where?: RecipeMedicalTagWhereInput
    orderBy?: RecipeMedicalTagOrderByWithRelationInput | RecipeMedicalTagOrderByWithRelationInput[]
    cursor?: RecipeMedicalTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeMedicalTagScalarFieldEnum | RecipeMedicalTagScalarFieldEnum[]
  }

  /**
   * MedicalTag without action
   */
  export type MedicalTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalTag
     */
    select?: MedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalTag
     */
    omit?: MedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalTagInclude<ExtArgs> | null
  }


  /**
   * Model RecipeMedicalTag
   */

  export type AggregateRecipeMedicalTag = {
    _count: RecipeMedicalTagCountAggregateOutputType | null
    _min: RecipeMedicalTagMinAggregateOutputType | null
    _max: RecipeMedicalTagMaxAggregateOutputType | null
  }

  export type RecipeMedicalTagMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    medicalTagId: string | null
  }

  export type RecipeMedicalTagMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    medicalTagId: string | null
  }

  export type RecipeMedicalTagCountAggregateOutputType = {
    id: number
    recipeId: number
    medicalTagId: number
    _all: number
  }


  export type RecipeMedicalTagMinAggregateInputType = {
    id?: true
    recipeId?: true
    medicalTagId?: true
  }

  export type RecipeMedicalTagMaxAggregateInputType = {
    id?: true
    recipeId?: true
    medicalTagId?: true
  }

  export type RecipeMedicalTagCountAggregateInputType = {
    id?: true
    recipeId?: true
    medicalTagId?: true
    _all?: true
  }

  export type RecipeMedicalTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeMedicalTag to aggregate.
     */
    where?: RecipeMedicalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeMedicalTags to fetch.
     */
    orderBy?: RecipeMedicalTagOrderByWithRelationInput | RecipeMedicalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeMedicalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeMedicalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeMedicalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeMedicalTags
    **/
    _count?: true | RecipeMedicalTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMedicalTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMedicalTagMaxAggregateInputType
  }

  export type GetRecipeMedicalTagAggregateType<T extends RecipeMedicalTagAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeMedicalTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeMedicalTag[P]>
      : GetScalarType<T[P], AggregateRecipeMedicalTag[P]>
  }




  export type RecipeMedicalTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeMedicalTagWhereInput
    orderBy?: RecipeMedicalTagOrderByWithAggregationInput | RecipeMedicalTagOrderByWithAggregationInput[]
    by: RecipeMedicalTagScalarFieldEnum[] | RecipeMedicalTagScalarFieldEnum
    having?: RecipeMedicalTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeMedicalTagCountAggregateInputType | true
    _min?: RecipeMedicalTagMinAggregateInputType
    _max?: RecipeMedicalTagMaxAggregateInputType
  }

  export type RecipeMedicalTagGroupByOutputType = {
    id: string
    recipeId: string
    medicalTagId: string
    _count: RecipeMedicalTagCountAggregateOutputType | null
    _min: RecipeMedicalTagMinAggregateOutputType | null
    _max: RecipeMedicalTagMaxAggregateOutputType | null
  }

  type GetRecipeMedicalTagGroupByPayload<T extends RecipeMedicalTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeMedicalTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeMedicalTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeMedicalTagGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeMedicalTagGroupByOutputType[P]>
        }
      >
    >


  export type RecipeMedicalTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    medicalTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    medicalTag?: boolean | MedicalTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeMedicalTag"]>

  export type RecipeMedicalTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    medicalTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    medicalTag?: boolean | MedicalTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeMedicalTag"]>

  export type RecipeMedicalTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    medicalTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    medicalTag?: boolean | MedicalTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeMedicalTag"]>

  export type RecipeMedicalTagSelectScalar = {
    id?: boolean
    recipeId?: boolean
    medicalTagId?: boolean
  }

  export type RecipeMedicalTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "medicalTagId", ExtArgs["result"]["recipeMedicalTag"]>
  export type RecipeMedicalTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    medicalTag?: boolean | MedicalTagDefaultArgs<ExtArgs>
  }
  export type RecipeMedicalTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    medicalTag?: boolean | MedicalTagDefaultArgs<ExtArgs>
  }
  export type RecipeMedicalTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    medicalTag?: boolean | MedicalTagDefaultArgs<ExtArgs>
  }

  export type $RecipeMedicalTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeMedicalTag"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      medicalTag: Prisma.$MedicalTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      medicalTagId: string
    }, ExtArgs["result"]["recipeMedicalTag"]>
    composites: {}
  }

  type RecipeMedicalTagGetPayload<S extends boolean | null | undefined | RecipeMedicalTagDefaultArgs> = $Result.GetResult<Prisma.$RecipeMedicalTagPayload, S>

  type RecipeMedicalTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeMedicalTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeMedicalTagCountAggregateInputType | true
    }

  export interface RecipeMedicalTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeMedicalTag'], meta: { name: 'RecipeMedicalTag' } }
    /**
     * Find zero or one RecipeMedicalTag that matches the filter.
     * @param {RecipeMedicalTagFindUniqueArgs} args - Arguments to find a RecipeMedicalTag
     * @example
     * // Get one RecipeMedicalTag
     * const recipeMedicalTag = await prisma.recipeMedicalTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeMedicalTagFindUniqueArgs>(args: SelectSubset<T, RecipeMedicalTagFindUniqueArgs<ExtArgs>>): Prisma__RecipeMedicalTagClient<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeMedicalTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeMedicalTagFindUniqueOrThrowArgs} args - Arguments to find a RecipeMedicalTag
     * @example
     * // Get one RecipeMedicalTag
     * const recipeMedicalTag = await prisma.recipeMedicalTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeMedicalTagFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeMedicalTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeMedicalTagClient<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeMedicalTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMedicalTagFindFirstArgs} args - Arguments to find a RecipeMedicalTag
     * @example
     * // Get one RecipeMedicalTag
     * const recipeMedicalTag = await prisma.recipeMedicalTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeMedicalTagFindFirstArgs>(args?: SelectSubset<T, RecipeMedicalTagFindFirstArgs<ExtArgs>>): Prisma__RecipeMedicalTagClient<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeMedicalTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMedicalTagFindFirstOrThrowArgs} args - Arguments to find a RecipeMedicalTag
     * @example
     * // Get one RecipeMedicalTag
     * const recipeMedicalTag = await prisma.recipeMedicalTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeMedicalTagFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeMedicalTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeMedicalTagClient<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeMedicalTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMedicalTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeMedicalTags
     * const recipeMedicalTags = await prisma.recipeMedicalTag.findMany()
     * 
     * // Get first 10 RecipeMedicalTags
     * const recipeMedicalTags = await prisma.recipeMedicalTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeMedicalTagWithIdOnly = await prisma.recipeMedicalTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeMedicalTagFindManyArgs>(args?: SelectSubset<T, RecipeMedicalTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeMedicalTag.
     * @param {RecipeMedicalTagCreateArgs} args - Arguments to create a RecipeMedicalTag.
     * @example
     * // Create one RecipeMedicalTag
     * const RecipeMedicalTag = await prisma.recipeMedicalTag.create({
     *   data: {
     *     // ... data to create a RecipeMedicalTag
     *   }
     * })
     * 
     */
    create<T extends RecipeMedicalTagCreateArgs>(args: SelectSubset<T, RecipeMedicalTagCreateArgs<ExtArgs>>): Prisma__RecipeMedicalTagClient<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeMedicalTags.
     * @param {RecipeMedicalTagCreateManyArgs} args - Arguments to create many RecipeMedicalTags.
     * @example
     * // Create many RecipeMedicalTags
     * const recipeMedicalTag = await prisma.recipeMedicalTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeMedicalTagCreateManyArgs>(args?: SelectSubset<T, RecipeMedicalTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeMedicalTags and returns the data saved in the database.
     * @param {RecipeMedicalTagCreateManyAndReturnArgs} args - Arguments to create many RecipeMedicalTags.
     * @example
     * // Create many RecipeMedicalTags
     * const recipeMedicalTag = await prisma.recipeMedicalTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeMedicalTags and only return the `id`
     * const recipeMedicalTagWithIdOnly = await prisma.recipeMedicalTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeMedicalTagCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeMedicalTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeMedicalTag.
     * @param {RecipeMedicalTagDeleteArgs} args - Arguments to delete one RecipeMedicalTag.
     * @example
     * // Delete one RecipeMedicalTag
     * const RecipeMedicalTag = await prisma.recipeMedicalTag.delete({
     *   where: {
     *     // ... filter to delete one RecipeMedicalTag
     *   }
     * })
     * 
     */
    delete<T extends RecipeMedicalTagDeleteArgs>(args: SelectSubset<T, RecipeMedicalTagDeleteArgs<ExtArgs>>): Prisma__RecipeMedicalTagClient<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeMedicalTag.
     * @param {RecipeMedicalTagUpdateArgs} args - Arguments to update one RecipeMedicalTag.
     * @example
     * // Update one RecipeMedicalTag
     * const recipeMedicalTag = await prisma.recipeMedicalTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeMedicalTagUpdateArgs>(args: SelectSubset<T, RecipeMedicalTagUpdateArgs<ExtArgs>>): Prisma__RecipeMedicalTagClient<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeMedicalTags.
     * @param {RecipeMedicalTagDeleteManyArgs} args - Arguments to filter RecipeMedicalTags to delete.
     * @example
     * // Delete a few RecipeMedicalTags
     * const { count } = await prisma.recipeMedicalTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeMedicalTagDeleteManyArgs>(args?: SelectSubset<T, RecipeMedicalTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeMedicalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMedicalTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeMedicalTags
     * const recipeMedicalTag = await prisma.recipeMedicalTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeMedicalTagUpdateManyArgs>(args: SelectSubset<T, RecipeMedicalTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeMedicalTags and returns the data updated in the database.
     * @param {RecipeMedicalTagUpdateManyAndReturnArgs} args - Arguments to update many RecipeMedicalTags.
     * @example
     * // Update many RecipeMedicalTags
     * const recipeMedicalTag = await prisma.recipeMedicalTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeMedicalTags and only return the `id`
     * const recipeMedicalTagWithIdOnly = await prisma.recipeMedicalTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeMedicalTagUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeMedicalTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeMedicalTag.
     * @param {RecipeMedicalTagUpsertArgs} args - Arguments to update or create a RecipeMedicalTag.
     * @example
     * // Update or create a RecipeMedicalTag
     * const recipeMedicalTag = await prisma.recipeMedicalTag.upsert({
     *   create: {
     *     // ... data to create a RecipeMedicalTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeMedicalTag we want to update
     *   }
     * })
     */
    upsert<T extends RecipeMedicalTagUpsertArgs>(args: SelectSubset<T, RecipeMedicalTagUpsertArgs<ExtArgs>>): Prisma__RecipeMedicalTagClient<$Result.GetResult<Prisma.$RecipeMedicalTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeMedicalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMedicalTagCountArgs} args - Arguments to filter RecipeMedicalTags to count.
     * @example
     * // Count the number of RecipeMedicalTags
     * const count = await prisma.recipeMedicalTag.count({
     *   where: {
     *     // ... the filter for the RecipeMedicalTags we want to count
     *   }
     * })
    **/
    count<T extends RecipeMedicalTagCountArgs>(
      args?: Subset<T, RecipeMedicalTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeMedicalTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeMedicalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMedicalTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeMedicalTagAggregateArgs>(args: Subset<T, RecipeMedicalTagAggregateArgs>): Prisma.PrismaPromise<GetRecipeMedicalTagAggregateType<T>>

    /**
     * Group by RecipeMedicalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeMedicalTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeMedicalTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeMedicalTagGroupByArgs['orderBy'] }
        : { orderBy?: RecipeMedicalTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeMedicalTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeMedicalTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeMedicalTag model
   */
  readonly fields: RecipeMedicalTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeMedicalTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeMedicalTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicalTag<T extends MedicalTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalTagDefaultArgs<ExtArgs>>): Prisma__MedicalTagClient<$Result.GetResult<Prisma.$MedicalTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeMedicalTag model
   */
  interface RecipeMedicalTagFieldRefs {
    readonly id: FieldRef<"RecipeMedicalTag", 'String'>
    readonly recipeId: FieldRef<"RecipeMedicalTag", 'String'>
    readonly medicalTagId: FieldRef<"RecipeMedicalTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecipeMedicalTag findUnique
   */
  export type RecipeMedicalTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMedicalTag to fetch.
     */
    where: RecipeMedicalTagWhereUniqueInput
  }

  /**
   * RecipeMedicalTag findUniqueOrThrow
   */
  export type RecipeMedicalTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMedicalTag to fetch.
     */
    where: RecipeMedicalTagWhereUniqueInput
  }

  /**
   * RecipeMedicalTag findFirst
   */
  export type RecipeMedicalTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMedicalTag to fetch.
     */
    where?: RecipeMedicalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeMedicalTags to fetch.
     */
    orderBy?: RecipeMedicalTagOrderByWithRelationInput | RecipeMedicalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeMedicalTags.
     */
    cursor?: RecipeMedicalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeMedicalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeMedicalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeMedicalTags.
     */
    distinct?: RecipeMedicalTagScalarFieldEnum | RecipeMedicalTagScalarFieldEnum[]
  }

  /**
   * RecipeMedicalTag findFirstOrThrow
   */
  export type RecipeMedicalTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMedicalTag to fetch.
     */
    where?: RecipeMedicalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeMedicalTags to fetch.
     */
    orderBy?: RecipeMedicalTagOrderByWithRelationInput | RecipeMedicalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeMedicalTags.
     */
    cursor?: RecipeMedicalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeMedicalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeMedicalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeMedicalTags.
     */
    distinct?: RecipeMedicalTagScalarFieldEnum | RecipeMedicalTagScalarFieldEnum[]
  }

  /**
   * RecipeMedicalTag findMany
   */
  export type RecipeMedicalTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeMedicalTags to fetch.
     */
    where?: RecipeMedicalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeMedicalTags to fetch.
     */
    orderBy?: RecipeMedicalTagOrderByWithRelationInput | RecipeMedicalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeMedicalTags.
     */
    cursor?: RecipeMedicalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeMedicalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeMedicalTags.
     */
    skip?: number
    distinct?: RecipeMedicalTagScalarFieldEnum | RecipeMedicalTagScalarFieldEnum[]
  }

  /**
   * RecipeMedicalTag create
   */
  export type RecipeMedicalTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeMedicalTag.
     */
    data: XOR<RecipeMedicalTagCreateInput, RecipeMedicalTagUncheckedCreateInput>
  }

  /**
   * RecipeMedicalTag createMany
   */
  export type RecipeMedicalTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeMedicalTags.
     */
    data: RecipeMedicalTagCreateManyInput | RecipeMedicalTagCreateManyInput[]
  }

  /**
   * RecipeMedicalTag createManyAndReturn
   */
  export type RecipeMedicalTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeMedicalTags.
     */
    data: RecipeMedicalTagCreateManyInput | RecipeMedicalTagCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeMedicalTag update
   */
  export type RecipeMedicalTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeMedicalTag.
     */
    data: XOR<RecipeMedicalTagUpdateInput, RecipeMedicalTagUncheckedUpdateInput>
    /**
     * Choose, which RecipeMedicalTag to update.
     */
    where: RecipeMedicalTagWhereUniqueInput
  }

  /**
   * RecipeMedicalTag updateMany
   */
  export type RecipeMedicalTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeMedicalTags.
     */
    data: XOR<RecipeMedicalTagUpdateManyMutationInput, RecipeMedicalTagUncheckedUpdateManyInput>
    /**
     * Filter which RecipeMedicalTags to update
     */
    where?: RecipeMedicalTagWhereInput
    /**
     * Limit how many RecipeMedicalTags to update.
     */
    limit?: number
  }

  /**
   * RecipeMedicalTag updateManyAndReturn
   */
  export type RecipeMedicalTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * The data used to update RecipeMedicalTags.
     */
    data: XOR<RecipeMedicalTagUpdateManyMutationInput, RecipeMedicalTagUncheckedUpdateManyInput>
    /**
     * Filter which RecipeMedicalTags to update
     */
    where?: RecipeMedicalTagWhereInput
    /**
     * Limit how many RecipeMedicalTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeMedicalTag upsert
   */
  export type RecipeMedicalTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeMedicalTag to update in case it exists.
     */
    where: RecipeMedicalTagWhereUniqueInput
    /**
     * In case the RecipeMedicalTag found by the `where` argument doesn't exist, create a new RecipeMedicalTag with this data.
     */
    create: XOR<RecipeMedicalTagCreateInput, RecipeMedicalTagUncheckedCreateInput>
    /**
     * In case the RecipeMedicalTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeMedicalTagUpdateInput, RecipeMedicalTagUncheckedUpdateInput>
  }

  /**
   * RecipeMedicalTag delete
   */
  export type RecipeMedicalTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
    /**
     * Filter which RecipeMedicalTag to delete.
     */
    where: RecipeMedicalTagWhereUniqueInput
  }

  /**
   * RecipeMedicalTag deleteMany
   */
  export type RecipeMedicalTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeMedicalTags to delete
     */
    where?: RecipeMedicalTagWhereInput
    /**
     * Limit how many RecipeMedicalTags to delete.
     */
    limit?: number
  }

  /**
   * RecipeMedicalTag without action
   */
  export type RecipeMedicalTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeMedicalTag
     */
    select?: RecipeMedicalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeMedicalTag
     */
    omit?: RecipeMedicalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeMedicalTagInclude<ExtArgs> | null
  }


  /**
   * Model DietaryTag
   */

  export type AggregateDietaryTag = {
    _count: DietaryTagCountAggregateOutputType | null
    _min: DietaryTagMinAggregateOutputType | null
    _max: DietaryTagMaxAggregateOutputType | null
  }

  export type DietaryTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.DietaryCategory | null
  }

  export type DietaryTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.DietaryCategory | null
  }

  export type DietaryTagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    _all: number
  }


  export type DietaryTagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type DietaryTagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type DietaryTagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    _all?: true
  }

  export type DietaryTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietaryTag to aggregate.
     */
    where?: DietaryTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietaryTags to fetch.
     */
    orderBy?: DietaryTagOrderByWithRelationInput | DietaryTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DietaryTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietaryTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietaryTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DietaryTags
    **/
    _count?: true | DietaryTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DietaryTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DietaryTagMaxAggregateInputType
  }

  export type GetDietaryTagAggregateType<T extends DietaryTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDietaryTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDietaryTag[P]>
      : GetScalarType<T[P], AggregateDietaryTag[P]>
  }




  export type DietaryTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DietaryTagWhereInput
    orderBy?: DietaryTagOrderByWithAggregationInput | DietaryTagOrderByWithAggregationInput[]
    by: DietaryTagScalarFieldEnum[] | DietaryTagScalarFieldEnum
    having?: DietaryTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DietaryTagCountAggregateInputType | true
    _min?: DietaryTagMinAggregateInputType
    _max?: DietaryTagMaxAggregateInputType
  }

  export type DietaryTagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: $Enums.DietaryCategory
    _count: DietaryTagCountAggregateOutputType | null
    _min: DietaryTagMinAggregateOutputType | null
    _max: DietaryTagMaxAggregateOutputType | null
  }

  type GetDietaryTagGroupByPayload<T extends DietaryTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DietaryTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DietaryTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DietaryTagGroupByOutputType[P]>
            : GetScalarType<T[P], DietaryTagGroupByOutputType[P]>
        }
      >
    >


  export type DietaryTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    recipes?: boolean | DietaryTag$recipesArgs<ExtArgs>
    _count?: boolean | DietaryTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dietaryTag"]>

  export type DietaryTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["dietaryTag"]>

  export type DietaryTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["dietaryTag"]>

  export type DietaryTagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }

  export type DietaryTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category", ExtArgs["result"]["dietaryTag"]>
  export type DietaryTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | DietaryTag$recipesArgs<ExtArgs>
    _count?: boolean | DietaryTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DietaryTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DietaryTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DietaryTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DietaryTag"
    objects: {
      recipes: Prisma.$RecipeDietaryTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: $Enums.DietaryCategory
    }, ExtArgs["result"]["dietaryTag"]>
    composites: {}
  }

  type DietaryTagGetPayload<S extends boolean | null | undefined | DietaryTagDefaultArgs> = $Result.GetResult<Prisma.$DietaryTagPayload, S>

  type DietaryTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DietaryTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DietaryTagCountAggregateInputType | true
    }

  export interface DietaryTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DietaryTag'], meta: { name: 'DietaryTag' } }
    /**
     * Find zero or one DietaryTag that matches the filter.
     * @param {DietaryTagFindUniqueArgs} args - Arguments to find a DietaryTag
     * @example
     * // Get one DietaryTag
     * const dietaryTag = await prisma.dietaryTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DietaryTagFindUniqueArgs>(args: SelectSubset<T, DietaryTagFindUniqueArgs<ExtArgs>>): Prisma__DietaryTagClient<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DietaryTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DietaryTagFindUniqueOrThrowArgs} args - Arguments to find a DietaryTag
     * @example
     * // Get one DietaryTag
     * const dietaryTag = await prisma.dietaryTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DietaryTagFindUniqueOrThrowArgs>(args: SelectSubset<T, DietaryTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DietaryTagClient<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietaryTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryTagFindFirstArgs} args - Arguments to find a DietaryTag
     * @example
     * // Get one DietaryTag
     * const dietaryTag = await prisma.dietaryTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DietaryTagFindFirstArgs>(args?: SelectSubset<T, DietaryTagFindFirstArgs<ExtArgs>>): Prisma__DietaryTagClient<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DietaryTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryTagFindFirstOrThrowArgs} args - Arguments to find a DietaryTag
     * @example
     * // Get one DietaryTag
     * const dietaryTag = await prisma.dietaryTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DietaryTagFindFirstOrThrowArgs>(args?: SelectSubset<T, DietaryTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__DietaryTagClient<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DietaryTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DietaryTags
     * const dietaryTags = await prisma.dietaryTag.findMany()
     * 
     * // Get first 10 DietaryTags
     * const dietaryTags = await prisma.dietaryTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dietaryTagWithIdOnly = await prisma.dietaryTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DietaryTagFindManyArgs>(args?: SelectSubset<T, DietaryTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DietaryTag.
     * @param {DietaryTagCreateArgs} args - Arguments to create a DietaryTag.
     * @example
     * // Create one DietaryTag
     * const DietaryTag = await prisma.dietaryTag.create({
     *   data: {
     *     // ... data to create a DietaryTag
     *   }
     * })
     * 
     */
    create<T extends DietaryTagCreateArgs>(args: SelectSubset<T, DietaryTagCreateArgs<ExtArgs>>): Prisma__DietaryTagClient<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DietaryTags.
     * @param {DietaryTagCreateManyArgs} args - Arguments to create many DietaryTags.
     * @example
     * // Create many DietaryTags
     * const dietaryTag = await prisma.dietaryTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DietaryTagCreateManyArgs>(args?: SelectSubset<T, DietaryTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DietaryTags and returns the data saved in the database.
     * @param {DietaryTagCreateManyAndReturnArgs} args - Arguments to create many DietaryTags.
     * @example
     * // Create many DietaryTags
     * const dietaryTag = await prisma.dietaryTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DietaryTags and only return the `id`
     * const dietaryTagWithIdOnly = await prisma.dietaryTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DietaryTagCreateManyAndReturnArgs>(args?: SelectSubset<T, DietaryTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DietaryTag.
     * @param {DietaryTagDeleteArgs} args - Arguments to delete one DietaryTag.
     * @example
     * // Delete one DietaryTag
     * const DietaryTag = await prisma.dietaryTag.delete({
     *   where: {
     *     // ... filter to delete one DietaryTag
     *   }
     * })
     * 
     */
    delete<T extends DietaryTagDeleteArgs>(args: SelectSubset<T, DietaryTagDeleteArgs<ExtArgs>>): Prisma__DietaryTagClient<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DietaryTag.
     * @param {DietaryTagUpdateArgs} args - Arguments to update one DietaryTag.
     * @example
     * // Update one DietaryTag
     * const dietaryTag = await prisma.dietaryTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DietaryTagUpdateArgs>(args: SelectSubset<T, DietaryTagUpdateArgs<ExtArgs>>): Prisma__DietaryTagClient<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DietaryTags.
     * @param {DietaryTagDeleteManyArgs} args - Arguments to filter DietaryTags to delete.
     * @example
     * // Delete a few DietaryTags
     * const { count } = await prisma.dietaryTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DietaryTagDeleteManyArgs>(args?: SelectSubset<T, DietaryTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietaryTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DietaryTags
     * const dietaryTag = await prisma.dietaryTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DietaryTagUpdateManyArgs>(args: SelectSubset<T, DietaryTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DietaryTags and returns the data updated in the database.
     * @param {DietaryTagUpdateManyAndReturnArgs} args - Arguments to update many DietaryTags.
     * @example
     * // Update many DietaryTags
     * const dietaryTag = await prisma.dietaryTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DietaryTags and only return the `id`
     * const dietaryTagWithIdOnly = await prisma.dietaryTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DietaryTagUpdateManyAndReturnArgs>(args: SelectSubset<T, DietaryTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DietaryTag.
     * @param {DietaryTagUpsertArgs} args - Arguments to update or create a DietaryTag.
     * @example
     * // Update or create a DietaryTag
     * const dietaryTag = await prisma.dietaryTag.upsert({
     *   create: {
     *     // ... data to create a DietaryTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DietaryTag we want to update
     *   }
     * })
     */
    upsert<T extends DietaryTagUpsertArgs>(args: SelectSubset<T, DietaryTagUpsertArgs<ExtArgs>>): Prisma__DietaryTagClient<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DietaryTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryTagCountArgs} args - Arguments to filter DietaryTags to count.
     * @example
     * // Count the number of DietaryTags
     * const count = await prisma.dietaryTag.count({
     *   where: {
     *     // ... the filter for the DietaryTags we want to count
     *   }
     * })
    **/
    count<T extends DietaryTagCountArgs>(
      args?: Subset<T, DietaryTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DietaryTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DietaryTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DietaryTagAggregateArgs>(args: Subset<T, DietaryTagAggregateArgs>): Prisma.PrismaPromise<GetDietaryTagAggregateType<T>>

    /**
     * Group by DietaryTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DietaryTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DietaryTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DietaryTagGroupByArgs['orderBy'] }
        : { orderBy?: DietaryTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DietaryTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDietaryTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DietaryTag model
   */
  readonly fields: DietaryTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DietaryTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DietaryTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipes<T extends DietaryTag$recipesArgs<ExtArgs> = {}>(args?: Subset<T, DietaryTag$recipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DietaryTag model
   */
  interface DietaryTagFieldRefs {
    readonly id: FieldRef<"DietaryTag", 'String'>
    readonly name: FieldRef<"DietaryTag", 'String'>
    readonly description: FieldRef<"DietaryTag", 'String'>
    readonly category: FieldRef<"DietaryTag", 'DietaryCategory'>
  }
    

  // Custom InputTypes
  /**
   * DietaryTag findUnique
   */
  export type DietaryTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which DietaryTag to fetch.
     */
    where: DietaryTagWhereUniqueInput
  }

  /**
   * DietaryTag findUniqueOrThrow
   */
  export type DietaryTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which DietaryTag to fetch.
     */
    where: DietaryTagWhereUniqueInput
  }

  /**
   * DietaryTag findFirst
   */
  export type DietaryTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which DietaryTag to fetch.
     */
    where?: DietaryTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietaryTags to fetch.
     */
    orderBy?: DietaryTagOrderByWithRelationInput | DietaryTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietaryTags.
     */
    cursor?: DietaryTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietaryTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietaryTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietaryTags.
     */
    distinct?: DietaryTagScalarFieldEnum | DietaryTagScalarFieldEnum[]
  }

  /**
   * DietaryTag findFirstOrThrow
   */
  export type DietaryTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which DietaryTag to fetch.
     */
    where?: DietaryTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietaryTags to fetch.
     */
    orderBy?: DietaryTagOrderByWithRelationInput | DietaryTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DietaryTags.
     */
    cursor?: DietaryTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietaryTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietaryTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DietaryTags.
     */
    distinct?: DietaryTagScalarFieldEnum | DietaryTagScalarFieldEnum[]
  }

  /**
   * DietaryTag findMany
   */
  export type DietaryTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which DietaryTags to fetch.
     */
    where?: DietaryTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DietaryTags to fetch.
     */
    orderBy?: DietaryTagOrderByWithRelationInput | DietaryTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DietaryTags.
     */
    cursor?: DietaryTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DietaryTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DietaryTags.
     */
    skip?: number
    distinct?: DietaryTagScalarFieldEnum | DietaryTagScalarFieldEnum[]
  }

  /**
   * DietaryTag create
   */
  export type DietaryTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DietaryTag.
     */
    data: XOR<DietaryTagCreateInput, DietaryTagUncheckedCreateInput>
  }

  /**
   * DietaryTag createMany
   */
  export type DietaryTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DietaryTags.
     */
    data: DietaryTagCreateManyInput | DietaryTagCreateManyInput[]
  }

  /**
   * DietaryTag createManyAndReturn
   */
  export type DietaryTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * The data used to create many DietaryTags.
     */
    data: DietaryTagCreateManyInput | DietaryTagCreateManyInput[]
  }

  /**
   * DietaryTag update
   */
  export type DietaryTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DietaryTag.
     */
    data: XOR<DietaryTagUpdateInput, DietaryTagUncheckedUpdateInput>
    /**
     * Choose, which DietaryTag to update.
     */
    where: DietaryTagWhereUniqueInput
  }

  /**
   * DietaryTag updateMany
   */
  export type DietaryTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DietaryTags.
     */
    data: XOR<DietaryTagUpdateManyMutationInput, DietaryTagUncheckedUpdateManyInput>
    /**
     * Filter which DietaryTags to update
     */
    where?: DietaryTagWhereInput
    /**
     * Limit how many DietaryTags to update.
     */
    limit?: number
  }

  /**
   * DietaryTag updateManyAndReturn
   */
  export type DietaryTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * The data used to update DietaryTags.
     */
    data: XOR<DietaryTagUpdateManyMutationInput, DietaryTagUncheckedUpdateManyInput>
    /**
     * Filter which DietaryTags to update
     */
    where?: DietaryTagWhereInput
    /**
     * Limit how many DietaryTags to update.
     */
    limit?: number
  }

  /**
   * DietaryTag upsert
   */
  export type DietaryTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DietaryTag to update in case it exists.
     */
    where: DietaryTagWhereUniqueInput
    /**
     * In case the DietaryTag found by the `where` argument doesn't exist, create a new DietaryTag with this data.
     */
    create: XOR<DietaryTagCreateInput, DietaryTagUncheckedCreateInput>
    /**
     * In case the DietaryTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DietaryTagUpdateInput, DietaryTagUncheckedUpdateInput>
  }

  /**
   * DietaryTag delete
   */
  export type DietaryTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
    /**
     * Filter which DietaryTag to delete.
     */
    where: DietaryTagWhereUniqueInput
  }

  /**
   * DietaryTag deleteMany
   */
  export type DietaryTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DietaryTags to delete
     */
    where?: DietaryTagWhereInput
    /**
     * Limit how many DietaryTags to delete.
     */
    limit?: number
  }

  /**
   * DietaryTag.recipes
   */
  export type DietaryTag$recipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    where?: RecipeDietaryTagWhereInput
    orderBy?: RecipeDietaryTagOrderByWithRelationInput | RecipeDietaryTagOrderByWithRelationInput[]
    cursor?: RecipeDietaryTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeDietaryTagScalarFieldEnum | RecipeDietaryTagScalarFieldEnum[]
  }

  /**
   * DietaryTag without action
   */
  export type DietaryTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DietaryTag
     */
    select?: DietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DietaryTag
     */
    omit?: DietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DietaryTagInclude<ExtArgs> | null
  }


  /**
   * Model RecipeDietaryTag
   */

  export type AggregateRecipeDietaryTag = {
    _count: RecipeDietaryTagCountAggregateOutputType | null
    _min: RecipeDietaryTagMinAggregateOutputType | null
    _max: RecipeDietaryTagMaxAggregateOutputType | null
  }

  export type RecipeDietaryTagMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    dietaryTagId: string | null
  }

  export type RecipeDietaryTagMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    dietaryTagId: string | null
  }

  export type RecipeDietaryTagCountAggregateOutputType = {
    id: number
    recipeId: number
    dietaryTagId: number
    _all: number
  }


  export type RecipeDietaryTagMinAggregateInputType = {
    id?: true
    recipeId?: true
    dietaryTagId?: true
  }

  export type RecipeDietaryTagMaxAggregateInputType = {
    id?: true
    recipeId?: true
    dietaryTagId?: true
  }

  export type RecipeDietaryTagCountAggregateInputType = {
    id?: true
    recipeId?: true
    dietaryTagId?: true
    _all?: true
  }

  export type RecipeDietaryTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeDietaryTag to aggregate.
     */
    where?: RecipeDietaryTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeDietaryTags to fetch.
     */
    orderBy?: RecipeDietaryTagOrderByWithRelationInput | RecipeDietaryTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeDietaryTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeDietaryTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeDietaryTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeDietaryTags
    **/
    _count?: true | RecipeDietaryTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeDietaryTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeDietaryTagMaxAggregateInputType
  }

  export type GetRecipeDietaryTagAggregateType<T extends RecipeDietaryTagAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeDietaryTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeDietaryTag[P]>
      : GetScalarType<T[P], AggregateRecipeDietaryTag[P]>
  }




  export type RecipeDietaryTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeDietaryTagWhereInput
    orderBy?: RecipeDietaryTagOrderByWithAggregationInput | RecipeDietaryTagOrderByWithAggregationInput[]
    by: RecipeDietaryTagScalarFieldEnum[] | RecipeDietaryTagScalarFieldEnum
    having?: RecipeDietaryTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeDietaryTagCountAggregateInputType | true
    _min?: RecipeDietaryTagMinAggregateInputType
    _max?: RecipeDietaryTagMaxAggregateInputType
  }

  export type RecipeDietaryTagGroupByOutputType = {
    id: string
    recipeId: string
    dietaryTagId: string
    _count: RecipeDietaryTagCountAggregateOutputType | null
    _min: RecipeDietaryTagMinAggregateOutputType | null
    _max: RecipeDietaryTagMaxAggregateOutputType | null
  }

  type GetRecipeDietaryTagGroupByPayload<T extends RecipeDietaryTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeDietaryTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeDietaryTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeDietaryTagGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeDietaryTagGroupByOutputType[P]>
        }
      >
    >


  export type RecipeDietaryTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    dietaryTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    dietaryTag?: boolean | DietaryTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeDietaryTag"]>

  export type RecipeDietaryTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    dietaryTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    dietaryTag?: boolean | DietaryTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeDietaryTag"]>

  export type RecipeDietaryTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    dietaryTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    dietaryTag?: boolean | DietaryTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeDietaryTag"]>

  export type RecipeDietaryTagSelectScalar = {
    id?: boolean
    recipeId?: boolean
    dietaryTagId?: boolean
  }

  export type RecipeDietaryTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "dietaryTagId", ExtArgs["result"]["recipeDietaryTag"]>
  export type RecipeDietaryTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    dietaryTag?: boolean | DietaryTagDefaultArgs<ExtArgs>
  }
  export type RecipeDietaryTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    dietaryTag?: boolean | DietaryTagDefaultArgs<ExtArgs>
  }
  export type RecipeDietaryTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    dietaryTag?: boolean | DietaryTagDefaultArgs<ExtArgs>
  }

  export type $RecipeDietaryTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeDietaryTag"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      dietaryTag: Prisma.$DietaryTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      dietaryTagId: string
    }, ExtArgs["result"]["recipeDietaryTag"]>
    composites: {}
  }

  type RecipeDietaryTagGetPayload<S extends boolean | null | undefined | RecipeDietaryTagDefaultArgs> = $Result.GetResult<Prisma.$RecipeDietaryTagPayload, S>

  type RecipeDietaryTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeDietaryTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeDietaryTagCountAggregateInputType | true
    }

  export interface RecipeDietaryTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeDietaryTag'], meta: { name: 'RecipeDietaryTag' } }
    /**
     * Find zero or one RecipeDietaryTag that matches the filter.
     * @param {RecipeDietaryTagFindUniqueArgs} args - Arguments to find a RecipeDietaryTag
     * @example
     * // Get one RecipeDietaryTag
     * const recipeDietaryTag = await prisma.recipeDietaryTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeDietaryTagFindUniqueArgs>(args: SelectSubset<T, RecipeDietaryTagFindUniqueArgs<ExtArgs>>): Prisma__RecipeDietaryTagClient<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeDietaryTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeDietaryTagFindUniqueOrThrowArgs} args - Arguments to find a RecipeDietaryTag
     * @example
     * // Get one RecipeDietaryTag
     * const recipeDietaryTag = await prisma.recipeDietaryTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeDietaryTagFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeDietaryTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeDietaryTagClient<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeDietaryTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeDietaryTagFindFirstArgs} args - Arguments to find a RecipeDietaryTag
     * @example
     * // Get one RecipeDietaryTag
     * const recipeDietaryTag = await prisma.recipeDietaryTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeDietaryTagFindFirstArgs>(args?: SelectSubset<T, RecipeDietaryTagFindFirstArgs<ExtArgs>>): Prisma__RecipeDietaryTagClient<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeDietaryTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeDietaryTagFindFirstOrThrowArgs} args - Arguments to find a RecipeDietaryTag
     * @example
     * // Get one RecipeDietaryTag
     * const recipeDietaryTag = await prisma.recipeDietaryTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeDietaryTagFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeDietaryTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeDietaryTagClient<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeDietaryTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeDietaryTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeDietaryTags
     * const recipeDietaryTags = await prisma.recipeDietaryTag.findMany()
     * 
     * // Get first 10 RecipeDietaryTags
     * const recipeDietaryTags = await prisma.recipeDietaryTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeDietaryTagWithIdOnly = await prisma.recipeDietaryTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeDietaryTagFindManyArgs>(args?: SelectSubset<T, RecipeDietaryTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeDietaryTag.
     * @param {RecipeDietaryTagCreateArgs} args - Arguments to create a RecipeDietaryTag.
     * @example
     * // Create one RecipeDietaryTag
     * const RecipeDietaryTag = await prisma.recipeDietaryTag.create({
     *   data: {
     *     // ... data to create a RecipeDietaryTag
     *   }
     * })
     * 
     */
    create<T extends RecipeDietaryTagCreateArgs>(args: SelectSubset<T, RecipeDietaryTagCreateArgs<ExtArgs>>): Prisma__RecipeDietaryTagClient<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeDietaryTags.
     * @param {RecipeDietaryTagCreateManyArgs} args - Arguments to create many RecipeDietaryTags.
     * @example
     * // Create many RecipeDietaryTags
     * const recipeDietaryTag = await prisma.recipeDietaryTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeDietaryTagCreateManyArgs>(args?: SelectSubset<T, RecipeDietaryTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeDietaryTags and returns the data saved in the database.
     * @param {RecipeDietaryTagCreateManyAndReturnArgs} args - Arguments to create many RecipeDietaryTags.
     * @example
     * // Create many RecipeDietaryTags
     * const recipeDietaryTag = await prisma.recipeDietaryTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeDietaryTags and only return the `id`
     * const recipeDietaryTagWithIdOnly = await prisma.recipeDietaryTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeDietaryTagCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeDietaryTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeDietaryTag.
     * @param {RecipeDietaryTagDeleteArgs} args - Arguments to delete one RecipeDietaryTag.
     * @example
     * // Delete one RecipeDietaryTag
     * const RecipeDietaryTag = await prisma.recipeDietaryTag.delete({
     *   where: {
     *     // ... filter to delete one RecipeDietaryTag
     *   }
     * })
     * 
     */
    delete<T extends RecipeDietaryTagDeleteArgs>(args: SelectSubset<T, RecipeDietaryTagDeleteArgs<ExtArgs>>): Prisma__RecipeDietaryTagClient<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeDietaryTag.
     * @param {RecipeDietaryTagUpdateArgs} args - Arguments to update one RecipeDietaryTag.
     * @example
     * // Update one RecipeDietaryTag
     * const recipeDietaryTag = await prisma.recipeDietaryTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeDietaryTagUpdateArgs>(args: SelectSubset<T, RecipeDietaryTagUpdateArgs<ExtArgs>>): Prisma__RecipeDietaryTagClient<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeDietaryTags.
     * @param {RecipeDietaryTagDeleteManyArgs} args - Arguments to filter RecipeDietaryTags to delete.
     * @example
     * // Delete a few RecipeDietaryTags
     * const { count } = await prisma.recipeDietaryTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDietaryTagDeleteManyArgs>(args?: SelectSubset<T, RecipeDietaryTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeDietaryTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeDietaryTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeDietaryTags
     * const recipeDietaryTag = await prisma.recipeDietaryTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeDietaryTagUpdateManyArgs>(args: SelectSubset<T, RecipeDietaryTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeDietaryTags and returns the data updated in the database.
     * @param {RecipeDietaryTagUpdateManyAndReturnArgs} args - Arguments to update many RecipeDietaryTags.
     * @example
     * // Update many RecipeDietaryTags
     * const recipeDietaryTag = await prisma.recipeDietaryTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeDietaryTags and only return the `id`
     * const recipeDietaryTagWithIdOnly = await prisma.recipeDietaryTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeDietaryTagUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeDietaryTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeDietaryTag.
     * @param {RecipeDietaryTagUpsertArgs} args - Arguments to update or create a RecipeDietaryTag.
     * @example
     * // Update or create a RecipeDietaryTag
     * const recipeDietaryTag = await prisma.recipeDietaryTag.upsert({
     *   create: {
     *     // ... data to create a RecipeDietaryTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeDietaryTag we want to update
     *   }
     * })
     */
    upsert<T extends RecipeDietaryTagUpsertArgs>(args: SelectSubset<T, RecipeDietaryTagUpsertArgs<ExtArgs>>): Prisma__RecipeDietaryTagClient<$Result.GetResult<Prisma.$RecipeDietaryTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeDietaryTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeDietaryTagCountArgs} args - Arguments to filter RecipeDietaryTags to count.
     * @example
     * // Count the number of RecipeDietaryTags
     * const count = await prisma.recipeDietaryTag.count({
     *   where: {
     *     // ... the filter for the RecipeDietaryTags we want to count
     *   }
     * })
    **/
    count<T extends RecipeDietaryTagCountArgs>(
      args?: Subset<T, RecipeDietaryTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeDietaryTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeDietaryTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeDietaryTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeDietaryTagAggregateArgs>(args: Subset<T, RecipeDietaryTagAggregateArgs>): Prisma.PrismaPromise<GetRecipeDietaryTagAggregateType<T>>

    /**
     * Group by RecipeDietaryTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeDietaryTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeDietaryTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeDietaryTagGroupByArgs['orderBy'] }
        : { orderBy?: RecipeDietaryTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeDietaryTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeDietaryTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeDietaryTag model
   */
  readonly fields: RecipeDietaryTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeDietaryTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeDietaryTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dietaryTag<T extends DietaryTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DietaryTagDefaultArgs<ExtArgs>>): Prisma__DietaryTagClient<$Result.GetResult<Prisma.$DietaryTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeDietaryTag model
   */
  interface RecipeDietaryTagFieldRefs {
    readonly id: FieldRef<"RecipeDietaryTag", 'String'>
    readonly recipeId: FieldRef<"RecipeDietaryTag", 'String'>
    readonly dietaryTagId: FieldRef<"RecipeDietaryTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecipeDietaryTag findUnique
   */
  export type RecipeDietaryTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeDietaryTag to fetch.
     */
    where: RecipeDietaryTagWhereUniqueInput
  }

  /**
   * RecipeDietaryTag findUniqueOrThrow
   */
  export type RecipeDietaryTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeDietaryTag to fetch.
     */
    where: RecipeDietaryTagWhereUniqueInput
  }

  /**
   * RecipeDietaryTag findFirst
   */
  export type RecipeDietaryTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeDietaryTag to fetch.
     */
    where?: RecipeDietaryTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeDietaryTags to fetch.
     */
    orderBy?: RecipeDietaryTagOrderByWithRelationInput | RecipeDietaryTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeDietaryTags.
     */
    cursor?: RecipeDietaryTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeDietaryTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeDietaryTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeDietaryTags.
     */
    distinct?: RecipeDietaryTagScalarFieldEnum | RecipeDietaryTagScalarFieldEnum[]
  }

  /**
   * RecipeDietaryTag findFirstOrThrow
   */
  export type RecipeDietaryTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeDietaryTag to fetch.
     */
    where?: RecipeDietaryTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeDietaryTags to fetch.
     */
    orderBy?: RecipeDietaryTagOrderByWithRelationInput | RecipeDietaryTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeDietaryTags.
     */
    cursor?: RecipeDietaryTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeDietaryTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeDietaryTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeDietaryTags.
     */
    distinct?: RecipeDietaryTagScalarFieldEnum | RecipeDietaryTagScalarFieldEnum[]
  }

  /**
   * RecipeDietaryTag findMany
   */
  export type RecipeDietaryTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeDietaryTags to fetch.
     */
    where?: RecipeDietaryTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeDietaryTags to fetch.
     */
    orderBy?: RecipeDietaryTagOrderByWithRelationInput | RecipeDietaryTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeDietaryTags.
     */
    cursor?: RecipeDietaryTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeDietaryTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeDietaryTags.
     */
    skip?: number
    distinct?: RecipeDietaryTagScalarFieldEnum | RecipeDietaryTagScalarFieldEnum[]
  }

  /**
   * RecipeDietaryTag create
   */
  export type RecipeDietaryTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeDietaryTag.
     */
    data: XOR<RecipeDietaryTagCreateInput, RecipeDietaryTagUncheckedCreateInput>
  }

  /**
   * RecipeDietaryTag createMany
   */
  export type RecipeDietaryTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeDietaryTags.
     */
    data: RecipeDietaryTagCreateManyInput | RecipeDietaryTagCreateManyInput[]
  }

  /**
   * RecipeDietaryTag createManyAndReturn
   */
  export type RecipeDietaryTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeDietaryTags.
     */
    data: RecipeDietaryTagCreateManyInput | RecipeDietaryTagCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeDietaryTag update
   */
  export type RecipeDietaryTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeDietaryTag.
     */
    data: XOR<RecipeDietaryTagUpdateInput, RecipeDietaryTagUncheckedUpdateInput>
    /**
     * Choose, which RecipeDietaryTag to update.
     */
    where: RecipeDietaryTagWhereUniqueInput
  }

  /**
   * RecipeDietaryTag updateMany
   */
  export type RecipeDietaryTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeDietaryTags.
     */
    data: XOR<RecipeDietaryTagUpdateManyMutationInput, RecipeDietaryTagUncheckedUpdateManyInput>
    /**
     * Filter which RecipeDietaryTags to update
     */
    where?: RecipeDietaryTagWhereInput
    /**
     * Limit how many RecipeDietaryTags to update.
     */
    limit?: number
  }

  /**
   * RecipeDietaryTag updateManyAndReturn
   */
  export type RecipeDietaryTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * The data used to update RecipeDietaryTags.
     */
    data: XOR<RecipeDietaryTagUpdateManyMutationInput, RecipeDietaryTagUncheckedUpdateManyInput>
    /**
     * Filter which RecipeDietaryTags to update
     */
    where?: RecipeDietaryTagWhereInput
    /**
     * Limit how many RecipeDietaryTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeDietaryTag upsert
   */
  export type RecipeDietaryTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeDietaryTag to update in case it exists.
     */
    where: RecipeDietaryTagWhereUniqueInput
    /**
     * In case the RecipeDietaryTag found by the `where` argument doesn't exist, create a new RecipeDietaryTag with this data.
     */
    create: XOR<RecipeDietaryTagCreateInput, RecipeDietaryTagUncheckedCreateInput>
    /**
     * In case the RecipeDietaryTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeDietaryTagUpdateInput, RecipeDietaryTagUncheckedUpdateInput>
  }

  /**
   * RecipeDietaryTag delete
   */
  export type RecipeDietaryTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
    /**
     * Filter which RecipeDietaryTag to delete.
     */
    where: RecipeDietaryTagWhereUniqueInput
  }

  /**
   * RecipeDietaryTag deleteMany
   */
  export type RecipeDietaryTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeDietaryTags to delete
     */
    where?: RecipeDietaryTagWhereInput
    /**
     * Limit how many RecipeDietaryTags to delete.
     */
    limit?: number
  }

  /**
   * RecipeDietaryTag without action
   */
  export type RecipeDietaryTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeDietaryTag
     */
    select?: RecipeDietaryTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeDietaryTag
     */
    omit?: RecipeDietaryTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeDietaryTagInclude<ExtArgs> | null
  }


  /**
   * Model PracticalTag
   */

  export type AggregatePracticalTag = {
    _count: PracticalTagCountAggregateOutputType | null
    _min: PracticalTagMinAggregateOutputType | null
    _max: PracticalTagMaxAggregateOutputType | null
  }

  export type PracticalTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.PracticalCategory | null
  }

  export type PracticalTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.PracticalCategory | null
  }

  export type PracticalTagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    _all: number
  }


  export type PracticalTagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type PracticalTagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type PracticalTagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    _all?: true
  }

  export type PracticalTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticalTag to aggregate.
     */
    where?: PracticalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticalTags to fetch.
     */
    orderBy?: PracticalTagOrderByWithRelationInput | PracticalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PracticalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PracticalTags
    **/
    _count?: true | PracticalTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PracticalTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PracticalTagMaxAggregateInputType
  }

  export type GetPracticalTagAggregateType<T extends PracticalTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePracticalTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePracticalTag[P]>
      : GetScalarType<T[P], AggregatePracticalTag[P]>
  }




  export type PracticalTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PracticalTagWhereInput
    orderBy?: PracticalTagOrderByWithAggregationInput | PracticalTagOrderByWithAggregationInput[]
    by: PracticalTagScalarFieldEnum[] | PracticalTagScalarFieldEnum
    having?: PracticalTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PracticalTagCountAggregateInputType | true
    _min?: PracticalTagMinAggregateInputType
    _max?: PracticalTagMaxAggregateInputType
  }

  export type PracticalTagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: $Enums.PracticalCategory
    _count: PracticalTagCountAggregateOutputType | null
    _min: PracticalTagMinAggregateOutputType | null
    _max: PracticalTagMaxAggregateOutputType | null
  }

  type GetPracticalTagGroupByPayload<T extends PracticalTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PracticalTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PracticalTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PracticalTagGroupByOutputType[P]>
            : GetScalarType<T[P], PracticalTagGroupByOutputType[P]>
        }
      >
    >


  export type PracticalTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    recipes?: boolean | PracticalTag$recipesArgs<ExtArgs>
    _count?: boolean | PracticalTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["practicalTag"]>

  export type PracticalTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["practicalTag"]>

  export type PracticalTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["practicalTag"]>

  export type PracticalTagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }

  export type PracticalTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category", ExtArgs["result"]["practicalTag"]>
  export type PracticalTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | PracticalTag$recipesArgs<ExtArgs>
    _count?: boolean | PracticalTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PracticalTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PracticalTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PracticalTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PracticalTag"
    objects: {
      recipes: Prisma.$RecipePracticalTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: $Enums.PracticalCategory
    }, ExtArgs["result"]["practicalTag"]>
    composites: {}
  }

  type PracticalTagGetPayload<S extends boolean | null | undefined | PracticalTagDefaultArgs> = $Result.GetResult<Prisma.$PracticalTagPayload, S>

  type PracticalTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PracticalTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PracticalTagCountAggregateInputType | true
    }

  export interface PracticalTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PracticalTag'], meta: { name: 'PracticalTag' } }
    /**
     * Find zero or one PracticalTag that matches the filter.
     * @param {PracticalTagFindUniqueArgs} args - Arguments to find a PracticalTag
     * @example
     * // Get one PracticalTag
     * const practicalTag = await prisma.practicalTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PracticalTagFindUniqueArgs>(args: SelectSubset<T, PracticalTagFindUniqueArgs<ExtArgs>>): Prisma__PracticalTagClient<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PracticalTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PracticalTagFindUniqueOrThrowArgs} args - Arguments to find a PracticalTag
     * @example
     * // Get one PracticalTag
     * const practicalTag = await prisma.practicalTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PracticalTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PracticalTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PracticalTagClient<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PracticalTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticalTagFindFirstArgs} args - Arguments to find a PracticalTag
     * @example
     * // Get one PracticalTag
     * const practicalTag = await prisma.practicalTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PracticalTagFindFirstArgs>(args?: SelectSubset<T, PracticalTagFindFirstArgs<ExtArgs>>): Prisma__PracticalTagClient<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PracticalTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticalTagFindFirstOrThrowArgs} args - Arguments to find a PracticalTag
     * @example
     * // Get one PracticalTag
     * const practicalTag = await prisma.practicalTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PracticalTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PracticalTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PracticalTagClient<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PracticalTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticalTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PracticalTags
     * const practicalTags = await prisma.practicalTag.findMany()
     * 
     * // Get first 10 PracticalTags
     * const practicalTags = await prisma.practicalTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const practicalTagWithIdOnly = await prisma.practicalTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PracticalTagFindManyArgs>(args?: SelectSubset<T, PracticalTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PracticalTag.
     * @param {PracticalTagCreateArgs} args - Arguments to create a PracticalTag.
     * @example
     * // Create one PracticalTag
     * const PracticalTag = await prisma.practicalTag.create({
     *   data: {
     *     // ... data to create a PracticalTag
     *   }
     * })
     * 
     */
    create<T extends PracticalTagCreateArgs>(args: SelectSubset<T, PracticalTagCreateArgs<ExtArgs>>): Prisma__PracticalTagClient<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PracticalTags.
     * @param {PracticalTagCreateManyArgs} args - Arguments to create many PracticalTags.
     * @example
     * // Create many PracticalTags
     * const practicalTag = await prisma.practicalTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PracticalTagCreateManyArgs>(args?: SelectSubset<T, PracticalTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PracticalTags and returns the data saved in the database.
     * @param {PracticalTagCreateManyAndReturnArgs} args - Arguments to create many PracticalTags.
     * @example
     * // Create many PracticalTags
     * const practicalTag = await prisma.practicalTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PracticalTags and only return the `id`
     * const practicalTagWithIdOnly = await prisma.practicalTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PracticalTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PracticalTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PracticalTag.
     * @param {PracticalTagDeleteArgs} args - Arguments to delete one PracticalTag.
     * @example
     * // Delete one PracticalTag
     * const PracticalTag = await prisma.practicalTag.delete({
     *   where: {
     *     // ... filter to delete one PracticalTag
     *   }
     * })
     * 
     */
    delete<T extends PracticalTagDeleteArgs>(args: SelectSubset<T, PracticalTagDeleteArgs<ExtArgs>>): Prisma__PracticalTagClient<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PracticalTag.
     * @param {PracticalTagUpdateArgs} args - Arguments to update one PracticalTag.
     * @example
     * // Update one PracticalTag
     * const practicalTag = await prisma.practicalTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PracticalTagUpdateArgs>(args: SelectSubset<T, PracticalTagUpdateArgs<ExtArgs>>): Prisma__PracticalTagClient<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PracticalTags.
     * @param {PracticalTagDeleteManyArgs} args - Arguments to filter PracticalTags to delete.
     * @example
     * // Delete a few PracticalTags
     * const { count } = await prisma.practicalTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PracticalTagDeleteManyArgs>(args?: SelectSubset<T, PracticalTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PracticalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticalTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PracticalTags
     * const practicalTag = await prisma.practicalTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PracticalTagUpdateManyArgs>(args: SelectSubset<T, PracticalTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PracticalTags and returns the data updated in the database.
     * @param {PracticalTagUpdateManyAndReturnArgs} args - Arguments to update many PracticalTags.
     * @example
     * // Update many PracticalTags
     * const practicalTag = await prisma.practicalTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PracticalTags and only return the `id`
     * const practicalTagWithIdOnly = await prisma.practicalTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PracticalTagUpdateManyAndReturnArgs>(args: SelectSubset<T, PracticalTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PracticalTag.
     * @param {PracticalTagUpsertArgs} args - Arguments to update or create a PracticalTag.
     * @example
     * // Update or create a PracticalTag
     * const practicalTag = await prisma.practicalTag.upsert({
     *   create: {
     *     // ... data to create a PracticalTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PracticalTag we want to update
     *   }
     * })
     */
    upsert<T extends PracticalTagUpsertArgs>(args: SelectSubset<T, PracticalTagUpsertArgs<ExtArgs>>): Prisma__PracticalTagClient<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PracticalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticalTagCountArgs} args - Arguments to filter PracticalTags to count.
     * @example
     * // Count the number of PracticalTags
     * const count = await prisma.practicalTag.count({
     *   where: {
     *     // ... the filter for the PracticalTags we want to count
     *   }
     * })
    **/
    count<T extends PracticalTagCountArgs>(
      args?: Subset<T, PracticalTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PracticalTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PracticalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticalTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PracticalTagAggregateArgs>(args: Subset<T, PracticalTagAggregateArgs>): Prisma.PrismaPromise<GetPracticalTagAggregateType<T>>

    /**
     * Group by PracticalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PracticalTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PracticalTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PracticalTagGroupByArgs['orderBy'] }
        : { orderBy?: PracticalTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PracticalTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPracticalTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PracticalTag model
   */
  readonly fields: PracticalTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PracticalTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PracticalTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipes<T extends PracticalTag$recipesArgs<ExtArgs> = {}>(args?: Subset<T, PracticalTag$recipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PracticalTag model
   */
  interface PracticalTagFieldRefs {
    readonly id: FieldRef<"PracticalTag", 'String'>
    readonly name: FieldRef<"PracticalTag", 'String'>
    readonly description: FieldRef<"PracticalTag", 'String'>
    readonly category: FieldRef<"PracticalTag", 'PracticalCategory'>
  }
    

  // Custom InputTypes
  /**
   * PracticalTag findUnique
   */
  export type PracticalTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which PracticalTag to fetch.
     */
    where: PracticalTagWhereUniqueInput
  }

  /**
   * PracticalTag findUniqueOrThrow
   */
  export type PracticalTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which PracticalTag to fetch.
     */
    where: PracticalTagWhereUniqueInput
  }

  /**
   * PracticalTag findFirst
   */
  export type PracticalTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which PracticalTag to fetch.
     */
    where?: PracticalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticalTags to fetch.
     */
    orderBy?: PracticalTagOrderByWithRelationInput | PracticalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticalTags.
     */
    cursor?: PracticalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticalTags.
     */
    distinct?: PracticalTagScalarFieldEnum | PracticalTagScalarFieldEnum[]
  }

  /**
   * PracticalTag findFirstOrThrow
   */
  export type PracticalTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which PracticalTag to fetch.
     */
    where?: PracticalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticalTags to fetch.
     */
    orderBy?: PracticalTagOrderByWithRelationInput | PracticalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PracticalTags.
     */
    cursor?: PracticalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PracticalTags.
     */
    distinct?: PracticalTagScalarFieldEnum | PracticalTagScalarFieldEnum[]
  }

  /**
   * PracticalTag findMany
   */
  export type PracticalTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which PracticalTags to fetch.
     */
    where?: PracticalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PracticalTags to fetch.
     */
    orderBy?: PracticalTagOrderByWithRelationInput | PracticalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PracticalTags.
     */
    cursor?: PracticalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PracticalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PracticalTags.
     */
    skip?: number
    distinct?: PracticalTagScalarFieldEnum | PracticalTagScalarFieldEnum[]
  }

  /**
   * PracticalTag create
   */
  export type PracticalTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PracticalTag.
     */
    data: XOR<PracticalTagCreateInput, PracticalTagUncheckedCreateInput>
  }

  /**
   * PracticalTag createMany
   */
  export type PracticalTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PracticalTags.
     */
    data: PracticalTagCreateManyInput | PracticalTagCreateManyInput[]
  }

  /**
   * PracticalTag createManyAndReturn
   */
  export type PracticalTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * The data used to create many PracticalTags.
     */
    data: PracticalTagCreateManyInput | PracticalTagCreateManyInput[]
  }

  /**
   * PracticalTag update
   */
  export type PracticalTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PracticalTag.
     */
    data: XOR<PracticalTagUpdateInput, PracticalTagUncheckedUpdateInput>
    /**
     * Choose, which PracticalTag to update.
     */
    where: PracticalTagWhereUniqueInput
  }

  /**
   * PracticalTag updateMany
   */
  export type PracticalTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PracticalTags.
     */
    data: XOR<PracticalTagUpdateManyMutationInput, PracticalTagUncheckedUpdateManyInput>
    /**
     * Filter which PracticalTags to update
     */
    where?: PracticalTagWhereInput
    /**
     * Limit how many PracticalTags to update.
     */
    limit?: number
  }

  /**
   * PracticalTag updateManyAndReturn
   */
  export type PracticalTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * The data used to update PracticalTags.
     */
    data: XOR<PracticalTagUpdateManyMutationInput, PracticalTagUncheckedUpdateManyInput>
    /**
     * Filter which PracticalTags to update
     */
    where?: PracticalTagWhereInput
    /**
     * Limit how many PracticalTags to update.
     */
    limit?: number
  }

  /**
   * PracticalTag upsert
   */
  export type PracticalTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PracticalTag to update in case it exists.
     */
    where: PracticalTagWhereUniqueInput
    /**
     * In case the PracticalTag found by the `where` argument doesn't exist, create a new PracticalTag with this data.
     */
    create: XOR<PracticalTagCreateInput, PracticalTagUncheckedCreateInput>
    /**
     * In case the PracticalTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PracticalTagUpdateInput, PracticalTagUncheckedUpdateInput>
  }

  /**
   * PracticalTag delete
   */
  export type PracticalTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
    /**
     * Filter which PracticalTag to delete.
     */
    where: PracticalTagWhereUniqueInput
  }

  /**
   * PracticalTag deleteMany
   */
  export type PracticalTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PracticalTags to delete
     */
    where?: PracticalTagWhereInput
    /**
     * Limit how many PracticalTags to delete.
     */
    limit?: number
  }

  /**
   * PracticalTag.recipes
   */
  export type PracticalTag$recipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    where?: RecipePracticalTagWhereInput
    orderBy?: RecipePracticalTagOrderByWithRelationInput | RecipePracticalTagOrderByWithRelationInput[]
    cursor?: RecipePracticalTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipePracticalTagScalarFieldEnum | RecipePracticalTagScalarFieldEnum[]
  }

  /**
   * PracticalTag without action
   */
  export type PracticalTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PracticalTag
     */
    select?: PracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PracticalTag
     */
    omit?: PracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PracticalTagInclude<ExtArgs> | null
  }


  /**
   * Model RecipePracticalTag
   */

  export type AggregateRecipePracticalTag = {
    _count: RecipePracticalTagCountAggregateOutputType | null
    _min: RecipePracticalTagMinAggregateOutputType | null
    _max: RecipePracticalTagMaxAggregateOutputType | null
  }

  export type RecipePracticalTagMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    practicalTagId: string | null
  }

  export type RecipePracticalTagMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    practicalTagId: string | null
  }

  export type RecipePracticalTagCountAggregateOutputType = {
    id: number
    recipeId: number
    practicalTagId: number
    _all: number
  }


  export type RecipePracticalTagMinAggregateInputType = {
    id?: true
    recipeId?: true
    practicalTagId?: true
  }

  export type RecipePracticalTagMaxAggregateInputType = {
    id?: true
    recipeId?: true
    practicalTagId?: true
  }

  export type RecipePracticalTagCountAggregateInputType = {
    id?: true
    recipeId?: true
    practicalTagId?: true
    _all?: true
  }

  export type RecipePracticalTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipePracticalTag to aggregate.
     */
    where?: RecipePracticalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipePracticalTags to fetch.
     */
    orderBy?: RecipePracticalTagOrderByWithRelationInput | RecipePracticalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipePracticalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipePracticalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipePracticalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipePracticalTags
    **/
    _count?: true | RecipePracticalTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipePracticalTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipePracticalTagMaxAggregateInputType
  }

  export type GetRecipePracticalTagAggregateType<T extends RecipePracticalTagAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipePracticalTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipePracticalTag[P]>
      : GetScalarType<T[P], AggregateRecipePracticalTag[P]>
  }




  export type RecipePracticalTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipePracticalTagWhereInput
    orderBy?: RecipePracticalTagOrderByWithAggregationInput | RecipePracticalTagOrderByWithAggregationInput[]
    by: RecipePracticalTagScalarFieldEnum[] | RecipePracticalTagScalarFieldEnum
    having?: RecipePracticalTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipePracticalTagCountAggregateInputType | true
    _min?: RecipePracticalTagMinAggregateInputType
    _max?: RecipePracticalTagMaxAggregateInputType
  }

  export type RecipePracticalTagGroupByOutputType = {
    id: string
    recipeId: string
    practicalTagId: string
    _count: RecipePracticalTagCountAggregateOutputType | null
    _min: RecipePracticalTagMinAggregateOutputType | null
    _max: RecipePracticalTagMaxAggregateOutputType | null
  }

  type GetRecipePracticalTagGroupByPayload<T extends RecipePracticalTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipePracticalTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipePracticalTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipePracticalTagGroupByOutputType[P]>
            : GetScalarType<T[P], RecipePracticalTagGroupByOutputType[P]>
        }
      >
    >


  export type RecipePracticalTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    practicalTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    practicalTag?: boolean | PracticalTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipePracticalTag"]>

  export type RecipePracticalTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    practicalTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    practicalTag?: boolean | PracticalTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipePracticalTag"]>

  export type RecipePracticalTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    practicalTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    practicalTag?: boolean | PracticalTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipePracticalTag"]>

  export type RecipePracticalTagSelectScalar = {
    id?: boolean
    recipeId?: boolean
    practicalTagId?: boolean
  }

  export type RecipePracticalTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "practicalTagId", ExtArgs["result"]["recipePracticalTag"]>
  export type RecipePracticalTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    practicalTag?: boolean | PracticalTagDefaultArgs<ExtArgs>
  }
  export type RecipePracticalTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    practicalTag?: boolean | PracticalTagDefaultArgs<ExtArgs>
  }
  export type RecipePracticalTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    practicalTag?: boolean | PracticalTagDefaultArgs<ExtArgs>
  }

  export type $RecipePracticalTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipePracticalTag"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      practicalTag: Prisma.$PracticalTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      practicalTagId: string
    }, ExtArgs["result"]["recipePracticalTag"]>
    composites: {}
  }

  type RecipePracticalTagGetPayload<S extends boolean | null | undefined | RecipePracticalTagDefaultArgs> = $Result.GetResult<Prisma.$RecipePracticalTagPayload, S>

  type RecipePracticalTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipePracticalTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipePracticalTagCountAggregateInputType | true
    }

  export interface RecipePracticalTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipePracticalTag'], meta: { name: 'RecipePracticalTag' } }
    /**
     * Find zero or one RecipePracticalTag that matches the filter.
     * @param {RecipePracticalTagFindUniqueArgs} args - Arguments to find a RecipePracticalTag
     * @example
     * // Get one RecipePracticalTag
     * const recipePracticalTag = await prisma.recipePracticalTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipePracticalTagFindUniqueArgs>(args: SelectSubset<T, RecipePracticalTagFindUniqueArgs<ExtArgs>>): Prisma__RecipePracticalTagClient<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipePracticalTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipePracticalTagFindUniqueOrThrowArgs} args - Arguments to find a RecipePracticalTag
     * @example
     * // Get one RecipePracticalTag
     * const recipePracticalTag = await prisma.recipePracticalTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipePracticalTagFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipePracticalTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipePracticalTagClient<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipePracticalTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipePracticalTagFindFirstArgs} args - Arguments to find a RecipePracticalTag
     * @example
     * // Get one RecipePracticalTag
     * const recipePracticalTag = await prisma.recipePracticalTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipePracticalTagFindFirstArgs>(args?: SelectSubset<T, RecipePracticalTagFindFirstArgs<ExtArgs>>): Prisma__RecipePracticalTagClient<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipePracticalTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipePracticalTagFindFirstOrThrowArgs} args - Arguments to find a RecipePracticalTag
     * @example
     * // Get one RecipePracticalTag
     * const recipePracticalTag = await prisma.recipePracticalTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipePracticalTagFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipePracticalTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipePracticalTagClient<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipePracticalTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipePracticalTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipePracticalTags
     * const recipePracticalTags = await prisma.recipePracticalTag.findMany()
     * 
     * // Get first 10 RecipePracticalTags
     * const recipePracticalTags = await prisma.recipePracticalTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipePracticalTagWithIdOnly = await prisma.recipePracticalTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipePracticalTagFindManyArgs>(args?: SelectSubset<T, RecipePracticalTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipePracticalTag.
     * @param {RecipePracticalTagCreateArgs} args - Arguments to create a RecipePracticalTag.
     * @example
     * // Create one RecipePracticalTag
     * const RecipePracticalTag = await prisma.recipePracticalTag.create({
     *   data: {
     *     // ... data to create a RecipePracticalTag
     *   }
     * })
     * 
     */
    create<T extends RecipePracticalTagCreateArgs>(args: SelectSubset<T, RecipePracticalTagCreateArgs<ExtArgs>>): Prisma__RecipePracticalTagClient<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipePracticalTags.
     * @param {RecipePracticalTagCreateManyArgs} args - Arguments to create many RecipePracticalTags.
     * @example
     * // Create many RecipePracticalTags
     * const recipePracticalTag = await prisma.recipePracticalTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipePracticalTagCreateManyArgs>(args?: SelectSubset<T, RecipePracticalTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipePracticalTags and returns the data saved in the database.
     * @param {RecipePracticalTagCreateManyAndReturnArgs} args - Arguments to create many RecipePracticalTags.
     * @example
     * // Create many RecipePracticalTags
     * const recipePracticalTag = await prisma.recipePracticalTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipePracticalTags and only return the `id`
     * const recipePracticalTagWithIdOnly = await prisma.recipePracticalTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipePracticalTagCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipePracticalTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipePracticalTag.
     * @param {RecipePracticalTagDeleteArgs} args - Arguments to delete one RecipePracticalTag.
     * @example
     * // Delete one RecipePracticalTag
     * const RecipePracticalTag = await prisma.recipePracticalTag.delete({
     *   where: {
     *     // ... filter to delete one RecipePracticalTag
     *   }
     * })
     * 
     */
    delete<T extends RecipePracticalTagDeleteArgs>(args: SelectSubset<T, RecipePracticalTagDeleteArgs<ExtArgs>>): Prisma__RecipePracticalTagClient<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipePracticalTag.
     * @param {RecipePracticalTagUpdateArgs} args - Arguments to update one RecipePracticalTag.
     * @example
     * // Update one RecipePracticalTag
     * const recipePracticalTag = await prisma.recipePracticalTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipePracticalTagUpdateArgs>(args: SelectSubset<T, RecipePracticalTagUpdateArgs<ExtArgs>>): Prisma__RecipePracticalTagClient<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipePracticalTags.
     * @param {RecipePracticalTagDeleteManyArgs} args - Arguments to filter RecipePracticalTags to delete.
     * @example
     * // Delete a few RecipePracticalTags
     * const { count } = await prisma.recipePracticalTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipePracticalTagDeleteManyArgs>(args?: SelectSubset<T, RecipePracticalTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipePracticalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipePracticalTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipePracticalTags
     * const recipePracticalTag = await prisma.recipePracticalTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipePracticalTagUpdateManyArgs>(args: SelectSubset<T, RecipePracticalTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipePracticalTags and returns the data updated in the database.
     * @param {RecipePracticalTagUpdateManyAndReturnArgs} args - Arguments to update many RecipePracticalTags.
     * @example
     * // Update many RecipePracticalTags
     * const recipePracticalTag = await prisma.recipePracticalTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipePracticalTags and only return the `id`
     * const recipePracticalTagWithIdOnly = await prisma.recipePracticalTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipePracticalTagUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipePracticalTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipePracticalTag.
     * @param {RecipePracticalTagUpsertArgs} args - Arguments to update or create a RecipePracticalTag.
     * @example
     * // Update or create a RecipePracticalTag
     * const recipePracticalTag = await prisma.recipePracticalTag.upsert({
     *   create: {
     *     // ... data to create a RecipePracticalTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipePracticalTag we want to update
     *   }
     * })
     */
    upsert<T extends RecipePracticalTagUpsertArgs>(args: SelectSubset<T, RecipePracticalTagUpsertArgs<ExtArgs>>): Prisma__RecipePracticalTagClient<$Result.GetResult<Prisma.$RecipePracticalTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipePracticalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipePracticalTagCountArgs} args - Arguments to filter RecipePracticalTags to count.
     * @example
     * // Count the number of RecipePracticalTags
     * const count = await prisma.recipePracticalTag.count({
     *   where: {
     *     // ... the filter for the RecipePracticalTags we want to count
     *   }
     * })
    **/
    count<T extends RecipePracticalTagCountArgs>(
      args?: Subset<T, RecipePracticalTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipePracticalTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipePracticalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipePracticalTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipePracticalTagAggregateArgs>(args: Subset<T, RecipePracticalTagAggregateArgs>): Prisma.PrismaPromise<GetRecipePracticalTagAggregateType<T>>

    /**
     * Group by RecipePracticalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipePracticalTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipePracticalTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipePracticalTagGroupByArgs['orderBy'] }
        : { orderBy?: RecipePracticalTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipePracticalTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipePracticalTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipePracticalTag model
   */
  readonly fields: RecipePracticalTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipePracticalTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipePracticalTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    practicalTag<T extends PracticalTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PracticalTagDefaultArgs<ExtArgs>>): Prisma__PracticalTagClient<$Result.GetResult<Prisma.$PracticalTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipePracticalTag model
   */
  interface RecipePracticalTagFieldRefs {
    readonly id: FieldRef<"RecipePracticalTag", 'String'>
    readonly recipeId: FieldRef<"RecipePracticalTag", 'String'>
    readonly practicalTagId: FieldRef<"RecipePracticalTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecipePracticalTag findUnique
   */
  export type RecipePracticalTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipePracticalTag to fetch.
     */
    where: RecipePracticalTagWhereUniqueInput
  }

  /**
   * RecipePracticalTag findUniqueOrThrow
   */
  export type RecipePracticalTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipePracticalTag to fetch.
     */
    where: RecipePracticalTagWhereUniqueInput
  }

  /**
   * RecipePracticalTag findFirst
   */
  export type RecipePracticalTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipePracticalTag to fetch.
     */
    where?: RecipePracticalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipePracticalTags to fetch.
     */
    orderBy?: RecipePracticalTagOrderByWithRelationInput | RecipePracticalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipePracticalTags.
     */
    cursor?: RecipePracticalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipePracticalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipePracticalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipePracticalTags.
     */
    distinct?: RecipePracticalTagScalarFieldEnum | RecipePracticalTagScalarFieldEnum[]
  }

  /**
   * RecipePracticalTag findFirstOrThrow
   */
  export type RecipePracticalTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipePracticalTag to fetch.
     */
    where?: RecipePracticalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipePracticalTags to fetch.
     */
    orderBy?: RecipePracticalTagOrderByWithRelationInput | RecipePracticalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipePracticalTags.
     */
    cursor?: RecipePracticalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipePracticalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipePracticalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipePracticalTags.
     */
    distinct?: RecipePracticalTagScalarFieldEnum | RecipePracticalTagScalarFieldEnum[]
  }

  /**
   * RecipePracticalTag findMany
   */
  export type RecipePracticalTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipePracticalTags to fetch.
     */
    where?: RecipePracticalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipePracticalTags to fetch.
     */
    orderBy?: RecipePracticalTagOrderByWithRelationInput | RecipePracticalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipePracticalTags.
     */
    cursor?: RecipePracticalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipePracticalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipePracticalTags.
     */
    skip?: number
    distinct?: RecipePracticalTagScalarFieldEnum | RecipePracticalTagScalarFieldEnum[]
  }

  /**
   * RecipePracticalTag create
   */
  export type RecipePracticalTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipePracticalTag.
     */
    data: XOR<RecipePracticalTagCreateInput, RecipePracticalTagUncheckedCreateInput>
  }

  /**
   * RecipePracticalTag createMany
   */
  export type RecipePracticalTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipePracticalTags.
     */
    data: RecipePracticalTagCreateManyInput | RecipePracticalTagCreateManyInput[]
  }

  /**
   * RecipePracticalTag createManyAndReturn
   */
  export type RecipePracticalTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * The data used to create many RecipePracticalTags.
     */
    data: RecipePracticalTagCreateManyInput | RecipePracticalTagCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipePracticalTag update
   */
  export type RecipePracticalTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipePracticalTag.
     */
    data: XOR<RecipePracticalTagUpdateInput, RecipePracticalTagUncheckedUpdateInput>
    /**
     * Choose, which RecipePracticalTag to update.
     */
    where: RecipePracticalTagWhereUniqueInput
  }

  /**
   * RecipePracticalTag updateMany
   */
  export type RecipePracticalTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipePracticalTags.
     */
    data: XOR<RecipePracticalTagUpdateManyMutationInput, RecipePracticalTagUncheckedUpdateManyInput>
    /**
     * Filter which RecipePracticalTags to update
     */
    where?: RecipePracticalTagWhereInput
    /**
     * Limit how many RecipePracticalTags to update.
     */
    limit?: number
  }

  /**
   * RecipePracticalTag updateManyAndReturn
   */
  export type RecipePracticalTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * The data used to update RecipePracticalTags.
     */
    data: XOR<RecipePracticalTagUpdateManyMutationInput, RecipePracticalTagUncheckedUpdateManyInput>
    /**
     * Filter which RecipePracticalTags to update
     */
    where?: RecipePracticalTagWhereInput
    /**
     * Limit how many RecipePracticalTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipePracticalTag upsert
   */
  export type RecipePracticalTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipePracticalTag to update in case it exists.
     */
    where: RecipePracticalTagWhereUniqueInput
    /**
     * In case the RecipePracticalTag found by the `where` argument doesn't exist, create a new RecipePracticalTag with this data.
     */
    create: XOR<RecipePracticalTagCreateInput, RecipePracticalTagUncheckedCreateInput>
    /**
     * In case the RecipePracticalTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipePracticalTagUpdateInput, RecipePracticalTagUncheckedUpdateInput>
  }

  /**
   * RecipePracticalTag delete
   */
  export type RecipePracticalTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
    /**
     * Filter which RecipePracticalTag to delete.
     */
    where: RecipePracticalTagWhereUniqueInput
  }

  /**
   * RecipePracticalTag deleteMany
   */
  export type RecipePracticalTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipePracticalTags to delete
     */
    where?: RecipePracticalTagWhereInput
    /**
     * Limit how many RecipePracticalTags to delete.
     */
    limit?: number
  }

  /**
   * RecipePracticalTag without action
   */
  export type RecipePracticalTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipePracticalTag
     */
    select?: RecipePracticalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipePracticalTag
     */
    omit?: RecipePracticalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipePracticalTagInclude<ExtArgs> | null
  }


  /**
   * Model NutritionalTag
   */

  export type AggregateNutritionalTag = {
    _count: NutritionalTagCountAggregateOutputType | null
    _min: NutritionalTagMinAggregateOutputType | null
    _max: NutritionalTagMaxAggregateOutputType | null
  }

  export type NutritionalTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.NutritionalCategory | null
  }

  export type NutritionalTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.NutritionalCategory | null
  }

  export type NutritionalTagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    _all: number
  }


  export type NutritionalTagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type NutritionalTagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type NutritionalTagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    _all?: true
  }

  export type NutritionalTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionalTag to aggregate.
     */
    where?: NutritionalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalTags to fetch.
     */
    orderBy?: NutritionalTagOrderByWithRelationInput | NutritionalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutritionalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionalTags
    **/
    _count?: true | NutritionalTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionalTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionalTagMaxAggregateInputType
  }

  export type GetNutritionalTagAggregateType<T extends NutritionalTagAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionalTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionalTag[P]>
      : GetScalarType<T[P], AggregateNutritionalTag[P]>
  }




  export type NutritionalTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionalTagWhereInput
    orderBy?: NutritionalTagOrderByWithAggregationInput | NutritionalTagOrderByWithAggregationInput[]
    by: NutritionalTagScalarFieldEnum[] | NutritionalTagScalarFieldEnum
    having?: NutritionalTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionalTagCountAggregateInputType | true
    _min?: NutritionalTagMinAggregateInputType
    _max?: NutritionalTagMaxAggregateInputType
  }

  export type NutritionalTagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: $Enums.NutritionalCategory
    _count: NutritionalTagCountAggregateOutputType | null
    _min: NutritionalTagMinAggregateOutputType | null
    _max: NutritionalTagMaxAggregateOutputType | null
  }

  type GetNutritionalTagGroupByPayload<T extends NutritionalTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionalTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionalTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionalTagGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionalTagGroupByOutputType[P]>
        }
      >
    >


  export type NutritionalTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    recipes?: boolean | NutritionalTag$recipesArgs<ExtArgs>
    _count?: boolean | NutritionalTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionalTag"]>

  export type NutritionalTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["nutritionalTag"]>

  export type NutritionalTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["nutritionalTag"]>

  export type NutritionalTagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }

  export type NutritionalTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category", ExtArgs["result"]["nutritionalTag"]>
  export type NutritionalTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipes?: boolean | NutritionalTag$recipesArgs<ExtArgs>
    _count?: boolean | NutritionalTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NutritionalTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NutritionalTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NutritionalTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutritionalTag"
    objects: {
      recipes: Prisma.$RecipeNutritionalTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: $Enums.NutritionalCategory
    }, ExtArgs["result"]["nutritionalTag"]>
    composites: {}
  }

  type NutritionalTagGetPayload<S extends boolean | null | undefined | NutritionalTagDefaultArgs> = $Result.GetResult<Prisma.$NutritionalTagPayload, S>

  type NutritionalTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NutritionalTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutritionalTagCountAggregateInputType | true
    }

  export interface NutritionalTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutritionalTag'], meta: { name: 'NutritionalTag' } }
    /**
     * Find zero or one NutritionalTag that matches the filter.
     * @param {NutritionalTagFindUniqueArgs} args - Arguments to find a NutritionalTag
     * @example
     * // Get one NutritionalTag
     * const nutritionalTag = await prisma.nutritionalTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutritionalTagFindUniqueArgs>(args: SelectSubset<T, NutritionalTagFindUniqueArgs<ExtArgs>>): Prisma__NutritionalTagClient<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NutritionalTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NutritionalTagFindUniqueOrThrowArgs} args - Arguments to find a NutritionalTag
     * @example
     * // Get one NutritionalTag
     * const nutritionalTag = await prisma.nutritionalTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutritionalTagFindUniqueOrThrowArgs>(args: SelectSubset<T, NutritionalTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutritionalTagClient<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalTagFindFirstArgs} args - Arguments to find a NutritionalTag
     * @example
     * // Get one NutritionalTag
     * const nutritionalTag = await prisma.nutritionalTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutritionalTagFindFirstArgs>(args?: SelectSubset<T, NutritionalTagFindFirstArgs<ExtArgs>>): Prisma__NutritionalTagClient<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalTagFindFirstOrThrowArgs} args - Arguments to find a NutritionalTag
     * @example
     * // Get one NutritionalTag
     * const nutritionalTag = await prisma.nutritionalTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutritionalTagFindFirstOrThrowArgs>(args?: SelectSubset<T, NutritionalTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutritionalTagClient<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NutritionalTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionalTags
     * const nutritionalTags = await prisma.nutritionalTag.findMany()
     * 
     * // Get first 10 NutritionalTags
     * const nutritionalTags = await prisma.nutritionalTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionalTagWithIdOnly = await prisma.nutritionalTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutritionalTagFindManyArgs>(args?: SelectSubset<T, NutritionalTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NutritionalTag.
     * @param {NutritionalTagCreateArgs} args - Arguments to create a NutritionalTag.
     * @example
     * // Create one NutritionalTag
     * const NutritionalTag = await prisma.nutritionalTag.create({
     *   data: {
     *     // ... data to create a NutritionalTag
     *   }
     * })
     * 
     */
    create<T extends NutritionalTagCreateArgs>(args: SelectSubset<T, NutritionalTagCreateArgs<ExtArgs>>): Prisma__NutritionalTagClient<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NutritionalTags.
     * @param {NutritionalTagCreateManyArgs} args - Arguments to create many NutritionalTags.
     * @example
     * // Create many NutritionalTags
     * const nutritionalTag = await prisma.nutritionalTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutritionalTagCreateManyArgs>(args?: SelectSubset<T, NutritionalTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NutritionalTags and returns the data saved in the database.
     * @param {NutritionalTagCreateManyAndReturnArgs} args - Arguments to create many NutritionalTags.
     * @example
     * // Create many NutritionalTags
     * const nutritionalTag = await prisma.nutritionalTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NutritionalTags and only return the `id`
     * const nutritionalTagWithIdOnly = await prisma.nutritionalTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NutritionalTagCreateManyAndReturnArgs>(args?: SelectSubset<T, NutritionalTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NutritionalTag.
     * @param {NutritionalTagDeleteArgs} args - Arguments to delete one NutritionalTag.
     * @example
     * // Delete one NutritionalTag
     * const NutritionalTag = await prisma.nutritionalTag.delete({
     *   where: {
     *     // ... filter to delete one NutritionalTag
     *   }
     * })
     * 
     */
    delete<T extends NutritionalTagDeleteArgs>(args: SelectSubset<T, NutritionalTagDeleteArgs<ExtArgs>>): Prisma__NutritionalTagClient<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NutritionalTag.
     * @param {NutritionalTagUpdateArgs} args - Arguments to update one NutritionalTag.
     * @example
     * // Update one NutritionalTag
     * const nutritionalTag = await prisma.nutritionalTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutritionalTagUpdateArgs>(args: SelectSubset<T, NutritionalTagUpdateArgs<ExtArgs>>): Prisma__NutritionalTagClient<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NutritionalTags.
     * @param {NutritionalTagDeleteManyArgs} args - Arguments to filter NutritionalTags to delete.
     * @example
     * // Delete a few NutritionalTags
     * const { count } = await prisma.nutritionalTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutritionalTagDeleteManyArgs>(args?: SelectSubset<T, NutritionalTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionalTags
     * const nutritionalTag = await prisma.nutritionalTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutritionalTagUpdateManyArgs>(args: SelectSubset<T, NutritionalTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionalTags and returns the data updated in the database.
     * @param {NutritionalTagUpdateManyAndReturnArgs} args - Arguments to update many NutritionalTags.
     * @example
     * // Update many NutritionalTags
     * const nutritionalTag = await prisma.nutritionalTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NutritionalTags and only return the `id`
     * const nutritionalTagWithIdOnly = await prisma.nutritionalTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NutritionalTagUpdateManyAndReturnArgs>(args: SelectSubset<T, NutritionalTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NutritionalTag.
     * @param {NutritionalTagUpsertArgs} args - Arguments to update or create a NutritionalTag.
     * @example
     * // Update or create a NutritionalTag
     * const nutritionalTag = await prisma.nutritionalTag.upsert({
     *   create: {
     *     // ... data to create a NutritionalTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionalTag we want to update
     *   }
     * })
     */
    upsert<T extends NutritionalTagUpsertArgs>(args: SelectSubset<T, NutritionalTagUpsertArgs<ExtArgs>>): Prisma__NutritionalTagClient<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NutritionalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalTagCountArgs} args - Arguments to filter NutritionalTags to count.
     * @example
     * // Count the number of NutritionalTags
     * const count = await prisma.nutritionalTag.count({
     *   where: {
     *     // ... the filter for the NutritionalTags we want to count
     *   }
     * })
    **/
    count<T extends NutritionalTagCountArgs>(
      args?: Subset<T, NutritionalTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionalTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionalTagAggregateArgs>(args: Subset<T, NutritionalTagAggregateArgs>): Prisma.PrismaPromise<GetNutritionalTagAggregateType<T>>

    /**
     * Group by NutritionalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionalTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionalTagGroupByArgs['orderBy'] }
        : { orderBy?: NutritionalTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionalTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionalTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutritionalTag model
   */
  readonly fields: NutritionalTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionalTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutritionalTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipes<T extends NutritionalTag$recipesArgs<ExtArgs> = {}>(args?: Subset<T, NutritionalTag$recipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutritionalTag model
   */
  interface NutritionalTagFieldRefs {
    readonly id: FieldRef<"NutritionalTag", 'String'>
    readonly name: FieldRef<"NutritionalTag", 'String'>
    readonly description: FieldRef<"NutritionalTag", 'String'>
    readonly category: FieldRef<"NutritionalTag", 'NutritionalCategory'>
  }
    

  // Custom InputTypes
  /**
   * NutritionalTag findUnique
   */
  export type NutritionalTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalTag to fetch.
     */
    where: NutritionalTagWhereUniqueInput
  }

  /**
   * NutritionalTag findUniqueOrThrow
   */
  export type NutritionalTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalTag to fetch.
     */
    where: NutritionalTagWhereUniqueInput
  }

  /**
   * NutritionalTag findFirst
   */
  export type NutritionalTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalTag to fetch.
     */
    where?: NutritionalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalTags to fetch.
     */
    orderBy?: NutritionalTagOrderByWithRelationInput | NutritionalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionalTags.
     */
    cursor?: NutritionalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionalTags.
     */
    distinct?: NutritionalTagScalarFieldEnum | NutritionalTagScalarFieldEnum[]
  }

  /**
   * NutritionalTag findFirstOrThrow
   */
  export type NutritionalTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalTag to fetch.
     */
    where?: NutritionalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalTags to fetch.
     */
    orderBy?: NutritionalTagOrderByWithRelationInput | NutritionalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionalTags.
     */
    cursor?: NutritionalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionalTags.
     */
    distinct?: NutritionalTagScalarFieldEnum | NutritionalTagScalarFieldEnum[]
  }

  /**
   * NutritionalTag findMany
   */
  export type NutritionalTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalTags to fetch.
     */
    where?: NutritionalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalTags to fetch.
     */
    orderBy?: NutritionalTagOrderByWithRelationInput | NutritionalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionalTags.
     */
    cursor?: NutritionalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalTags.
     */
    skip?: number
    distinct?: NutritionalTagScalarFieldEnum | NutritionalTagScalarFieldEnum[]
  }

  /**
   * NutritionalTag create
   */
  export type NutritionalTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
    /**
     * The data needed to create a NutritionalTag.
     */
    data: XOR<NutritionalTagCreateInput, NutritionalTagUncheckedCreateInput>
  }

  /**
   * NutritionalTag createMany
   */
  export type NutritionalTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutritionalTags.
     */
    data: NutritionalTagCreateManyInput | NutritionalTagCreateManyInput[]
  }

  /**
   * NutritionalTag createManyAndReturn
   */
  export type NutritionalTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * The data used to create many NutritionalTags.
     */
    data: NutritionalTagCreateManyInput | NutritionalTagCreateManyInput[]
  }

  /**
   * NutritionalTag update
   */
  export type NutritionalTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
    /**
     * The data needed to update a NutritionalTag.
     */
    data: XOR<NutritionalTagUpdateInput, NutritionalTagUncheckedUpdateInput>
    /**
     * Choose, which NutritionalTag to update.
     */
    where: NutritionalTagWhereUniqueInput
  }

  /**
   * NutritionalTag updateMany
   */
  export type NutritionalTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutritionalTags.
     */
    data: XOR<NutritionalTagUpdateManyMutationInput, NutritionalTagUncheckedUpdateManyInput>
    /**
     * Filter which NutritionalTags to update
     */
    where?: NutritionalTagWhereInput
    /**
     * Limit how many NutritionalTags to update.
     */
    limit?: number
  }

  /**
   * NutritionalTag updateManyAndReturn
   */
  export type NutritionalTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * The data used to update NutritionalTags.
     */
    data: XOR<NutritionalTagUpdateManyMutationInput, NutritionalTagUncheckedUpdateManyInput>
    /**
     * Filter which NutritionalTags to update
     */
    where?: NutritionalTagWhereInput
    /**
     * Limit how many NutritionalTags to update.
     */
    limit?: number
  }

  /**
   * NutritionalTag upsert
   */
  export type NutritionalTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
    /**
     * The filter to search for the NutritionalTag to update in case it exists.
     */
    where: NutritionalTagWhereUniqueInput
    /**
     * In case the NutritionalTag found by the `where` argument doesn't exist, create a new NutritionalTag with this data.
     */
    create: XOR<NutritionalTagCreateInput, NutritionalTagUncheckedCreateInput>
    /**
     * In case the NutritionalTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutritionalTagUpdateInput, NutritionalTagUncheckedUpdateInput>
  }

  /**
   * NutritionalTag delete
   */
  export type NutritionalTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
    /**
     * Filter which NutritionalTag to delete.
     */
    where: NutritionalTagWhereUniqueInput
  }

  /**
   * NutritionalTag deleteMany
   */
  export type NutritionalTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionalTags to delete
     */
    where?: NutritionalTagWhereInput
    /**
     * Limit how many NutritionalTags to delete.
     */
    limit?: number
  }

  /**
   * NutritionalTag.recipes
   */
  export type NutritionalTag$recipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    where?: RecipeNutritionalTagWhereInput
    orderBy?: RecipeNutritionalTagOrderByWithRelationInput | RecipeNutritionalTagOrderByWithRelationInput[]
    cursor?: RecipeNutritionalTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeNutritionalTagScalarFieldEnum | RecipeNutritionalTagScalarFieldEnum[]
  }

  /**
   * NutritionalTag without action
   */
  export type NutritionalTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalTag
     */
    select?: NutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalTag
     */
    omit?: NutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalTagInclude<ExtArgs> | null
  }


  /**
   * Model RecipeNutritionalTag
   */

  export type AggregateRecipeNutritionalTag = {
    _count: RecipeNutritionalTagCountAggregateOutputType | null
    _min: RecipeNutritionalTagMinAggregateOutputType | null
    _max: RecipeNutritionalTagMaxAggregateOutputType | null
  }

  export type RecipeNutritionalTagMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    nutritionalTagId: string | null
  }

  export type RecipeNutritionalTagMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    nutritionalTagId: string | null
  }

  export type RecipeNutritionalTagCountAggregateOutputType = {
    id: number
    recipeId: number
    nutritionalTagId: number
    _all: number
  }


  export type RecipeNutritionalTagMinAggregateInputType = {
    id?: true
    recipeId?: true
    nutritionalTagId?: true
  }

  export type RecipeNutritionalTagMaxAggregateInputType = {
    id?: true
    recipeId?: true
    nutritionalTagId?: true
  }

  export type RecipeNutritionalTagCountAggregateInputType = {
    id?: true
    recipeId?: true
    nutritionalTagId?: true
    _all?: true
  }

  export type RecipeNutritionalTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeNutritionalTag to aggregate.
     */
    where?: RecipeNutritionalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeNutritionalTags to fetch.
     */
    orderBy?: RecipeNutritionalTagOrderByWithRelationInput | RecipeNutritionalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeNutritionalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeNutritionalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeNutritionalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeNutritionalTags
    **/
    _count?: true | RecipeNutritionalTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeNutritionalTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeNutritionalTagMaxAggregateInputType
  }

  export type GetRecipeNutritionalTagAggregateType<T extends RecipeNutritionalTagAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeNutritionalTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeNutritionalTag[P]>
      : GetScalarType<T[P], AggregateRecipeNutritionalTag[P]>
  }




  export type RecipeNutritionalTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeNutritionalTagWhereInput
    orderBy?: RecipeNutritionalTagOrderByWithAggregationInput | RecipeNutritionalTagOrderByWithAggregationInput[]
    by: RecipeNutritionalTagScalarFieldEnum[] | RecipeNutritionalTagScalarFieldEnum
    having?: RecipeNutritionalTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeNutritionalTagCountAggregateInputType | true
    _min?: RecipeNutritionalTagMinAggregateInputType
    _max?: RecipeNutritionalTagMaxAggregateInputType
  }

  export type RecipeNutritionalTagGroupByOutputType = {
    id: string
    recipeId: string
    nutritionalTagId: string
    _count: RecipeNutritionalTagCountAggregateOutputType | null
    _min: RecipeNutritionalTagMinAggregateOutputType | null
    _max: RecipeNutritionalTagMaxAggregateOutputType | null
  }

  type GetRecipeNutritionalTagGroupByPayload<T extends RecipeNutritionalTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeNutritionalTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeNutritionalTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeNutritionalTagGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeNutritionalTagGroupByOutputType[P]>
        }
      >
    >


  export type RecipeNutritionalTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    nutritionalTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    nutritionalTag?: boolean | NutritionalTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeNutritionalTag"]>

  export type RecipeNutritionalTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    nutritionalTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    nutritionalTag?: boolean | NutritionalTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeNutritionalTag"]>

  export type RecipeNutritionalTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    nutritionalTagId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    nutritionalTag?: boolean | NutritionalTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeNutritionalTag"]>

  export type RecipeNutritionalTagSelectScalar = {
    id?: boolean
    recipeId?: boolean
    nutritionalTagId?: boolean
  }

  export type RecipeNutritionalTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipeId" | "nutritionalTagId", ExtArgs["result"]["recipeNutritionalTag"]>
  export type RecipeNutritionalTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    nutritionalTag?: boolean | NutritionalTagDefaultArgs<ExtArgs>
  }
  export type RecipeNutritionalTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    nutritionalTag?: boolean | NutritionalTagDefaultArgs<ExtArgs>
  }
  export type RecipeNutritionalTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    nutritionalTag?: boolean | NutritionalTagDefaultArgs<ExtArgs>
  }

  export type $RecipeNutritionalTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeNutritionalTag"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      nutritionalTag: Prisma.$NutritionalTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      nutritionalTagId: string
    }, ExtArgs["result"]["recipeNutritionalTag"]>
    composites: {}
  }

  type RecipeNutritionalTagGetPayload<S extends boolean | null | undefined | RecipeNutritionalTagDefaultArgs> = $Result.GetResult<Prisma.$RecipeNutritionalTagPayload, S>

  type RecipeNutritionalTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecipeNutritionalTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecipeNutritionalTagCountAggregateInputType | true
    }

  export interface RecipeNutritionalTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeNutritionalTag'], meta: { name: 'RecipeNutritionalTag' } }
    /**
     * Find zero or one RecipeNutritionalTag that matches the filter.
     * @param {RecipeNutritionalTagFindUniqueArgs} args - Arguments to find a RecipeNutritionalTag
     * @example
     * // Get one RecipeNutritionalTag
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeNutritionalTagFindUniqueArgs>(args: SelectSubset<T, RecipeNutritionalTagFindUniqueArgs<ExtArgs>>): Prisma__RecipeNutritionalTagClient<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecipeNutritionalTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecipeNutritionalTagFindUniqueOrThrowArgs} args - Arguments to find a RecipeNutritionalTag
     * @example
     * // Get one RecipeNutritionalTag
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeNutritionalTagFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeNutritionalTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeNutritionalTagClient<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeNutritionalTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeNutritionalTagFindFirstArgs} args - Arguments to find a RecipeNutritionalTag
     * @example
     * // Get one RecipeNutritionalTag
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeNutritionalTagFindFirstArgs>(args?: SelectSubset<T, RecipeNutritionalTagFindFirstArgs<ExtArgs>>): Prisma__RecipeNutritionalTagClient<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecipeNutritionalTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeNutritionalTagFindFirstOrThrowArgs} args - Arguments to find a RecipeNutritionalTag
     * @example
     * // Get one RecipeNutritionalTag
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeNutritionalTagFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeNutritionalTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeNutritionalTagClient<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecipeNutritionalTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeNutritionalTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeNutritionalTags
     * const recipeNutritionalTags = await prisma.recipeNutritionalTag.findMany()
     * 
     * // Get first 10 RecipeNutritionalTags
     * const recipeNutritionalTags = await prisma.recipeNutritionalTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeNutritionalTagWithIdOnly = await prisma.recipeNutritionalTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeNutritionalTagFindManyArgs>(args?: SelectSubset<T, RecipeNutritionalTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecipeNutritionalTag.
     * @param {RecipeNutritionalTagCreateArgs} args - Arguments to create a RecipeNutritionalTag.
     * @example
     * // Create one RecipeNutritionalTag
     * const RecipeNutritionalTag = await prisma.recipeNutritionalTag.create({
     *   data: {
     *     // ... data to create a RecipeNutritionalTag
     *   }
     * })
     * 
     */
    create<T extends RecipeNutritionalTagCreateArgs>(args: SelectSubset<T, RecipeNutritionalTagCreateArgs<ExtArgs>>): Prisma__RecipeNutritionalTagClient<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecipeNutritionalTags.
     * @param {RecipeNutritionalTagCreateManyArgs} args - Arguments to create many RecipeNutritionalTags.
     * @example
     * // Create many RecipeNutritionalTags
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeNutritionalTagCreateManyArgs>(args?: SelectSubset<T, RecipeNutritionalTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecipeNutritionalTags and returns the data saved in the database.
     * @param {RecipeNutritionalTagCreateManyAndReturnArgs} args - Arguments to create many RecipeNutritionalTags.
     * @example
     * // Create many RecipeNutritionalTags
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecipeNutritionalTags and only return the `id`
     * const recipeNutritionalTagWithIdOnly = await prisma.recipeNutritionalTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeNutritionalTagCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeNutritionalTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecipeNutritionalTag.
     * @param {RecipeNutritionalTagDeleteArgs} args - Arguments to delete one RecipeNutritionalTag.
     * @example
     * // Delete one RecipeNutritionalTag
     * const RecipeNutritionalTag = await prisma.recipeNutritionalTag.delete({
     *   where: {
     *     // ... filter to delete one RecipeNutritionalTag
     *   }
     * })
     * 
     */
    delete<T extends RecipeNutritionalTagDeleteArgs>(args: SelectSubset<T, RecipeNutritionalTagDeleteArgs<ExtArgs>>): Prisma__RecipeNutritionalTagClient<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecipeNutritionalTag.
     * @param {RecipeNutritionalTagUpdateArgs} args - Arguments to update one RecipeNutritionalTag.
     * @example
     * // Update one RecipeNutritionalTag
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeNutritionalTagUpdateArgs>(args: SelectSubset<T, RecipeNutritionalTagUpdateArgs<ExtArgs>>): Prisma__RecipeNutritionalTagClient<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecipeNutritionalTags.
     * @param {RecipeNutritionalTagDeleteManyArgs} args - Arguments to filter RecipeNutritionalTags to delete.
     * @example
     * // Delete a few RecipeNutritionalTags
     * const { count } = await prisma.recipeNutritionalTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeNutritionalTagDeleteManyArgs>(args?: SelectSubset<T, RecipeNutritionalTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeNutritionalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeNutritionalTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeNutritionalTags
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeNutritionalTagUpdateManyArgs>(args: SelectSubset<T, RecipeNutritionalTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeNutritionalTags and returns the data updated in the database.
     * @param {RecipeNutritionalTagUpdateManyAndReturnArgs} args - Arguments to update many RecipeNutritionalTags.
     * @example
     * // Update many RecipeNutritionalTags
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecipeNutritionalTags and only return the `id`
     * const recipeNutritionalTagWithIdOnly = await prisma.recipeNutritionalTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecipeNutritionalTagUpdateManyAndReturnArgs>(args: SelectSubset<T, RecipeNutritionalTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecipeNutritionalTag.
     * @param {RecipeNutritionalTagUpsertArgs} args - Arguments to update or create a RecipeNutritionalTag.
     * @example
     * // Update or create a RecipeNutritionalTag
     * const recipeNutritionalTag = await prisma.recipeNutritionalTag.upsert({
     *   create: {
     *     // ... data to create a RecipeNutritionalTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeNutritionalTag we want to update
     *   }
     * })
     */
    upsert<T extends RecipeNutritionalTagUpsertArgs>(args: SelectSubset<T, RecipeNutritionalTagUpsertArgs<ExtArgs>>): Prisma__RecipeNutritionalTagClient<$Result.GetResult<Prisma.$RecipeNutritionalTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecipeNutritionalTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeNutritionalTagCountArgs} args - Arguments to filter RecipeNutritionalTags to count.
     * @example
     * // Count the number of RecipeNutritionalTags
     * const count = await prisma.recipeNutritionalTag.count({
     *   where: {
     *     // ... the filter for the RecipeNutritionalTags we want to count
     *   }
     * })
    **/
    count<T extends RecipeNutritionalTagCountArgs>(
      args?: Subset<T, RecipeNutritionalTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeNutritionalTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeNutritionalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeNutritionalTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeNutritionalTagAggregateArgs>(args: Subset<T, RecipeNutritionalTagAggregateArgs>): Prisma.PrismaPromise<GetRecipeNutritionalTagAggregateType<T>>

    /**
     * Group by RecipeNutritionalTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeNutritionalTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeNutritionalTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeNutritionalTagGroupByArgs['orderBy'] }
        : { orderBy?: RecipeNutritionalTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeNutritionalTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeNutritionalTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeNutritionalTag model
   */
  readonly fields: RecipeNutritionalTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeNutritionalTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeNutritionalTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nutritionalTag<T extends NutritionalTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NutritionalTagDefaultArgs<ExtArgs>>): Prisma__NutritionalTagClient<$Result.GetResult<Prisma.$NutritionalTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecipeNutritionalTag model
   */
  interface RecipeNutritionalTagFieldRefs {
    readonly id: FieldRef<"RecipeNutritionalTag", 'String'>
    readonly recipeId: FieldRef<"RecipeNutritionalTag", 'String'>
    readonly nutritionalTagId: FieldRef<"RecipeNutritionalTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RecipeNutritionalTag findUnique
   */
  export type RecipeNutritionalTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeNutritionalTag to fetch.
     */
    where: RecipeNutritionalTagWhereUniqueInput
  }

  /**
   * RecipeNutritionalTag findUniqueOrThrow
   */
  export type RecipeNutritionalTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeNutritionalTag to fetch.
     */
    where: RecipeNutritionalTagWhereUniqueInput
  }

  /**
   * RecipeNutritionalTag findFirst
   */
  export type RecipeNutritionalTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeNutritionalTag to fetch.
     */
    where?: RecipeNutritionalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeNutritionalTags to fetch.
     */
    orderBy?: RecipeNutritionalTagOrderByWithRelationInput | RecipeNutritionalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeNutritionalTags.
     */
    cursor?: RecipeNutritionalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeNutritionalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeNutritionalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeNutritionalTags.
     */
    distinct?: RecipeNutritionalTagScalarFieldEnum | RecipeNutritionalTagScalarFieldEnum[]
  }

  /**
   * RecipeNutritionalTag findFirstOrThrow
   */
  export type RecipeNutritionalTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeNutritionalTag to fetch.
     */
    where?: RecipeNutritionalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeNutritionalTags to fetch.
     */
    orderBy?: RecipeNutritionalTagOrderByWithRelationInput | RecipeNutritionalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeNutritionalTags.
     */
    cursor?: RecipeNutritionalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeNutritionalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeNutritionalTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeNutritionalTags.
     */
    distinct?: RecipeNutritionalTagScalarFieldEnum | RecipeNutritionalTagScalarFieldEnum[]
  }

  /**
   * RecipeNutritionalTag findMany
   */
  export type RecipeNutritionalTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    /**
     * Filter, which RecipeNutritionalTags to fetch.
     */
    where?: RecipeNutritionalTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeNutritionalTags to fetch.
     */
    orderBy?: RecipeNutritionalTagOrderByWithRelationInput | RecipeNutritionalTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeNutritionalTags.
     */
    cursor?: RecipeNutritionalTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeNutritionalTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeNutritionalTags.
     */
    skip?: number
    distinct?: RecipeNutritionalTagScalarFieldEnum | RecipeNutritionalTagScalarFieldEnum[]
  }

  /**
   * RecipeNutritionalTag create
   */
  export type RecipeNutritionalTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeNutritionalTag.
     */
    data: XOR<RecipeNutritionalTagCreateInput, RecipeNutritionalTagUncheckedCreateInput>
  }

  /**
   * RecipeNutritionalTag createMany
   */
  export type RecipeNutritionalTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeNutritionalTags.
     */
    data: RecipeNutritionalTagCreateManyInput | RecipeNutritionalTagCreateManyInput[]
  }

  /**
   * RecipeNutritionalTag createManyAndReturn
   */
  export type RecipeNutritionalTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * The data used to create many RecipeNutritionalTags.
     */
    data: RecipeNutritionalTagCreateManyInput | RecipeNutritionalTagCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeNutritionalTag update
   */
  export type RecipeNutritionalTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeNutritionalTag.
     */
    data: XOR<RecipeNutritionalTagUpdateInput, RecipeNutritionalTagUncheckedUpdateInput>
    /**
     * Choose, which RecipeNutritionalTag to update.
     */
    where: RecipeNutritionalTagWhereUniqueInput
  }

  /**
   * RecipeNutritionalTag updateMany
   */
  export type RecipeNutritionalTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeNutritionalTags.
     */
    data: XOR<RecipeNutritionalTagUpdateManyMutationInput, RecipeNutritionalTagUncheckedUpdateManyInput>
    /**
     * Filter which RecipeNutritionalTags to update
     */
    where?: RecipeNutritionalTagWhereInput
    /**
     * Limit how many RecipeNutritionalTags to update.
     */
    limit?: number
  }

  /**
   * RecipeNutritionalTag updateManyAndReturn
   */
  export type RecipeNutritionalTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * The data used to update RecipeNutritionalTags.
     */
    data: XOR<RecipeNutritionalTagUpdateManyMutationInput, RecipeNutritionalTagUncheckedUpdateManyInput>
    /**
     * Filter which RecipeNutritionalTags to update
     */
    where?: RecipeNutritionalTagWhereInput
    /**
     * Limit how many RecipeNutritionalTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecipeNutritionalTag upsert
   */
  export type RecipeNutritionalTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeNutritionalTag to update in case it exists.
     */
    where: RecipeNutritionalTagWhereUniqueInput
    /**
     * In case the RecipeNutritionalTag found by the `where` argument doesn't exist, create a new RecipeNutritionalTag with this data.
     */
    create: XOR<RecipeNutritionalTagCreateInput, RecipeNutritionalTagUncheckedCreateInput>
    /**
     * In case the RecipeNutritionalTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeNutritionalTagUpdateInput, RecipeNutritionalTagUncheckedUpdateInput>
  }

  /**
   * RecipeNutritionalTag delete
   */
  export type RecipeNutritionalTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
    /**
     * Filter which RecipeNutritionalTag to delete.
     */
    where: RecipeNutritionalTagWhereUniqueInput
  }

  /**
   * RecipeNutritionalTag deleteMany
   */
  export type RecipeNutritionalTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeNutritionalTags to delete
     */
    where?: RecipeNutritionalTagWhereInput
    /**
     * Limit how many RecipeNutritionalTags to delete.
     */
    limit?: number
  }

  /**
   * RecipeNutritionalTag without action
   */
  export type RecipeNutritionalTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeNutritionalTag
     */
    select?: RecipeNutritionalTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecipeNutritionalTag
     */
    omit?: RecipeNutritionalTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeNutritionalTagInclude<ExtArgs> | null
  }


  /**
   * Model MealPlan
   */

  export type AggregateMealPlan = {
    _count: MealPlanCountAggregateOutputType | null
    _min: MealPlanMinAggregateOutputType | null
    _max: MealPlanMaxAggregateOutputType | null
  }

  export type MealPlanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    weekStartDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MealPlanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    weekStartDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MealPlanCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    weekStartDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MealPlanMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    weekStartDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MealPlanMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    weekStartDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MealPlanCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    weekStartDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MealPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MealPlan to aggregate.
     */
    where?: MealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlans to fetch.
     */
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MealPlans
    **/
    _count?: true | MealPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MealPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MealPlanMaxAggregateInputType
  }

  export type GetMealPlanAggregateType<T extends MealPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateMealPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMealPlan[P]>
      : GetScalarType<T[P], AggregateMealPlan[P]>
  }




  export type MealPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealPlanWhereInput
    orderBy?: MealPlanOrderByWithAggregationInput | MealPlanOrderByWithAggregationInput[]
    by: MealPlanScalarFieldEnum[] | MealPlanScalarFieldEnum
    having?: MealPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MealPlanCountAggregateInputType | true
    _min?: MealPlanMinAggregateInputType
    _max?: MealPlanMaxAggregateInputType
  }

  export type MealPlanGroupByOutputType = {
    id: string
    userId: string
    name: string
    weekStartDate: Date
    createdAt: Date
    updatedAt: Date
    _count: MealPlanCountAggregateOutputType | null
    _min: MealPlanMinAggregateOutputType | null
    _max: MealPlanMaxAggregateOutputType | null
  }

  type GetMealPlanGroupByPayload<T extends MealPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MealPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MealPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MealPlanGroupByOutputType[P]>
            : GetScalarType<T[P], MealPlanGroupByOutputType[P]>
        }
      >
    >


  export type MealPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    weekStartDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    meals?: boolean | MealPlan$mealsArgs<ExtArgs>
    shoppingList?: boolean | MealPlan$shoppingListArgs<ExtArgs>
    _count?: boolean | MealPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mealPlan"]>

  export type MealPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    weekStartDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mealPlan"]>

  export type MealPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    weekStartDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mealPlan"]>

  export type MealPlanSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    weekStartDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MealPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "weekStartDate" | "createdAt" | "updatedAt", ExtArgs["result"]["mealPlan"]>
  export type MealPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    meals?: boolean | MealPlan$mealsArgs<ExtArgs>
    shoppingList?: boolean | MealPlan$shoppingListArgs<ExtArgs>
    _count?: boolean | MealPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MealPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MealPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MealPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MealPlan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      meals: Prisma.$MealPlanItemPayload<ExtArgs>[]
      shoppingList: Prisma.$ShoppingListPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      weekStartDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mealPlan"]>
    composites: {}
  }

  type MealPlanGetPayload<S extends boolean | null | undefined | MealPlanDefaultArgs> = $Result.GetResult<Prisma.$MealPlanPayload, S>

  type MealPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MealPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MealPlanCountAggregateInputType | true
    }

  export interface MealPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MealPlan'], meta: { name: 'MealPlan' } }
    /**
     * Find zero or one MealPlan that matches the filter.
     * @param {MealPlanFindUniqueArgs} args - Arguments to find a MealPlan
     * @example
     * // Get one MealPlan
     * const mealPlan = await prisma.mealPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MealPlanFindUniqueArgs>(args: SelectSubset<T, MealPlanFindUniqueArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MealPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MealPlanFindUniqueOrThrowArgs} args - Arguments to find a MealPlan
     * @example
     * // Get one MealPlan
     * const mealPlan = await prisma.mealPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MealPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, MealPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MealPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanFindFirstArgs} args - Arguments to find a MealPlan
     * @example
     * // Get one MealPlan
     * const mealPlan = await prisma.mealPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MealPlanFindFirstArgs>(args?: SelectSubset<T, MealPlanFindFirstArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MealPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanFindFirstOrThrowArgs} args - Arguments to find a MealPlan
     * @example
     * // Get one MealPlan
     * const mealPlan = await prisma.mealPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MealPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, MealPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MealPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MealPlans
     * const mealPlans = await prisma.mealPlan.findMany()
     * 
     * // Get first 10 MealPlans
     * const mealPlans = await prisma.mealPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mealPlanWithIdOnly = await prisma.mealPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MealPlanFindManyArgs>(args?: SelectSubset<T, MealPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MealPlan.
     * @param {MealPlanCreateArgs} args - Arguments to create a MealPlan.
     * @example
     * // Create one MealPlan
     * const MealPlan = await prisma.mealPlan.create({
     *   data: {
     *     // ... data to create a MealPlan
     *   }
     * })
     * 
     */
    create<T extends MealPlanCreateArgs>(args: SelectSubset<T, MealPlanCreateArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MealPlans.
     * @param {MealPlanCreateManyArgs} args - Arguments to create many MealPlans.
     * @example
     * // Create many MealPlans
     * const mealPlan = await prisma.mealPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MealPlanCreateManyArgs>(args?: SelectSubset<T, MealPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MealPlans and returns the data saved in the database.
     * @param {MealPlanCreateManyAndReturnArgs} args - Arguments to create many MealPlans.
     * @example
     * // Create many MealPlans
     * const mealPlan = await prisma.mealPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MealPlans and only return the `id`
     * const mealPlanWithIdOnly = await prisma.mealPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MealPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, MealPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MealPlan.
     * @param {MealPlanDeleteArgs} args - Arguments to delete one MealPlan.
     * @example
     * // Delete one MealPlan
     * const MealPlan = await prisma.mealPlan.delete({
     *   where: {
     *     // ... filter to delete one MealPlan
     *   }
     * })
     * 
     */
    delete<T extends MealPlanDeleteArgs>(args: SelectSubset<T, MealPlanDeleteArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MealPlan.
     * @param {MealPlanUpdateArgs} args - Arguments to update one MealPlan.
     * @example
     * // Update one MealPlan
     * const mealPlan = await prisma.mealPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MealPlanUpdateArgs>(args: SelectSubset<T, MealPlanUpdateArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MealPlans.
     * @param {MealPlanDeleteManyArgs} args - Arguments to filter MealPlans to delete.
     * @example
     * // Delete a few MealPlans
     * const { count } = await prisma.mealPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MealPlanDeleteManyArgs>(args?: SelectSubset<T, MealPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MealPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MealPlans
     * const mealPlan = await prisma.mealPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MealPlanUpdateManyArgs>(args: SelectSubset<T, MealPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MealPlans and returns the data updated in the database.
     * @param {MealPlanUpdateManyAndReturnArgs} args - Arguments to update many MealPlans.
     * @example
     * // Update many MealPlans
     * const mealPlan = await prisma.mealPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MealPlans and only return the `id`
     * const mealPlanWithIdOnly = await prisma.mealPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MealPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, MealPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MealPlan.
     * @param {MealPlanUpsertArgs} args - Arguments to update or create a MealPlan.
     * @example
     * // Update or create a MealPlan
     * const mealPlan = await prisma.mealPlan.upsert({
     *   create: {
     *     // ... data to create a MealPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MealPlan we want to update
     *   }
     * })
     */
    upsert<T extends MealPlanUpsertArgs>(args: SelectSubset<T, MealPlanUpsertArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MealPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanCountArgs} args - Arguments to filter MealPlans to count.
     * @example
     * // Count the number of MealPlans
     * const count = await prisma.mealPlan.count({
     *   where: {
     *     // ... the filter for the MealPlans we want to count
     *   }
     * })
    **/
    count<T extends MealPlanCountArgs>(
      args?: Subset<T, MealPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MealPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MealPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MealPlanAggregateArgs>(args: Subset<T, MealPlanAggregateArgs>): Prisma.PrismaPromise<GetMealPlanAggregateType<T>>

    /**
     * Group by MealPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MealPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MealPlanGroupByArgs['orderBy'] }
        : { orderBy?: MealPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MealPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMealPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MealPlan model
   */
  readonly fields: MealPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MealPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MealPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    meals<T extends MealPlan$mealsArgs<ExtArgs> = {}>(args?: Subset<T, MealPlan$mealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shoppingList<T extends MealPlan$shoppingListArgs<ExtArgs> = {}>(args?: Subset<T, MealPlan$shoppingListArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MealPlan model
   */
  interface MealPlanFieldRefs {
    readonly id: FieldRef<"MealPlan", 'String'>
    readonly userId: FieldRef<"MealPlan", 'String'>
    readonly name: FieldRef<"MealPlan", 'String'>
    readonly weekStartDate: FieldRef<"MealPlan", 'DateTime'>
    readonly createdAt: FieldRef<"MealPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"MealPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MealPlan findUnique
   */
  export type MealPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlan to fetch.
     */
    where: MealPlanWhereUniqueInput
  }

  /**
   * MealPlan findUniqueOrThrow
   */
  export type MealPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlan to fetch.
     */
    where: MealPlanWhereUniqueInput
  }

  /**
   * MealPlan findFirst
   */
  export type MealPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlan to fetch.
     */
    where?: MealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlans to fetch.
     */
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MealPlans.
     */
    cursor?: MealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MealPlans.
     */
    distinct?: MealPlanScalarFieldEnum | MealPlanScalarFieldEnum[]
  }

  /**
   * MealPlan findFirstOrThrow
   */
  export type MealPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlan to fetch.
     */
    where?: MealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlans to fetch.
     */
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MealPlans.
     */
    cursor?: MealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MealPlans.
     */
    distinct?: MealPlanScalarFieldEnum | MealPlanScalarFieldEnum[]
  }

  /**
   * MealPlan findMany
   */
  export type MealPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter, which MealPlans to fetch.
     */
    where?: MealPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlans to fetch.
     */
    orderBy?: MealPlanOrderByWithRelationInput | MealPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MealPlans.
     */
    cursor?: MealPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlans.
     */
    skip?: number
    distinct?: MealPlanScalarFieldEnum | MealPlanScalarFieldEnum[]
  }

  /**
   * MealPlan create
   */
  export type MealPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a MealPlan.
     */
    data: XOR<MealPlanCreateInput, MealPlanUncheckedCreateInput>
  }

  /**
   * MealPlan createMany
   */
  export type MealPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MealPlans.
     */
    data: MealPlanCreateManyInput | MealPlanCreateManyInput[]
  }

  /**
   * MealPlan createManyAndReturn
   */
  export type MealPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * The data used to create many MealPlans.
     */
    data: MealPlanCreateManyInput | MealPlanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MealPlan update
   */
  export type MealPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a MealPlan.
     */
    data: XOR<MealPlanUpdateInput, MealPlanUncheckedUpdateInput>
    /**
     * Choose, which MealPlan to update.
     */
    where: MealPlanWhereUniqueInput
  }

  /**
   * MealPlan updateMany
   */
  export type MealPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MealPlans.
     */
    data: XOR<MealPlanUpdateManyMutationInput, MealPlanUncheckedUpdateManyInput>
    /**
     * Filter which MealPlans to update
     */
    where?: MealPlanWhereInput
    /**
     * Limit how many MealPlans to update.
     */
    limit?: number
  }

  /**
   * MealPlan updateManyAndReturn
   */
  export type MealPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * The data used to update MealPlans.
     */
    data: XOR<MealPlanUpdateManyMutationInput, MealPlanUncheckedUpdateManyInput>
    /**
     * Filter which MealPlans to update
     */
    where?: MealPlanWhereInput
    /**
     * Limit how many MealPlans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MealPlan upsert
   */
  export type MealPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the MealPlan to update in case it exists.
     */
    where: MealPlanWhereUniqueInput
    /**
     * In case the MealPlan found by the `where` argument doesn't exist, create a new MealPlan with this data.
     */
    create: XOR<MealPlanCreateInput, MealPlanUncheckedCreateInput>
    /**
     * In case the MealPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MealPlanUpdateInput, MealPlanUncheckedUpdateInput>
  }

  /**
   * MealPlan delete
   */
  export type MealPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    /**
     * Filter which MealPlan to delete.
     */
    where: MealPlanWhereUniqueInput
  }

  /**
   * MealPlan deleteMany
   */
  export type MealPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MealPlans to delete
     */
    where?: MealPlanWhereInput
    /**
     * Limit how many MealPlans to delete.
     */
    limit?: number
  }

  /**
   * MealPlan.meals
   */
  export type MealPlan$mealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    where?: MealPlanItemWhereInput
    orderBy?: MealPlanItemOrderByWithRelationInput | MealPlanItemOrderByWithRelationInput[]
    cursor?: MealPlanItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MealPlanItemScalarFieldEnum | MealPlanItemScalarFieldEnum[]
  }

  /**
   * MealPlan.shoppingList
   */
  export type MealPlan$shoppingListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    where?: ShoppingListWhereInput
  }

  /**
   * MealPlan without action
   */
  export type MealPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
  }


  /**
   * Model MealPlanItem
   */

  export type AggregateMealPlanItem = {
    _count: MealPlanItemCountAggregateOutputType | null
    _avg: MealPlanItemAvgAggregateOutputType | null
    _sum: MealPlanItemSumAggregateOutputType | null
    _min: MealPlanItemMinAggregateOutputType | null
    _max: MealPlanItemMaxAggregateOutputType | null
  }

  export type MealPlanItemAvgAggregateOutputType = {
    servings: number | null
  }

  export type MealPlanItemSumAggregateOutputType = {
    servings: number | null
  }

  export type MealPlanItemMinAggregateOutputType = {
    id: string | null
    mealPlanId: string | null
    recipeId: string | null
    dayOfWeek: $Enums.DayOfWeek | null
    mealType: $Enums.MealType | null
    servings: number | null
  }

  export type MealPlanItemMaxAggregateOutputType = {
    id: string | null
    mealPlanId: string | null
    recipeId: string | null
    dayOfWeek: $Enums.DayOfWeek | null
    mealType: $Enums.MealType | null
    servings: number | null
  }

  export type MealPlanItemCountAggregateOutputType = {
    id: number
    mealPlanId: number
    recipeId: number
    dayOfWeek: number
    mealType: number
    servings: number
    _all: number
  }


  export type MealPlanItemAvgAggregateInputType = {
    servings?: true
  }

  export type MealPlanItemSumAggregateInputType = {
    servings?: true
  }

  export type MealPlanItemMinAggregateInputType = {
    id?: true
    mealPlanId?: true
    recipeId?: true
    dayOfWeek?: true
    mealType?: true
    servings?: true
  }

  export type MealPlanItemMaxAggregateInputType = {
    id?: true
    mealPlanId?: true
    recipeId?: true
    dayOfWeek?: true
    mealType?: true
    servings?: true
  }

  export type MealPlanItemCountAggregateInputType = {
    id?: true
    mealPlanId?: true
    recipeId?: true
    dayOfWeek?: true
    mealType?: true
    servings?: true
    _all?: true
  }

  export type MealPlanItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MealPlanItem to aggregate.
     */
    where?: MealPlanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlanItems to fetch.
     */
    orderBy?: MealPlanItemOrderByWithRelationInput | MealPlanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MealPlanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlanItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MealPlanItems
    **/
    _count?: true | MealPlanItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MealPlanItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MealPlanItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MealPlanItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MealPlanItemMaxAggregateInputType
  }

  export type GetMealPlanItemAggregateType<T extends MealPlanItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMealPlanItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMealPlanItem[P]>
      : GetScalarType<T[P], AggregateMealPlanItem[P]>
  }




  export type MealPlanItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealPlanItemWhereInput
    orderBy?: MealPlanItemOrderByWithAggregationInput | MealPlanItemOrderByWithAggregationInput[]
    by: MealPlanItemScalarFieldEnum[] | MealPlanItemScalarFieldEnum
    having?: MealPlanItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MealPlanItemCountAggregateInputType | true
    _avg?: MealPlanItemAvgAggregateInputType
    _sum?: MealPlanItemSumAggregateInputType
    _min?: MealPlanItemMinAggregateInputType
    _max?: MealPlanItemMaxAggregateInputType
  }

  export type MealPlanItemGroupByOutputType = {
    id: string
    mealPlanId: string
    recipeId: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings: number
    _count: MealPlanItemCountAggregateOutputType | null
    _avg: MealPlanItemAvgAggregateOutputType | null
    _sum: MealPlanItemSumAggregateOutputType | null
    _min: MealPlanItemMinAggregateOutputType | null
    _max: MealPlanItemMaxAggregateOutputType | null
  }

  type GetMealPlanItemGroupByPayload<T extends MealPlanItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MealPlanItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MealPlanItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MealPlanItemGroupByOutputType[P]>
            : GetScalarType<T[P], MealPlanItemGroupByOutputType[P]>
        }
      >
    >


  export type MealPlanItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mealPlanId?: boolean
    recipeId?: boolean
    dayOfWeek?: boolean
    mealType?: boolean
    servings?: boolean
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mealPlanItem"]>

  export type MealPlanItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mealPlanId?: boolean
    recipeId?: boolean
    dayOfWeek?: boolean
    mealType?: boolean
    servings?: boolean
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mealPlanItem"]>

  export type MealPlanItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mealPlanId?: boolean
    recipeId?: boolean
    dayOfWeek?: boolean
    mealType?: boolean
    servings?: boolean
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mealPlanItem"]>

  export type MealPlanItemSelectScalar = {
    id?: boolean
    mealPlanId?: boolean
    recipeId?: boolean
    dayOfWeek?: boolean
    mealType?: boolean
    servings?: boolean
  }

  export type MealPlanItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mealPlanId" | "recipeId" | "dayOfWeek" | "mealType" | "servings", ExtArgs["result"]["mealPlanItem"]>
  export type MealPlanItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type MealPlanItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type MealPlanItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mealPlan?: boolean | MealPlanDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $MealPlanItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MealPlanItem"
    objects: {
      mealPlan: Prisma.$MealPlanPayload<ExtArgs>
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mealPlanId: string
      recipeId: string
      dayOfWeek: $Enums.DayOfWeek
      mealType: $Enums.MealType
      servings: number
    }, ExtArgs["result"]["mealPlanItem"]>
    composites: {}
  }

  type MealPlanItemGetPayload<S extends boolean | null | undefined | MealPlanItemDefaultArgs> = $Result.GetResult<Prisma.$MealPlanItemPayload, S>

  type MealPlanItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MealPlanItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MealPlanItemCountAggregateInputType | true
    }

  export interface MealPlanItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MealPlanItem'], meta: { name: 'MealPlanItem' } }
    /**
     * Find zero or one MealPlanItem that matches the filter.
     * @param {MealPlanItemFindUniqueArgs} args - Arguments to find a MealPlanItem
     * @example
     * // Get one MealPlanItem
     * const mealPlanItem = await prisma.mealPlanItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MealPlanItemFindUniqueArgs>(args: SelectSubset<T, MealPlanItemFindUniqueArgs<ExtArgs>>): Prisma__MealPlanItemClient<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MealPlanItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MealPlanItemFindUniqueOrThrowArgs} args - Arguments to find a MealPlanItem
     * @example
     * // Get one MealPlanItem
     * const mealPlanItem = await prisma.mealPlanItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MealPlanItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MealPlanItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MealPlanItemClient<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MealPlanItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanItemFindFirstArgs} args - Arguments to find a MealPlanItem
     * @example
     * // Get one MealPlanItem
     * const mealPlanItem = await prisma.mealPlanItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MealPlanItemFindFirstArgs>(args?: SelectSubset<T, MealPlanItemFindFirstArgs<ExtArgs>>): Prisma__MealPlanItemClient<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MealPlanItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanItemFindFirstOrThrowArgs} args - Arguments to find a MealPlanItem
     * @example
     * // Get one MealPlanItem
     * const mealPlanItem = await prisma.mealPlanItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MealPlanItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MealPlanItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MealPlanItemClient<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MealPlanItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MealPlanItems
     * const mealPlanItems = await prisma.mealPlanItem.findMany()
     * 
     * // Get first 10 MealPlanItems
     * const mealPlanItems = await prisma.mealPlanItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mealPlanItemWithIdOnly = await prisma.mealPlanItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MealPlanItemFindManyArgs>(args?: SelectSubset<T, MealPlanItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MealPlanItem.
     * @param {MealPlanItemCreateArgs} args - Arguments to create a MealPlanItem.
     * @example
     * // Create one MealPlanItem
     * const MealPlanItem = await prisma.mealPlanItem.create({
     *   data: {
     *     // ... data to create a MealPlanItem
     *   }
     * })
     * 
     */
    create<T extends MealPlanItemCreateArgs>(args: SelectSubset<T, MealPlanItemCreateArgs<ExtArgs>>): Prisma__MealPlanItemClient<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MealPlanItems.
     * @param {MealPlanItemCreateManyArgs} args - Arguments to create many MealPlanItems.
     * @example
     * // Create many MealPlanItems
     * const mealPlanItem = await prisma.mealPlanItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MealPlanItemCreateManyArgs>(args?: SelectSubset<T, MealPlanItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MealPlanItems and returns the data saved in the database.
     * @param {MealPlanItemCreateManyAndReturnArgs} args - Arguments to create many MealPlanItems.
     * @example
     * // Create many MealPlanItems
     * const mealPlanItem = await prisma.mealPlanItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MealPlanItems and only return the `id`
     * const mealPlanItemWithIdOnly = await prisma.mealPlanItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MealPlanItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MealPlanItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MealPlanItem.
     * @param {MealPlanItemDeleteArgs} args - Arguments to delete one MealPlanItem.
     * @example
     * // Delete one MealPlanItem
     * const MealPlanItem = await prisma.mealPlanItem.delete({
     *   where: {
     *     // ... filter to delete one MealPlanItem
     *   }
     * })
     * 
     */
    delete<T extends MealPlanItemDeleteArgs>(args: SelectSubset<T, MealPlanItemDeleteArgs<ExtArgs>>): Prisma__MealPlanItemClient<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MealPlanItem.
     * @param {MealPlanItemUpdateArgs} args - Arguments to update one MealPlanItem.
     * @example
     * // Update one MealPlanItem
     * const mealPlanItem = await prisma.mealPlanItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MealPlanItemUpdateArgs>(args: SelectSubset<T, MealPlanItemUpdateArgs<ExtArgs>>): Prisma__MealPlanItemClient<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MealPlanItems.
     * @param {MealPlanItemDeleteManyArgs} args - Arguments to filter MealPlanItems to delete.
     * @example
     * // Delete a few MealPlanItems
     * const { count } = await prisma.mealPlanItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MealPlanItemDeleteManyArgs>(args?: SelectSubset<T, MealPlanItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MealPlanItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MealPlanItems
     * const mealPlanItem = await prisma.mealPlanItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MealPlanItemUpdateManyArgs>(args: SelectSubset<T, MealPlanItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MealPlanItems and returns the data updated in the database.
     * @param {MealPlanItemUpdateManyAndReturnArgs} args - Arguments to update many MealPlanItems.
     * @example
     * // Update many MealPlanItems
     * const mealPlanItem = await prisma.mealPlanItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MealPlanItems and only return the `id`
     * const mealPlanItemWithIdOnly = await prisma.mealPlanItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MealPlanItemUpdateManyAndReturnArgs>(args: SelectSubset<T, MealPlanItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MealPlanItem.
     * @param {MealPlanItemUpsertArgs} args - Arguments to update or create a MealPlanItem.
     * @example
     * // Update or create a MealPlanItem
     * const mealPlanItem = await prisma.mealPlanItem.upsert({
     *   create: {
     *     // ... data to create a MealPlanItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MealPlanItem we want to update
     *   }
     * })
     */
    upsert<T extends MealPlanItemUpsertArgs>(args: SelectSubset<T, MealPlanItemUpsertArgs<ExtArgs>>): Prisma__MealPlanItemClient<$Result.GetResult<Prisma.$MealPlanItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MealPlanItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanItemCountArgs} args - Arguments to filter MealPlanItems to count.
     * @example
     * // Count the number of MealPlanItems
     * const count = await prisma.mealPlanItem.count({
     *   where: {
     *     // ... the filter for the MealPlanItems we want to count
     *   }
     * })
    **/
    count<T extends MealPlanItemCountArgs>(
      args?: Subset<T, MealPlanItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MealPlanItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MealPlanItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MealPlanItemAggregateArgs>(args: Subset<T, MealPlanItemAggregateArgs>): Prisma.PrismaPromise<GetMealPlanItemAggregateType<T>>

    /**
     * Group by MealPlanItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealPlanItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MealPlanItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MealPlanItemGroupByArgs['orderBy'] }
        : { orderBy?: MealPlanItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MealPlanItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMealPlanItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MealPlanItem model
   */
  readonly fields: MealPlanItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MealPlanItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MealPlanItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mealPlan<T extends MealPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MealPlanDefaultArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MealPlanItem model
   */
  interface MealPlanItemFieldRefs {
    readonly id: FieldRef<"MealPlanItem", 'String'>
    readonly mealPlanId: FieldRef<"MealPlanItem", 'String'>
    readonly recipeId: FieldRef<"MealPlanItem", 'String'>
    readonly dayOfWeek: FieldRef<"MealPlanItem", 'DayOfWeek'>
    readonly mealType: FieldRef<"MealPlanItem", 'MealType'>
    readonly servings: FieldRef<"MealPlanItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MealPlanItem findUnique
   */
  export type MealPlanItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    /**
     * Filter, which MealPlanItem to fetch.
     */
    where: MealPlanItemWhereUniqueInput
  }

  /**
   * MealPlanItem findUniqueOrThrow
   */
  export type MealPlanItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    /**
     * Filter, which MealPlanItem to fetch.
     */
    where: MealPlanItemWhereUniqueInput
  }

  /**
   * MealPlanItem findFirst
   */
  export type MealPlanItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    /**
     * Filter, which MealPlanItem to fetch.
     */
    where?: MealPlanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlanItems to fetch.
     */
    orderBy?: MealPlanItemOrderByWithRelationInput | MealPlanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MealPlanItems.
     */
    cursor?: MealPlanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlanItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MealPlanItems.
     */
    distinct?: MealPlanItemScalarFieldEnum | MealPlanItemScalarFieldEnum[]
  }

  /**
   * MealPlanItem findFirstOrThrow
   */
  export type MealPlanItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    /**
     * Filter, which MealPlanItem to fetch.
     */
    where?: MealPlanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlanItems to fetch.
     */
    orderBy?: MealPlanItemOrderByWithRelationInput | MealPlanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MealPlanItems.
     */
    cursor?: MealPlanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlanItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MealPlanItems.
     */
    distinct?: MealPlanItemScalarFieldEnum | MealPlanItemScalarFieldEnum[]
  }

  /**
   * MealPlanItem findMany
   */
  export type MealPlanItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    /**
     * Filter, which MealPlanItems to fetch.
     */
    where?: MealPlanItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MealPlanItems to fetch.
     */
    orderBy?: MealPlanItemOrderByWithRelationInput | MealPlanItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MealPlanItems.
     */
    cursor?: MealPlanItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MealPlanItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MealPlanItems.
     */
    skip?: number
    distinct?: MealPlanItemScalarFieldEnum | MealPlanItemScalarFieldEnum[]
  }

  /**
   * MealPlanItem create
   */
  export type MealPlanItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MealPlanItem.
     */
    data: XOR<MealPlanItemCreateInput, MealPlanItemUncheckedCreateInput>
  }

  /**
   * MealPlanItem createMany
   */
  export type MealPlanItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MealPlanItems.
     */
    data: MealPlanItemCreateManyInput | MealPlanItemCreateManyInput[]
  }

  /**
   * MealPlanItem createManyAndReturn
   */
  export type MealPlanItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * The data used to create many MealPlanItems.
     */
    data: MealPlanItemCreateManyInput | MealPlanItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MealPlanItem update
   */
  export type MealPlanItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MealPlanItem.
     */
    data: XOR<MealPlanItemUpdateInput, MealPlanItemUncheckedUpdateInput>
    /**
     * Choose, which MealPlanItem to update.
     */
    where: MealPlanItemWhereUniqueInput
  }

  /**
   * MealPlanItem updateMany
   */
  export type MealPlanItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MealPlanItems.
     */
    data: XOR<MealPlanItemUpdateManyMutationInput, MealPlanItemUncheckedUpdateManyInput>
    /**
     * Filter which MealPlanItems to update
     */
    where?: MealPlanItemWhereInput
    /**
     * Limit how many MealPlanItems to update.
     */
    limit?: number
  }

  /**
   * MealPlanItem updateManyAndReturn
   */
  export type MealPlanItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * The data used to update MealPlanItems.
     */
    data: XOR<MealPlanItemUpdateManyMutationInput, MealPlanItemUncheckedUpdateManyInput>
    /**
     * Filter which MealPlanItems to update
     */
    where?: MealPlanItemWhereInput
    /**
     * Limit how many MealPlanItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MealPlanItem upsert
   */
  export type MealPlanItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MealPlanItem to update in case it exists.
     */
    where: MealPlanItemWhereUniqueInput
    /**
     * In case the MealPlanItem found by the `where` argument doesn't exist, create a new MealPlanItem with this data.
     */
    create: XOR<MealPlanItemCreateInput, MealPlanItemUncheckedCreateInput>
    /**
     * In case the MealPlanItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MealPlanItemUpdateInput, MealPlanItemUncheckedUpdateInput>
  }

  /**
   * MealPlanItem delete
   */
  export type MealPlanItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
    /**
     * Filter which MealPlanItem to delete.
     */
    where: MealPlanItemWhereUniqueInput
  }

  /**
   * MealPlanItem deleteMany
   */
  export type MealPlanItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MealPlanItems to delete
     */
    where?: MealPlanItemWhereInput
    /**
     * Limit how many MealPlanItems to delete.
     */
    limit?: number
  }

  /**
   * MealPlanItem without action
   */
  export type MealPlanItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlanItem
     */
    select?: MealPlanItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlanItem
     */
    omit?: MealPlanItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanItemInclude<ExtArgs> | null
  }


  /**
   * Model ShoppingList
   */

  export type AggregateShoppingList = {
    _count: ShoppingListCountAggregateOutputType | null
    _min: ShoppingListMinAggregateOutputType | null
    _max: ShoppingListMaxAggregateOutputType | null
  }

  export type ShoppingListMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mealPlanId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShoppingListMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mealPlanId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShoppingListCountAggregateOutputType = {
    id: number
    userId: number
    mealPlanId: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShoppingListMinAggregateInputType = {
    id?: true
    userId?: true
    mealPlanId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShoppingListMaxAggregateInputType = {
    id?: true
    userId?: true
    mealPlanId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShoppingListCountAggregateInputType = {
    id?: true
    userId?: true
    mealPlanId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShoppingListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShoppingList to aggregate.
     */
    where?: ShoppingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingLists to fetch.
     */
    orderBy?: ShoppingListOrderByWithRelationInput | ShoppingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShoppingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShoppingLists
    **/
    _count?: true | ShoppingListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShoppingListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShoppingListMaxAggregateInputType
  }

  export type GetShoppingListAggregateType<T extends ShoppingListAggregateArgs> = {
        [P in keyof T & keyof AggregateShoppingList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShoppingList[P]>
      : GetScalarType<T[P], AggregateShoppingList[P]>
  }




  export type ShoppingListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShoppingListWhereInput
    orderBy?: ShoppingListOrderByWithAggregationInput | ShoppingListOrderByWithAggregationInput[]
    by: ShoppingListScalarFieldEnum[] | ShoppingListScalarFieldEnum
    having?: ShoppingListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShoppingListCountAggregateInputType | true
    _min?: ShoppingListMinAggregateInputType
    _max?: ShoppingListMaxAggregateInputType
  }

  export type ShoppingListGroupByOutputType = {
    id: string
    userId: string
    mealPlanId: string | null
    name: string
    createdAt: Date
    updatedAt: Date
    _count: ShoppingListCountAggregateOutputType | null
    _min: ShoppingListMinAggregateOutputType | null
    _max: ShoppingListMaxAggregateOutputType | null
  }

  type GetShoppingListGroupByPayload<T extends ShoppingListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShoppingListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShoppingListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShoppingListGroupByOutputType[P]>
            : GetScalarType<T[P], ShoppingListGroupByOutputType[P]>
        }
      >
    >


  export type ShoppingListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mealPlanId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mealPlan?: boolean | ShoppingList$mealPlanArgs<ExtArgs>
    items?: boolean | ShoppingList$itemsArgs<ExtArgs>
    _count?: boolean | ShoppingListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shoppingList"]>

  export type ShoppingListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mealPlanId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mealPlan?: boolean | ShoppingList$mealPlanArgs<ExtArgs>
  }, ExtArgs["result"]["shoppingList"]>

  export type ShoppingListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mealPlanId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mealPlan?: boolean | ShoppingList$mealPlanArgs<ExtArgs>
  }, ExtArgs["result"]["shoppingList"]>

  export type ShoppingListSelectScalar = {
    id?: boolean
    userId?: boolean
    mealPlanId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShoppingListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mealPlanId" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["shoppingList"]>
  export type ShoppingListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mealPlan?: boolean | ShoppingList$mealPlanArgs<ExtArgs>
    items?: boolean | ShoppingList$itemsArgs<ExtArgs>
    _count?: boolean | ShoppingListCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShoppingListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mealPlan?: boolean | ShoppingList$mealPlanArgs<ExtArgs>
  }
  export type ShoppingListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mealPlan?: boolean | ShoppingList$mealPlanArgs<ExtArgs>
  }

  export type $ShoppingListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShoppingList"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      mealPlan: Prisma.$MealPlanPayload<ExtArgs> | null
      items: Prisma.$ShoppingListItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mealPlanId: string | null
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shoppingList"]>
    composites: {}
  }

  type ShoppingListGetPayload<S extends boolean | null | undefined | ShoppingListDefaultArgs> = $Result.GetResult<Prisma.$ShoppingListPayload, S>

  type ShoppingListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShoppingListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShoppingListCountAggregateInputType | true
    }

  export interface ShoppingListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShoppingList'], meta: { name: 'ShoppingList' } }
    /**
     * Find zero or one ShoppingList that matches the filter.
     * @param {ShoppingListFindUniqueArgs} args - Arguments to find a ShoppingList
     * @example
     * // Get one ShoppingList
     * const shoppingList = await prisma.shoppingList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShoppingListFindUniqueArgs>(args: SelectSubset<T, ShoppingListFindUniqueArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShoppingList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShoppingListFindUniqueOrThrowArgs} args - Arguments to find a ShoppingList
     * @example
     * // Get one ShoppingList
     * const shoppingList = await prisma.shoppingList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShoppingListFindUniqueOrThrowArgs>(args: SelectSubset<T, ShoppingListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShoppingList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListFindFirstArgs} args - Arguments to find a ShoppingList
     * @example
     * // Get one ShoppingList
     * const shoppingList = await prisma.shoppingList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShoppingListFindFirstArgs>(args?: SelectSubset<T, ShoppingListFindFirstArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShoppingList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListFindFirstOrThrowArgs} args - Arguments to find a ShoppingList
     * @example
     * // Get one ShoppingList
     * const shoppingList = await prisma.shoppingList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShoppingListFindFirstOrThrowArgs>(args?: SelectSubset<T, ShoppingListFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShoppingLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShoppingLists
     * const shoppingLists = await prisma.shoppingList.findMany()
     * 
     * // Get first 10 ShoppingLists
     * const shoppingLists = await prisma.shoppingList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shoppingListWithIdOnly = await prisma.shoppingList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShoppingListFindManyArgs>(args?: SelectSubset<T, ShoppingListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShoppingList.
     * @param {ShoppingListCreateArgs} args - Arguments to create a ShoppingList.
     * @example
     * // Create one ShoppingList
     * const ShoppingList = await prisma.shoppingList.create({
     *   data: {
     *     // ... data to create a ShoppingList
     *   }
     * })
     * 
     */
    create<T extends ShoppingListCreateArgs>(args: SelectSubset<T, ShoppingListCreateArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShoppingLists.
     * @param {ShoppingListCreateManyArgs} args - Arguments to create many ShoppingLists.
     * @example
     * // Create many ShoppingLists
     * const shoppingList = await prisma.shoppingList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShoppingListCreateManyArgs>(args?: SelectSubset<T, ShoppingListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShoppingLists and returns the data saved in the database.
     * @param {ShoppingListCreateManyAndReturnArgs} args - Arguments to create many ShoppingLists.
     * @example
     * // Create many ShoppingLists
     * const shoppingList = await prisma.shoppingList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShoppingLists and only return the `id`
     * const shoppingListWithIdOnly = await prisma.shoppingList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShoppingListCreateManyAndReturnArgs>(args?: SelectSubset<T, ShoppingListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShoppingList.
     * @param {ShoppingListDeleteArgs} args - Arguments to delete one ShoppingList.
     * @example
     * // Delete one ShoppingList
     * const ShoppingList = await prisma.shoppingList.delete({
     *   where: {
     *     // ... filter to delete one ShoppingList
     *   }
     * })
     * 
     */
    delete<T extends ShoppingListDeleteArgs>(args: SelectSubset<T, ShoppingListDeleteArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShoppingList.
     * @param {ShoppingListUpdateArgs} args - Arguments to update one ShoppingList.
     * @example
     * // Update one ShoppingList
     * const shoppingList = await prisma.shoppingList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShoppingListUpdateArgs>(args: SelectSubset<T, ShoppingListUpdateArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShoppingLists.
     * @param {ShoppingListDeleteManyArgs} args - Arguments to filter ShoppingLists to delete.
     * @example
     * // Delete a few ShoppingLists
     * const { count } = await prisma.shoppingList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShoppingListDeleteManyArgs>(args?: SelectSubset<T, ShoppingListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoppingLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShoppingLists
     * const shoppingList = await prisma.shoppingList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShoppingListUpdateManyArgs>(args: SelectSubset<T, ShoppingListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoppingLists and returns the data updated in the database.
     * @param {ShoppingListUpdateManyAndReturnArgs} args - Arguments to update many ShoppingLists.
     * @example
     * // Update many ShoppingLists
     * const shoppingList = await prisma.shoppingList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShoppingLists and only return the `id`
     * const shoppingListWithIdOnly = await prisma.shoppingList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShoppingListUpdateManyAndReturnArgs>(args: SelectSubset<T, ShoppingListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShoppingList.
     * @param {ShoppingListUpsertArgs} args - Arguments to update or create a ShoppingList.
     * @example
     * // Update or create a ShoppingList
     * const shoppingList = await prisma.shoppingList.upsert({
     *   create: {
     *     // ... data to create a ShoppingList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShoppingList we want to update
     *   }
     * })
     */
    upsert<T extends ShoppingListUpsertArgs>(args: SelectSubset<T, ShoppingListUpsertArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShoppingLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListCountArgs} args - Arguments to filter ShoppingLists to count.
     * @example
     * // Count the number of ShoppingLists
     * const count = await prisma.shoppingList.count({
     *   where: {
     *     // ... the filter for the ShoppingLists we want to count
     *   }
     * })
    **/
    count<T extends ShoppingListCountArgs>(
      args?: Subset<T, ShoppingListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoppingListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShoppingList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoppingListAggregateArgs>(args: Subset<T, ShoppingListAggregateArgs>): Prisma.PrismaPromise<GetShoppingListAggregateType<T>>

    /**
     * Group by ShoppingList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShoppingListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShoppingListGroupByArgs['orderBy'] }
        : { orderBy?: ShoppingListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShoppingListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShoppingListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShoppingList model
   */
  readonly fields: ShoppingListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShoppingList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShoppingListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mealPlan<T extends ShoppingList$mealPlanArgs<ExtArgs> = {}>(args?: Subset<T, ShoppingList$mealPlanArgs<ExtArgs>>): Prisma__MealPlanClient<$Result.GetResult<Prisma.$MealPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends ShoppingList$itemsArgs<ExtArgs> = {}>(args?: Subset<T, ShoppingList$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShoppingList model
   */
  interface ShoppingListFieldRefs {
    readonly id: FieldRef<"ShoppingList", 'String'>
    readonly userId: FieldRef<"ShoppingList", 'String'>
    readonly mealPlanId: FieldRef<"ShoppingList", 'String'>
    readonly name: FieldRef<"ShoppingList", 'String'>
    readonly createdAt: FieldRef<"ShoppingList", 'DateTime'>
    readonly updatedAt: FieldRef<"ShoppingList", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShoppingList findUnique
   */
  export type ShoppingListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingList to fetch.
     */
    where: ShoppingListWhereUniqueInput
  }

  /**
   * ShoppingList findUniqueOrThrow
   */
  export type ShoppingListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingList to fetch.
     */
    where: ShoppingListWhereUniqueInput
  }

  /**
   * ShoppingList findFirst
   */
  export type ShoppingListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingList to fetch.
     */
    where?: ShoppingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingLists to fetch.
     */
    orderBy?: ShoppingListOrderByWithRelationInput | ShoppingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingLists.
     */
    cursor?: ShoppingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingLists.
     */
    distinct?: ShoppingListScalarFieldEnum | ShoppingListScalarFieldEnum[]
  }

  /**
   * ShoppingList findFirstOrThrow
   */
  export type ShoppingListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingList to fetch.
     */
    where?: ShoppingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingLists to fetch.
     */
    orderBy?: ShoppingListOrderByWithRelationInput | ShoppingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingLists.
     */
    cursor?: ShoppingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingLists.
     */
    distinct?: ShoppingListScalarFieldEnum | ShoppingListScalarFieldEnum[]
  }

  /**
   * ShoppingList findMany
   */
  export type ShoppingListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingLists to fetch.
     */
    where?: ShoppingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingLists to fetch.
     */
    orderBy?: ShoppingListOrderByWithRelationInput | ShoppingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShoppingLists.
     */
    cursor?: ShoppingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingLists.
     */
    skip?: number
    distinct?: ShoppingListScalarFieldEnum | ShoppingListScalarFieldEnum[]
  }

  /**
   * ShoppingList create
   */
  export type ShoppingListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    /**
     * The data needed to create a ShoppingList.
     */
    data: XOR<ShoppingListCreateInput, ShoppingListUncheckedCreateInput>
  }

  /**
   * ShoppingList createMany
   */
  export type ShoppingListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShoppingLists.
     */
    data: ShoppingListCreateManyInput | ShoppingListCreateManyInput[]
  }

  /**
   * ShoppingList createManyAndReturn
   */
  export type ShoppingListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * The data used to create many ShoppingLists.
     */
    data: ShoppingListCreateManyInput | ShoppingListCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShoppingList update
   */
  export type ShoppingListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    /**
     * The data needed to update a ShoppingList.
     */
    data: XOR<ShoppingListUpdateInput, ShoppingListUncheckedUpdateInput>
    /**
     * Choose, which ShoppingList to update.
     */
    where: ShoppingListWhereUniqueInput
  }

  /**
   * ShoppingList updateMany
   */
  export type ShoppingListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShoppingLists.
     */
    data: XOR<ShoppingListUpdateManyMutationInput, ShoppingListUncheckedUpdateManyInput>
    /**
     * Filter which ShoppingLists to update
     */
    where?: ShoppingListWhereInput
    /**
     * Limit how many ShoppingLists to update.
     */
    limit?: number
  }

  /**
   * ShoppingList updateManyAndReturn
   */
  export type ShoppingListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * The data used to update ShoppingLists.
     */
    data: XOR<ShoppingListUpdateManyMutationInput, ShoppingListUncheckedUpdateManyInput>
    /**
     * Filter which ShoppingLists to update
     */
    where?: ShoppingListWhereInput
    /**
     * Limit how many ShoppingLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShoppingList upsert
   */
  export type ShoppingListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    /**
     * The filter to search for the ShoppingList to update in case it exists.
     */
    where: ShoppingListWhereUniqueInput
    /**
     * In case the ShoppingList found by the `where` argument doesn't exist, create a new ShoppingList with this data.
     */
    create: XOR<ShoppingListCreateInput, ShoppingListUncheckedCreateInput>
    /**
     * In case the ShoppingList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShoppingListUpdateInput, ShoppingListUncheckedUpdateInput>
  }

  /**
   * ShoppingList delete
   */
  export type ShoppingListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
    /**
     * Filter which ShoppingList to delete.
     */
    where: ShoppingListWhereUniqueInput
  }

  /**
   * ShoppingList deleteMany
   */
  export type ShoppingListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShoppingLists to delete
     */
    where?: ShoppingListWhereInput
    /**
     * Limit how many ShoppingLists to delete.
     */
    limit?: number
  }

  /**
   * ShoppingList.mealPlan
   */
  export type ShoppingList$mealPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealPlan
     */
    select?: MealPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MealPlan
     */
    omit?: MealPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealPlanInclude<ExtArgs> | null
    where?: MealPlanWhereInput
  }

  /**
   * ShoppingList.items
   */
  export type ShoppingList$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    where?: ShoppingListItemWhereInput
    orderBy?: ShoppingListItemOrderByWithRelationInput | ShoppingListItemOrderByWithRelationInput[]
    cursor?: ShoppingListItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShoppingListItemScalarFieldEnum | ShoppingListItemScalarFieldEnum[]
  }

  /**
   * ShoppingList without action
   */
  export type ShoppingListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingList
     */
    select?: ShoppingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingList
     */
    omit?: ShoppingListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListInclude<ExtArgs> | null
  }


  /**
   * Model ShoppingListItem
   */

  export type AggregateShoppingListItem = {
    _count: ShoppingListItemCountAggregateOutputType | null
    _avg: ShoppingListItemAvgAggregateOutputType | null
    _sum: ShoppingListItemSumAggregateOutputType | null
    _min: ShoppingListItemMinAggregateOutputType | null
    _max: ShoppingListItemMaxAggregateOutputType | null
  }

  export type ShoppingListItemAvgAggregateOutputType = {
    amount: number | null
    estimatedPrice: number | null
  }

  export type ShoppingListItemSumAggregateOutputType = {
    amount: number | null
    estimatedPrice: number | null
  }

  export type ShoppingListItemMinAggregateOutputType = {
    id: string | null
    shoppingListId: string | null
    name: string | null
    amount: number | null
    unit: string | null
    category: string | null
    purchased: boolean | null
    estimatedPrice: number | null
  }

  export type ShoppingListItemMaxAggregateOutputType = {
    id: string | null
    shoppingListId: string | null
    name: string | null
    amount: number | null
    unit: string | null
    category: string | null
    purchased: boolean | null
    estimatedPrice: number | null
  }

  export type ShoppingListItemCountAggregateOutputType = {
    id: number
    shoppingListId: number
    name: number
    amount: number
    unit: number
    category: number
    purchased: number
    estimatedPrice: number
    _all: number
  }


  export type ShoppingListItemAvgAggregateInputType = {
    amount?: true
    estimatedPrice?: true
  }

  export type ShoppingListItemSumAggregateInputType = {
    amount?: true
    estimatedPrice?: true
  }

  export type ShoppingListItemMinAggregateInputType = {
    id?: true
    shoppingListId?: true
    name?: true
    amount?: true
    unit?: true
    category?: true
    purchased?: true
    estimatedPrice?: true
  }

  export type ShoppingListItemMaxAggregateInputType = {
    id?: true
    shoppingListId?: true
    name?: true
    amount?: true
    unit?: true
    category?: true
    purchased?: true
    estimatedPrice?: true
  }

  export type ShoppingListItemCountAggregateInputType = {
    id?: true
    shoppingListId?: true
    name?: true
    amount?: true
    unit?: true
    category?: true
    purchased?: true
    estimatedPrice?: true
    _all?: true
  }

  export type ShoppingListItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShoppingListItem to aggregate.
     */
    where?: ShoppingListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingListItems to fetch.
     */
    orderBy?: ShoppingListItemOrderByWithRelationInput | ShoppingListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShoppingListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShoppingListItems
    **/
    _count?: true | ShoppingListItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShoppingListItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShoppingListItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShoppingListItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShoppingListItemMaxAggregateInputType
  }

  export type GetShoppingListItemAggregateType<T extends ShoppingListItemAggregateArgs> = {
        [P in keyof T & keyof AggregateShoppingListItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShoppingListItem[P]>
      : GetScalarType<T[P], AggregateShoppingListItem[P]>
  }




  export type ShoppingListItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShoppingListItemWhereInput
    orderBy?: ShoppingListItemOrderByWithAggregationInput | ShoppingListItemOrderByWithAggregationInput[]
    by: ShoppingListItemScalarFieldEnum[] | ShoppingListItemScalarFieldEnum
    having?: ShoppingListItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShoppingListItemCountAggregateInputType | true
    _avg?: ShoppingListItemAvgAggregateInputType
    _sum?: ShoppingListItemSumAggregateInputType
    _min?: ShoppingListItemMinAggregateInputType
    _max?: ShoppingListItemMaxAggregateInputType
  }

  export type ShoppingListItemGroupByOutputType = {
    id: string
    shoppingListId: string
    name: string
    amount: number
    unit: string
    category: string | null
    purchased: boolean
    estimatedPrice: number | null
    _count: ShoppingListItemCountAggregateOutputType | null
    _avg: ShoppingListItemAvgAggregateOutputType | null
    _sum: ShoppingListItemSumAggregateOutputType | null
    _min: ShoppingListItemMinAggregateOutputType | null
    _max: ShoppingListItemMaxAggregateOutputType | null
  }

  type GetShoppingListItemGroupByPayload<T extends ShoppingListItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShoppingListItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShoppingListItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShoppingListItemGroupByOutputType[P]>
            : GetScalarType<T[P], ShoppingListItemGroupByOutputType[P]>
        }
      >
    >


  export type ShoppingListItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shoppingListId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    category?: boolean
    purchased?: boolean
    estimatedPrice?: boolean
    shoppingList?: boolean | ShoppingListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shoppingListItem"]>

  export type ShoppingListItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shoppingListId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    category?: boolean
    purchased?: boolean
    estimatedPrice?: boolean
    shoppingList?: boolean | ShoppingListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shoppingListItem"]>

  export type ShoppingListItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shoppingListId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    category?: boolean
    purchased?: boolean
    estimatedPrice?: boolean
    shoppingList?: boolean | ShoppingListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shoppingListItem"]>

  export type ShoppingListItemSelectScalar = {
    id?: boolean
    shoppingListId?: boolean
    name?: boolean
    amount?: boolean
    unit?: boolean
    category?: boolean
    purchased?: boolean
    estimatedPrice?: boolean
  }

  export type ShoppingListItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shoppingListId" | "name" | "amount" | "unit" | "category" | "purchased" | "estimatedPrice", ExtArgs["result"]["shoppingListItem"]>
  export type ShoppingListItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shoppingList?: boolean | ShoppingListDefaultArgs<ExtArgs>
  }
  export type ShoppingListItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shoppingList?: boolean | ShoppingListDefaultArgs<ExtArgs>
  }
  export type ShoppingListItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shoppingList?: boolean | ShoppingListDefaultArgs<ExtArgs>
  }

  export type $ShoppingListItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShoppingListItem"
    objects: {
      shoppingList: Prisma.$ShoppingListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shoppingListId: string
      name: string
      amount: number
      unit: string
      category: string | null
      purchased: boolean
      estimatedPrice: number | null
    }, ExtArgs["result"]["shoppingListItem"]>
    composites: {}
  }

  type ShoppingListItemGetPayload<S extends boolean | null | undefined | ShoppingListItemDefaultArgs> = $Result.GetResult<Prisma.$ShoppingListItemPayload, S>

  type ShoppingListItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShoppingListItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShoppingListItemCountAggregateInputType | true
    }

  export interface ShoppingListItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShoppingListItem'], meta: { name: 'ShoppingListItem' } }
    /**
     * Find zero or one ShoppingListItem that matches the filter.
     * @param {ShoppingListItemFindUniqueArgs} args - Arguments to find a ShoppingListItem
     * @example
     * // Get one ShoppingListItem
     * const shoppingListItem = await prisma.shoppingListItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShoppingListItemFindUniqueArgs>(args: SelectSubset<T, ShoppingListItemFindUniqueArgs<ExtArgs>>): Prisma__ShoppingListItemClient<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShoppingListItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShoppingListItemFindUniqueOrThrowArgs} args - Arguments to find a ShoppingListItem
     * @example
     * // Get one ShoppingListItem
     * const shoppingListItem = await prisma.shoppingListItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShoppingListItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ShoppingListItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShoppingListItemClient<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShoppingListItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListItemFindFirstArgs} args - Arguments to find a ShoppingListItem
     * @example
     * // Get one ShoppingListItem
     * const shoppingListItem = await prisma.shoppingListItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShoppingListItemFindFirstArgs>(args?: SelectSubset<T, ShoppingListItemFindFirstArgs<ExtArgs>>): Prisma__ShoppingListItemClient<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShoppingListItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListItemFindFirstOrThrowArgs} args - Arguments to find a ShoppingListItem
     * @example
     * // Get one ShoppingListItem
     * const shoppingListItem = await prisma.shoppingListItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShoppingListItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ShoppingListItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShoppingListItemClient<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShoppingListItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShoppingListItems
     * const shoppingListItems = await prisma.shoppingListItem.findMany()
     * 
     * // Get first 10 ShoppingListItems
     * const shoppingListItems = await prisma.shoppingListItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shoppingListItemWithIdOnly = await prisma.shoppingListItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShoppingListItemFindManyArgs>(args?: SelectSubset<T, ShoppingListItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShoppingListItem.
     * @param {ShoppingListItemCreateArgs} args - Arguments to create a ShoppingListItem.
     * @example
     * // Create one ShoppingListItem
     * const ShoppingListItem = await prisma.shoppingListItem.create({
     *   data: {
     *     // ... data to create a ShoppingListItem
     *   }
     * })
     * 
     */
    create<T extends ShoppingListItemCreateArgs>(args: SelectSubset<T, ShoppingListItemCreateArgs<ExtArgs>>): Prisma__ShoppingListItemClient<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShoppingListItems.
     * @param {ShoppingListItemCreateManyArgs} args - Arguments to create many ShoppingListItems.
     * @example
     * // Create many ShoppingListItems
     * const shoppingListItem = await prisma.shoppingListItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShoppingListItemCreateManyArgs>(args?: SelectSubset<T, ShoppingListItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShoppingListItems and returns the data saved in the database.
     * @param {ShoppingListItemCreateManyAndReturnArgs} args - Arguments to create many ShoppingListItems.
     * @example
     * // Create many ShoppingListItems
     * const shoppingListItem = await prisma.shoppingListItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShoppingListItems and only return the `id`
     * const shoppingListItemWithIdOnly = await prisma.shoppingListItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShoppingListItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ShoppingListItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShoppingListItem.
     * @param {ShoppingListItemDeleteArgs} args - Arguments to delete one ShoppingListItem.
     * @example
     * // Delete one ShoppingListItem
     * const ShoppingListItem = await prisma.shoppingListItem.delete({
     *   where: {
     *     // ... filter to delete one ShoppingListItem
     *   }
     * })
     * 
     */
    delete<T extends ShoppingListItemDeleteArgs>(args: SelectSubset<T, ShoppingListItemDeleteArgs<ExtArgs>>): Prisma__ShoppingListItemClient<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShoppingListItem.
     * @param {ShoppingListItemUpdateArgs} args - Arguments to update one ShoppingListItem.
     * @example
     * // Update one ShoppingListItem
     * const shoppingListItem = await prisma.shoppingListItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShoppingListItemUpdateArgs>(args: SelectSubset<T, ShoppingListItemUpdateArgs<ExtArgs>>): Prisma__ShoppingListItemClient<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShoppingListItems.
     * @param {ShoppingListItemDeleteManyArgs} args - Arguments to filter ShoppingListItems to delete.
     * @example
     * // Delete a few ShoppingListItems
     * const { count } = await prisma.shoppingListItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShoppingListItemDeleteManyArgs>(args?: SelectSubset<T, ShoppingListItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoppingListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShoppingListItems
     * const shoppingListItem = await prisma.shoppingListItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShoppingListItemUpdateManyArgs>(args: SelectSubset<T, ShoppingListItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoppingListItems and returns the data updated in the database.
     * @param {ShoppingListItemUpdateManyAndReturnArgs} args - Arguments to update many ShoppingListItems.
     * @example
     * // Update many ShoppingListItems
     * const shoppingListItem = await prisma.shoppingListItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShoppingListItems and only return the `id`
     * const shoppingListItemWithIdOnly = await prisma.shoppingListItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShoppingListItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ShoppingListItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShoppingListItem.
     * @param {ShoppingListItemUpsertArgs} args - Arguments to update or create a ShoppingListItem.
     * @example
     * // Update or create a ShoppingListItem
     * const shoppingListItem = await prisma.shoppingListItem.upsert({
     *   create: {
     *     // ... data to create a ShoppingListItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShoppingListItem we want to update
     *   }
     * })
     */
    upsert<T extends ShoppingListItemUpsertArgs>(args: SelectSubset<T, ShoppingListItemUpsertArgs<ExtArgs>>): Prisma__ShoppingListItemClient<$Result.GetResult<Prisma.$ShoppingListItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShoppingListItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListItemCountArgs} args - Arguments to filter ShoppingListItems to count.
     * @example
     * // Count the number of ShoppingListItems
     * const count = await prisma.shoppingListItem.count({
     *   where: {
     *     // ... the filter for the ShoppingListItems we want to count
     *   }
     * })
    **/
    count<T extends ShoppingListItemCountArgs>(
      args?: Subset<T, ShoppingListItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoppingListItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShoppingListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoppingListItemAggregateArgs>(args: Subset<T, ShoppingListItemAggregateArgs>): Prisma.PrismaPromise<GetShoppingListItemAggregateType<T>>

    /**
     * Group by ShoppingListItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingListItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShoppingListItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShoppingListItemGroupByArgs['orderBy'] }
        : { orderBy?: ShoppingListItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShoppingListItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShoppingListItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShoppingListItem model
   */
  readonly fields: ShoppingListItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShoppingListItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShoppingListItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shoppingList<T extends ShoppingListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShoppingListDefaultArgs<ExtArgs>>): Prisma__ShoppingListClient<$Result.GetResult<Prisma.$ShoppingListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShoppingListItem model
   */
  interface ShoppingListItemFieldRefs {
    readonly id: FieldRef<"ShoppingListItem", 'String'>
    readonly shoppingListId: FieldRef<"ShoppingListItem", 'String'>
    readonly name: FieldRef<"ShoppingListItem", 'String'>
    readonly amount: FieldRef<"ShoppingListItem", 'Float'>
    readonly unit: FieldRef<"ShoppingListItem", 'String'>
    readonly category: FieldRef<"ShoppingListItem", 'String'>
    readonly purchased: FieldRef<"ShoppingListItem", 'Boolean'>
    readonly estimatedPrice: FieldRef<"ShoppingListItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ShoppingListItem findUnique
   */
  export type ShoppingListItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingListItem to fetch.
     */
    where: ShoppingListItemWhereUniqueInput
  }

  /**
   * ShoppingListItem findUniqueOrThrow
   */
  export type ShoppingListItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingListItem to fetch.
     */
    where: ShoppingListItemWhereUniqueInput
  }

  /**
   * ShoppingListItem findFirst
   */
  export type ShoppingListItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingListItem to fetch.
     */
    where?: ShoppingListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingListItems to fetch.
     */
    orderBy?: ShoppingListItemOrderByWithRelationInput | ShoppingListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingListItems.
     */
    cursor?: ShoppingListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingListItems.
     */
    distinct?: ShoppingListItemScalarFieldEnum | ShoppingListItemScalarFieldEnum[]
  }

  /**
   * ShoppingListItem findFirstOrThrow
   */
  export type ShoppingListItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingListItem to fetch.
     */
    where?: ShoppingListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingListItems to fetch.
     */
    orderBy?: ShoppingListItemOrderByWithRelationInput | ShoppingListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingListItems.
     */
    cursor?: ShoppingListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingListItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingListItems.
     */
    distinct?: ShoppingListItemScalarFieldEnum | ShoppingListItemScalarFieldEnum[]
  }

  /**
   * ShoppingListItem findMany
   */
  export type ShoppingListItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    /**
     * Filter, which ShoppingListItems to fetch.
     */
    where?: ShoppingListItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingListItems to fetch.
     */
    orderBy?: ShoppingListItemOrderByWithRelationInput | ShoppingListItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShoppingListItems.
     */
    cursor?: ShoppingListItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingListItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingListItems.
     */
    skip?: number
    distinct?: ShoppingListItemScalarFieldEnum | ShoppingListItemScalarFieldEnum[]
  }

  /**
   * ShoppingListItem create
   */
  export type ShoppingListItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ShoppingListItem.
     */
    data: XOR<ShoppingListItemCreateInput, ShoppingListItemUncheckedCreateInput>
  }

  /**
   * ShoppingListItem createMany
   */
  export type ShoppingListItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShoppingListItems.
     */
    data: ShoppingListItemCreateManyInput | ShoppingListItemCreateManyInput[]
  }

  /**
   * ShoppingListItem createManyAndReturn
   */
  export type ShoppingListItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * The data used to create many ShoppingListItems.
     */
    data: ShoppingListItemCreateManyInput | ShoppingListItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShoppingListItem update
   */
  export type ShoppingListItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ShoppingListItem.
     */
    data: XOR<ShoppingListItemUpdateInput, ShoppingListItemUncheckedUpdateInput>
    /**
     * Choose, which ShoppingListItem to update.
     */
    where: ShoppingListItemWhereUniqueInput
  }

  /**
   * ShoppingListItem updateMany
   */
  export type ShoppingListItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShoppingListItems.
     */
    data: XOR<ShoppingListItemUpdateManyMutationInput, ShoppingListItemUncheckedUpdateManyInput>
    /**
     * Filter which ShoppingListItems to update
     */
    where?: ShoppingListItemWhereInput
    /**
     * Limit how many ShoppingListItems to update.
     */
    limit?: number
  }

  /**
   * ShoppingListItem updateManyAndReturn
   */
  export type ShoppingListItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * The data used to update ShoppingListItems.
     */
    data: XOR<ShoppingListItemUpdateManyMutationInput, ShoppingListItemUncheckedUpdateManyInput>
    /**
     * Filter which ShoppingListItems to update
     */
    where?: ShoppingListItemWhereInput
    /**
     * Limit how many ShoppingListItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShoppingListItem upsert
   */
  export type ShoppingListItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ShoppingListItem to update in case it exists.
     */
    where: ShoppingListItemWhereUniqueInput
    /**
     * In case the ShoppingListItem found by the `where` argument doesn't exist, create a new ShoppingListItem with this data.
     */
    create: XOR<ShoppingListItemCreateInput, ShoppingListItemUncheckedCreateInput>
    /**
     * In case the ShoppingListItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShoppingListItemUpdateInput, ShoppingListItemUncheckedUpdateInput>
  }

  /**
   * ShoppingListItem delete
   */
  export type ShoppingListItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
    /**
     * Filter which ShoppingListItem to delete.
     */
    where: ShoppingListItemWhereUniqueInput
  }

  /**
   * ShoppingListItem deleteMany
   */
  export type ShoppingListItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShoppingListItems to delete
     */
    where?: ShoppingListItemWhereInput
    /**
     * Limit how many ShoppingListItems to delete.
     */
    limit?: number
  }

  /**
   * ShoppingListItem without action
   */
  export type ShoppingListItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShoppingListItem
     */
    select?: ShoppingListItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShoppingListItem
     */
    omit?: ShoppingListItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShoppingListItemInclude<ExtArgs> | null
  }


  /**
   * Model UserFavoriteRecipe
   */

  export type AggregateUserFavoriteRecipe = {
    _count: UserFavoriteRecipeCountAggregateOutputType | null
    _min: UserFavoriteRecipeMinAggregateOutputType | null
    _max: UserFavoriteRecipeMaxAggregateOutputType | null
  }

  export type UserFavoriteRecipeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    recipeId: string | null
    addedAt: Date | null
  }

  export type UserFavoriteRecipeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    recipeId: string | null
    addedAt: Date | null
  }

  export type UserFavoriteRecipeCountAggregateOutputType = {
    id: number
    userId: number
    recipeId: number
    addedAt: number
    _all: number
  }


  export type UserFavoriteRecipeMinAggregateInputType = {
    id?: true
    userId?: true
    recipeId?: true
    addedAt?: true
  }

  export type UserFavoriteRecipeMaxAggregateInputType = {
    id?: true
    userId?: true
    recipeId?: true
    addedAt?: true
  }

  export type UserFavoriteRecipeCountAggregateInputType = {
    id?: true
    userId?: true
    recipeId?: true
    addedAt?: true
    _all?: true
  }

  export type UserFavoriteRecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavoriteRecipe to aggregate.
     */
    where?: UserFavoriteRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavoriteRecipes to fetch.
     */
    orderBy?: UserFavoriteRecipeOrderByWithRelationInput | UserFavoriteRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFavoriteRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavoriteRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavoriteRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFavoriteRecipes
    **/
    _count?: true | UserFavoriteRecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFavoriteRecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFavoriteRecipeMaxAggregateInputType
  }

  export type GetUserFavoriteRecipeAggregateType<T extends UserFavoriteRecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFavoriteRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFavoriteRecipe[P]>
      : GetScalarType<T[P], AggregateUserFavoriteRecipe[P]>
  }




  export type UserFavoriteRecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteRecipeWhereInput
    orderBy?: UserFavoriteRecipeOrderByWithAggregationInput | UserFavoriteRecipeOrderByWithAggregationInput[]
    by: UserFavoriteRecipeScalarFieldEnum[] | UserFavoriteRecipeScalarFieldEnum
    having?: UserFavoriteRecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFavoriteRecipeCountAggregateInputType | true
    _min?: UserFavoriteRecipeMinAggregateInputType
    _max?: UserFavoriteRecipeMaxAggregateInputType
  }

  export type UserFavoriteRecipeGroupByOutputType = {
    id: string
    userId: string
    recipeId: string
    addedAt: Date
    _count: UserFavoriteRecipeCountAggregateOutputType | null
    _min: UserFavoriteRecipeMinAggregateOutputType | null
    _max: UserFavoriteRecipeMaxAggregateOutputType | null
  }

  type GetUserFavoriteRecipeGroupByPayload<T extends UserFavoriteRecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFavoriteRecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFavoriteRecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFavoriteRecipeGroupByOutputType[P]>
            : GetScalarType<T[P], UserFavoriteRecipeGroupByOutputType[P]>
        }
      >
    >


  export type UserFavoriteRecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recipeId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavoriteRecipe"]>

  export type UserFavoriteRecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recipeId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavoriteRecipe"]>

  export type UserFavoriteRecipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recipeId?: boolean
    addedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavoriteRecipe"]>

  export type UserFavoriteRecipeSelectScalar = {
    id?: boolean
    userId?: boolean
    recipeId?: boolean
    addedAt?: boolean
  }

  export type UserFavoriteRecipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "recipeId" | "addedAt", ExtArgs["result"]["userFavoriteRecipe"]>
  export type UserFavoriteRecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type UserFavoriteRecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type UserFavoriteRecipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $UserFavoriteRecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFavoriteRecipe"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      recipeId: string
      addedAt: Date
    }, ExtArgs["result"]["userFavoriteRecipe"]>
    composites: {}
  }

  type UserFavoriteRecipeGetPayload<S extends boolean | null | undefined | UserFavoriteRecipeDefaultArgs> = $Result.GetResult<Prisma.$UserFavoriteRecipePayload, S>

  type UserFavoriteRecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFavoriteRecipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFavoriteRecipeCountAggregateInputType | true
    }

  export interface UserFavoriteRecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFavoriteRecipe'], meta: { name: 'UserFavoriteRecipe' } }
    /**
     * Find zero or one UserFavoriteRecipe that matches the filter.
     * @param {UserFavoriteRecipeFindUniqueArgs} args - Arguments to find a UserFavoriteRecipe
     * @example
     * // Get one UserFavoriteRecipe
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFavoriteRecipeFindUniqueArgs>(args: SelectSubset<T, UserFavoriteRecipeFindUniqueArgs<ExtArgs>>): Prisma__UserFavoriteRecipeClient<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFavoriteRecipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFavoriteRecipeFindUniqueOrThrowArgs} args - Arguments to find a UserFavoriteRecipe
     * @example
     * // Get one UserFavoriteRecipe
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFavoriteRecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFavoriteRecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteRecipeClient<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavoriteRecipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteRecipeFindFirstArgs} args - Arguments to find a UserFavoriteRecipe
     * @example
     * // Get one UserFavoriteRecipe
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFavoriteRecipeFindFirstArgs>(args?: SelectSubset<T, UserFavoriteRecipeFindFirstArgs<ExtArgs>>): Prisma__UserFavoriteRecipeClient<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavoriteRecipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteRecipeFindFirstOrThrowArgs} args - Arguments to find a UserFavoriteRecipe
     * @example
     * // Get one UserFavoriteRecipe
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFavoriteRecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFavoriteRecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteRecipeClient<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFavoriteRecipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteRecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFavoriteRecipes
     * const userFavoriteRecipes = await prisma.userFavoriteRecipe.findMany()
     * 
     * // Get first 10 UserFavoriteRecipes
     * const userFavoriteRecipes = await prisma.userFavoriteRecipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFavoriteRecipeWithIdOnly = await prisma.userFavoriteRecipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFavoriteRecipeFindManyArgs>(args?: SelectSubset<T, UserFavoriteRecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFavoriteRecipe.
     * @param {UserFavoriteRecipeCreateArgs} args - Arguments to create a UserFavoriteRecipe.
     * @example
     * // Create one UserFavoriteRecipe
     * const UserFavoriteRecipe = await prisma.userFavoriteRecipe.create({
     *   data: {
     *     // ... data to create a UserFavoriteRecipe
     *   }
     * })
     * 
     */
    create<T extends UserFavoriteRecipeCreateArgs>(args: SelectSubset<T, UserFavoriteRecipeCreateArgs<ExtArgs>>): Prisma__UserFavoriteRecipeClient<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFavoriteRecipes.
     * @param {UserFavoriteRecipeCreateManyArgs} args - Arguments to create many UserFavoriteRecipes.
     * @example
     * // Create many UserFavoriteRecipes
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFavoriteRecipeCreateManyArgs>(args?: SelectSubset<T, UserFavoriteRecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFavoriteRecipes and returns the data saved in the database.
     * @param {UserFavoriteRecipeCreateManyAndReturnArgs} args - Arguments to create many UserFavoriteRecipes.
     * @example
     * // Create many UserFavoriteRecipes
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFavoriteRecipes and only return the `id`
     * const userFavoriteRecipeWithIdOnly = await prisma.userFavoriteRecipe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFavoriteRecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFavoriteRecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFavoriteRecipe.
     * @param {UserFavoriteRecipeDeleteArgs} args - Arguments to delete one UserFavoriteRecipe.
     * @example
     * // Delete one UserFavoriteRecipe
     * const UserFavoriteRecipe = await prisma.userFavoriteRecipe.delete({
     *   where: {
     *     // ... filter to delete one UserFavoriteRecipe
     *   }
     * })
     * 
     */
    delete<T extends UserFavoriteRecipeDeleteArgs>(args: SelectSubset<T, UserFavoriteRecipeDeleteArgs<ExtArgs>>): Prisma__UserFavoriteRecipeClient<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFavoriteRecipe.
     * @param {UserFavoriteRecipeUpdateArgs} args - Arguments to update one UserFavoriteRecipe.
     * @example
     * // Update one UserFavoriteRecipe
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFavoriteRecipeUpdateArgs>(args: SelectSubset<T, UserFavoriteRecipeUpdateArgs<ExtArgs>>): Prisma__UserFavoriteRecipeClient<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFavoriteRecipes.
     * @param {UserFavoriteRecipeDeleteManyArgs} args - Arguments to filter UserFavoriteRecipes to delete.
     * @example
     * // Delete a few UserFavoriteRecipes
     * const { count } = await prisma.userFavoriteRecipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFavoriteRecipeDeleteManyArgs>(args?: SelectSubset<T, UserFavoriteRecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavoriteRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteRecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFavoriteRecipes
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFavoriteRecipeUpdateManyArgs>(args: SelectSubset<T, UserFavoriteRecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavoriteRecipes and returns the data updated in the database.
     * @param {UserFavoriteRecipeUpdateManyAndReturnArgs} args - Arguments to update many UserFavoriteRecipes.
     * @example
     * // Update many UserFavoriteRecipes
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFavoriteRecipes and only return the `id`
     * const userFavoriteRecipeWithIdOnly = await prisma.userFavoriteRecipe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFavoriteRecipeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFavoriteRecipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFavoriteRecipe.
     * @param {UserFavoriteRecipeUpsertArgs} args - Arguments to update or create a UserFavoriteRecipe.
     * @example
     * // Update or create a UserFavoriteRecipe
     * const userFavoriteRecipe = await prisma.userFavoriteRecipe.upsert({
     *   create: {
     *     // ... data to create a UserFavoriteRecipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFavoriteRecipe we want to update
     *   }
     * })
     */
    upsert<T extends UserFavoriteRecipeUpsertArgs>(args: SelectSubset<T, UserFavoriteRecipeUpsertArgs<ExtArgs>>): Prisma__UserFavoriteRecipeClient<$Result.GetResult<Prisma.$UserFavoriteRecipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFavoriteRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteRecipeCountArgs} args - Arguments to filter UserFavoriteRecipes to count.
     * @example
     * // Count the number of UserFavoriteRecipes
     * const count = await prisma.userFavoriteRecipe.count({
     *   where: {
     *     // ... the filter for the UserFavoriteRecipes we want to count
     *   }
     * })
    **/
    count<T extends UserFavoriteRecipeCountArgs>(
      args?: Subset<T, UserFavoriteRecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFavoriteRecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFavoriteRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteRecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFavoriteRecipeAggregateArgs>(args: Subset<T, UserFavoriteRecipeAggregateArgs>): Prisma.PrismaPromise<GetUserFavoriteRecipeAggregateType<T>>

    /**
     * Group by UserFavoriteRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteRecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFavoriteRecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFavoriteRecipeGroupByArgs['orderBy'] }
        : { orderBy?: UserFavoriteRecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFavoriteRecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavoriteRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFavoriteRecipe model
   */
  readonly fields: UserFavoriteRecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFavoriteRecipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFavoriteRecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFavoriteRecipe model
   */
  interface UserFavoriteRecipeFieldRefs {
    readonly id: FieldRef<"UserFavoriteRecipe", 'String'>
    readonly userId: FieldRef<"UserFavoriteRecipe", 'String'>
    readonly recipeId: FieldRef<"UserFavoriteRecipe", 'String'>
    readonly addedAt: FieldRef<"UserFavoriteRecipe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFavoriteRecipe findUnique
   */
  export type UserFavoriteRecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    /**
     * Filter, which UserFavoriteRecipe to fetch.
     */
    where: UserFavoriteRecipeWhereUniqueInput
  }

  /**
   * UserFavoriteRecipe findUniqueOrThrow
   */
  export type UserFavoriteRecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    /**
     * Filter, which UserFavoriteRecipe to fetch.
     */
    where: UserFavoriteRecipeWhereUniqueInput
  }

  /**
   * UserFavoriteRecipe findFirst
   */
  export type UserFavoriteRecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    /**
     * Filter, which UserFavoriteRecipe to fetch.
     */
    where?: UserFavoriteRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavoriteRecipes to fetch.
     */
    orderBy?: UserFavoriteRecipeOrderByWithRelationInput | UserFavoriteRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavoriteRecipes.
     */
    cursor?: UserFavoriteRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavoriteRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavoriteRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavoriteRecipes.
     */
    distinct?: UserFavoriteRecipeScalarFieldEnum | UserFavoriteRecipeScalarFieldEnum[]
  }

  /**
   * UserFavoriteRecipe findFirstOrThrow
   */
  export type UserFavoriteRecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    /**
     * Filter, which UserFavoriteRecipe to fetch.
     */
    where?: UserFavoriteRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavoriteRecipes to fetch.
     */
    orderBy?: UserFavoriteRecipeOrderByWithRelationInput | UserFavoriteRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavoriteRecipes.
     */
    cursor?: UserFavoriteRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavoriteRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavoriteRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavoriteRecipes.
     */
    distinct?: UserFavoriteRecipeScalarFieldEnum | UserFavoriteRecipeScalarFieldEnum[]
  }

  /**
   * UserFavoriteRecipe findMany
   */
  export type UserFavoriteRecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    /**
     * Filter, which UserFavoriteRecipes to fetch.
     */
    where?: UserFavoriteRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavoriteRecipes to fetch.
     */
    orderBy?: UserFavoriteRecipeOrderByWithRelationInput | UserFavoriteRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFavoriteRecipes.
     */
    cursor?: UserFavoriteRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavoriteRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavoriteRecipes.
     */
    skip?: number
    distinct?: UserFavoriteRecipeScalarFieldEnum | UserFavoriteRecipeScalarFieldEnum[]
  }

  /**
   * UserFavoriteRecipe create
   */
  export type UserFavoriteRecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFavoriteRecipe.
     */
    data: XOR<UserFavoriteRecipeCreateInput, UserFavoriteRecipeUncheckedCreateInput>
  }

  /**
   * UserFavoriteRecipe createMany
   */
  export type UserFavoriteRecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFavoriteRecipes.
     */
    data: UserFavoriteRecipeCreateManyInput | UserFavoriteRecipeCreateManyInput[]
  }

  /**
   * UserFavoriteRecipe createManyAndReturn
   */
  export type UserFavoriteRecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * The data used to create many UserFavoriteRecipes.
     */
    data: UserFavoriteRecipeCreateManyInput | UserFavoriteRecipeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavoriteRecipe update
   */
  export type UserFavoriteRecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFavoriteRecipe.
     */
    data: XOR<UserFavoriteRecipeUpdateInput, UserFavoriteRecipeUncheckedUpdateInput>
    /**
     * Choose, which UserFavoriteRecipe to update.
     */
    where: UserFavoriteRecipeWhereUniqueInput
  }

  /**
   * UserFavoriteRecipe updateMany
   */
  export type UserFavoriteRecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFavoriteRecipes.
     */
    data: XOR<UserFavoriteRecipeUpdateManyMutationInput, UserFavoriteRecipeUncheckedUpdateManyInput>
    /**
     * Filter which UserFavoriteRecipes to update
     */
    where?: UserFavoriteRecipeWhereInput
    /**
     * Limit how many UserFavoriteRecipes to update.
     */
    limit?: number
  }

  /**
   * UserFavoriteRecipe updateManyAndReturn
   */
  export type UserFavoriteRecipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * The data used to update UserFavoriteRecipes.
     */
    data: XOR<UserFavoriteRecipeUpdateManyMutationInput, UserFavoriteRecipeUncheckedUpdateManyInput>
    /**
     * Filter which UserFavoriteRecipes to update
     */
    where?: UserFavoriteRecipeWhereInput
    /**
     * Limit how many UserFavoriteRecipes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavoriteRecipe upsert
   */
  export type UserFavoriteRecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFavoriteRecipe to update in case it exists.
     */
    where: UserFavoriteRecipeWhereUniqueInput
    /**
     * In case the UserFavoriteRecipe found by the `where` argument doesn't exist, create a new UserFavoriteRecipe with this data.
     */
    create: XOR<UserFavoriteRecipeCreateInput, UserFavoriteRecipeUncheckedCreateInput>
    /**
     * In case the UserFavoriteRecipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFavoriteRecipeUpdateInput, UserFavoriteRecipeUncheckedUpdateInput>
  }

  /**
   * UserFavoriteRecipe delete
   */
  export type UserFavoriteRecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
    /**
     * Filter which UserFavoriteRecipe to delete.
     */
    where: UserFavoriteRecipeWhereUniqueInput
  }

  /**
   * UserFavoriteRecipe deleteMany
   */
  export type UserFavoriteRecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavoriteRecipes to delete
     */
    where?: UserFavoriteRecipeWhereInput
    /**
     * Limit how many UserFavoriteRecipes to delete.
     */
    limit?: number
  }

  /**
   * UserFavoriteRecipe without action
   */
  export type UserFavoriteRecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavoriteRecipe
     */
    select?: UserFavoriteRecipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavoriteRecipe
     */
    omit?: UserFavoriteRecipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteRecipeInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    status: $Enums.SubscriptionStatus | null
    tier: $Enums.SubscriptionTier | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    status: $Enums.SubscriptionStatus | null
    tier: $Enums.SubscriptionTier | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    status: number
    tier: number
    currentPeriodStart: number
    currentPeriodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    status?: true
    tier?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    status?: true
    tier?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    status?: true
    tier?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    status: $Enums.SubscriptionStatus
    tier: $Enums.SubscriptionTier
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    tier?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    tier?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    tier?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    status?: boolean
    tier?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "stripeCustomerId" | "stripeSubscriptionId" | "status" | "tier" | "currentPeriodStart" | "currentPeriodEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      stripeCustomerId: string | null
      stripeSubscriptionId: string | null
      status: $Enums.SubscriptionStatus
      tier: $Enums.SubscriptionTier
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly tier: FieldRef<"Subscription", 'SubscriptionTier'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    userId: string | null
    recipeId: string | null
    rating: number | null
    notes: string | null
    timestamp: Date | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    recipeId: string | null
    rating: number | null
    notes: string | null
    timestamp: Date | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    userId: number
    recipeId: number
    rating: number
    notes: number
    timestamp: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type FeedbackSumAggregateInputType = {
    rating?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    recipeId?: true
    rating?: true
    notes?: true
    timestamp?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    recipeId?: true
    rating?: true
    notes?: true
    timestamp?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    recipeId?: true
    rating?: true
    notes?: true
    timestamp?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    userId: string
    recipeId: string
    rating: number
    notes: string | null
    timestamp: Date
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recipeId?: boolean
    rating?: boolean
    notes?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recipeId?: boolean
    rating?: boolean
    notes?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    recipeId?: boolean
    rating?: boolean
    notes?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    recipeId?: boolean
    rating?: boolean
    notes?: boolean
    timestamp?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "recipeId" | "rating" | "notes" | "timestamp", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      recipeId: string
      rating: number
      notes: string | null
      timestamp: Date
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {FeedbackUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeedbackUpdateManyAndReturnArgs>(args: SelectSubset<T, FeedbackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly userId: FieldRef<"Feedback", 'String'>
    readonly recipeId: FieldRef<"Feedback", 'String'>
    readonly rating: FieldRef<"Feedback", 'Int'>
    readonly notes: FieldRef<"Feedback", 'String'>
    readonly timestamp: FieldRef<"Feedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback updateManyAndReturn
   */
  export type FeedbackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model ABTest
   */

  export type AggregateABTest = {
    _count: ABTestCountAggregateOutputType | null
    _min: ABTestMinAggregateOutputType | null
    _max: ABTestMaxAggregateOutputType | null
  }

  export type ABTestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    feature: string | null
    variant: string | null
    timestamp: Date | null
  }

  export type ABTestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    feature: string | null
    variant: string | null
    timestamp: Date | null
  }

  export type ABTestCountAggregateOutputType = {
    id: number
    userId: number
    feature: number
    variant: number
    timestamp: number
    _all: number
  }


  export type ABTestMinAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    variant?: true
    timestamp?: true
  }

  export type ABTestMaxAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    variant?: true
    timestamp?: true
  }

  export type ABTestCountAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    variant?: true
    timestamp?: true
    _all?: true
  }

  export type ABTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTest to aggregate.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ABTests
    **/
    _count?: true | ABTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ABTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ABTestMaxAggregateInputType
  }

  export type GetABTestAggregateType<T extends ABTestAggregateArgs> = {
        [P in keyof T & keyof AggregateABTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateABTest[P]>
      : GetScalarType<T[P], AggregateABTest[P]>
  }




  export type ABTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ABTestWhereInput
    orderBy?: ABTestOrderByWithAggregationInput | ABTestOrderByWithAggregationInput[]
    by: ABTestScalarFieldEnum[] | ABTestScalarFieldEnum
    having?: ABTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ABTestCountAggregateInputType | true
    _min?: ABTestMinAggregateInputType
    _max?: ABTestMaxAggregateInputType
  }

  export type ABTestGroupByOutputType = {
    id: string
    userId: string
    feature: string
    variant: string
    timestamp: Date
    _count: ABTestCountAggregateOutputType | null
    _min: ABTestMinAggregateOutputType | null
    _max: ABTestMaxAggregateOutputType | null
  }

  type GetABTestGroupByPayload<T extends ABTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ABTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ABTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ABTestGroupByOutputType[P]>
            : GetScalarType<T[P], ABTestGroupByOutputType[P]>
        }
      >
    >


  export type ABTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    variant?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aBTest"]>

  export type ABTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    variant?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aBTest"]>

  export type ABTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    variant?: boolean
    timestamp?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aBTest"]>

  export type ABTestSelectScalar = {
    id?: boolean
    userId?: boolean
    feature?: boolean
    variant?: boolean
    timestamp?: boolean
  }

  export type ABTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "feature" | "variant" | "timestamp", ExtArgs["result"]["aBTest"]>
  export type ABTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ABTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ABTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ABTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ABTest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      feature: string
      variant: string
      timestamp: Date
    }, ExtArgs["result"]["aBTest"]>
    composites: {}
  }

  type ABTestGetPayload<S extends boolean | null | undefined | ABTestDefaultArgs> = $Result.GetResult<Prisma.$ABTestPayload, S>

  type ABTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ABTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ABTestCountAggregateInputType | true
    }

  export interface ABTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ABTest'], meta: { name: 'ABTest' } }
    /**
     * Find zero or one ABTest that matches the filter.
     * @param {ABTestFindUniqueArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ABTestFindUniqueArgs>(args: SelectSubset<T, ABTestFindUniqueArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ABTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ABTestFindUniqueOrThrowArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ABTestFindUniqueOrThrowArgs>(args: SelectSubset<T, ABTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestFindFirstArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ABTestFindFirstArgs>(args?: SelectSubset<T, ABTestFindFirstArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ABTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestFindFirstOrThrowArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ABTestFindFirstOrThrowArgs>(args?: SelectSubset<T, ABTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ABTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ABTests
     * const aBTests = await prisma.aBTest.findMany()
     * 
     * // Get first 10 ABTests
     * const aBTests = await prisma.aBTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aBTestWithIdOnly = await prisma.aBTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ABTestFindManyArgs>(args?: SelectSubset<T, ABTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ABTest.
     * @param {ABTestCreateArgs} args - Arguments to create a ABTest.
     * @example
     * // Create one ABTest
     * const ABTest = await prisma.aBTest.create({
     *   data: {
     *     // ... data to create a ABTest
     *   }
     * })
     * 
     */
    create<T extends ABTestCreateArgs>(args: SelectSubset<T, ABTestCreateArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ABTests.
     * @param {ABTestCreateManyArgs} args - Arguments to create many ABTests.
     * @example
     * // Create many ABTests
     * const aBTest = await prisma.aBTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ABTestCreateManyArgs>(args?: SelectSubset<T, ABTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ABTests and returns the data saved in the database.
     * @param {ABTestCreateManyAndReturnArgs} args - Arguments to create many ABTests.
     * @example
     * // Create many ABTests
     * const aBTest = await prisma.aBTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ABTests and only return the `id`
     * const aBTestWithIdOnly = await prisma.aBTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ABTestCreateManyAndReturnArgs>(args?: SelectSubset<T, ABTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ABTest.
     * @param {ABTestDeleteArgs} args - Arguments to delete one ABTest.
     * @example
     * // Delete one ABTest
     * const ABTest = await prisma.aBTest.delete({
     *   where: {
     *     // ... filter to delete one ABTest
     *   }
     * })
     * 
     */
    delete<T extends ABTestDeleteArgs>(args: SelectSubset<T, ABTestDeleteArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ABTest.
     * @param {ABTestUpdateArgs} args - Arguments to update one ABTest.
     * @example
     * // Update one ABTest
     * const aBTest = await prisma.aBTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ABTestUpdateArgs>(args: SelectSubset<T, ABTestUpdateArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ABTests.
     * @param {ABTestDeleteManyArgs} args - Arguments to filter ABTests to delete.
     * @example
     * // Delete a few ABTests
     * const { count } = await prisma.aBTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ABTestDeleteManyArgs>(args?: SelectSubset<T, ABTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ABTests
     * const aBTest = await prisma.aBTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ABTestUpdateManyArgs>(args: SelectSubset<T, ABTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABTests and returns the data updated in the database.
     * @param {ABTestUpdateManyAndReturnArgs} args - Arguments to update many ABTests.
     * @example
     * // Update many ABTests
     * const aBTest = await prisma.aBTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ABTests and only return the `id`
     * const aBTestWithIdOnly = await prisma.aBTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ABTestUpdateManyAndReturnArgs>(args: SelectSubset<T, ABTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ABTest.
     * @param {ABTestUpsertArgs} args - Arguments to update or create a ABTest.
     * @example
     * // Update or create a ABTest
     * const aBTest = await prisma.aBTest.upsert({
     *   create: {
     *     // ... data to create a ABTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ABTest we want to update
     *   }
     * })
     */
    upsert<T extends ABTestUpsertArgs>(args: SelectSubset<T, ABTestUpsertArgs<ExtArgs>>): Prisma__ABTestClient<$Result.GetResult<Prisma.$ABTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ABTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestCountArgs} args - Arguments to filter ABTests to count.
     * @example
     * // Count the number of ABTests
     * const count = await prisma.aBTest.count({
     *   where: {
     *     // ... the filter for the ABTests we want to count
     *   }
     * })
    **/
    count<T extends ABTestCountArgs>(
      args?: Subset<T, ABTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ABTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ABTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ABTestAggregateArgs>(args: Subset<T, ABTestAggregateArgs>): Prisma.PrismaPromise<GetABTestAggregateType<T>>

    /**
     * Group by ABTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ABTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ABTestGroupByArgs['orderBy'] }
        : { orderBy?: ABTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ABTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetABTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ABTest model
   */
  readonly fields: ABTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ABTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ABTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ABTest model
   */
  interface ABTestFieldRefs {
    readonly id: FieldRef<"ABTest", 'String'>
    readonly userId: FieldRef<"ABTest", 'String'>
    readonly feature: FieldRef<"ABTest", 'String'>
    readonly variant: FieldRef<"ABTest", 'String'>
    readonly timestamp: FieldRef<"ABTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ABTest findUnique
   */
  export type ABTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where: ABTestWhereUniqueInput
  }

  /**
   * ABTest findUniqueOrThrow
   */
  export type ABTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where: ABTestWhereUniqueInput
  }

  /**
   * ABTest findFirst
   */
  export type ABTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTests.
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTests.
     */
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }

  /**
   * ABTest findFirstOrThrow
   */
  export type ABTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTests.
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTests.
     */
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }

  /**
   * ABTest findMany
   */
  export type ABTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter, which ABTests to fetch.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ABTests.
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }

  /**
   * ABTest create
   */
  export type ABTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * The data needed to create a ABTest.
     */
    data: XOR<ABTestCreateInput, ABTestUncheckedCreateInput>
  }

  /**
   * ABTest createMany
   */
  export type ABTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ABTests.
     */
    data: ABTestCreateManyInput | ABTestCreateManyInput[]
  }

  /**
   * ABTest createManyAndReturn
   */
  export type ABTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * The data used to create many ABTests.
     */
    data: ABTestCreateManyInput | ABTestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ABTest update
   */
  export type ABTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * The data needed to update a ABTest.
     */
    data: XOR<ABTestUpdateInput, ABTestUncheckedUpdateInput>
    /**
     * Choose, which ABTest to update.
     */
    where: ABTestWhereUniqueInput
  }

  /**
   * ABTest updateMany
   */
  export type ABTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ABTests.
     */
    data: XOR<ABTestUpdateManyMutationInput, ABTestUncheckedUpdateManyInput>
    /**
     * Filter which ABTests to update
     */
    where?: ABTestWhereInput
    /**
     * Limit how many ABTests to update.
     */
    limit?: number
  }

  /**
   * ABTest updateManyAndReturn
   */
  export type ABTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * The data used to update ABTests.
     */
    data: XOR<ABTestUpdateManyMutationInput, ABTestUncheckedUpdateManyInput>
    /**
     * Filter which ABTests to update
     */
    where?: ABTestWhereInput
    /**
     * Limit how many ABTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ABTest upsert
   */
  export type ABTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * The filter to search for the ABTest to update in case it exists.
     */
    where: ABTestWhereUniqueInput
    /**
     * In case the ABTest found by the `where` argument doesn't exist, create a new ABTest with this data.
     */
    create: XOR<ABTestCreateInput, ABTestUncheckedCreateInput>
    /**
     * In case the ABTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ABTestUpdateInput, ABTestUncheckedUpdateInput>
  }

  /**
   * ABTest delete
   */
  export type ABTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
    /**
     * Filter which ABTest to delete.
     */
    where: ABTestWhereUniqueInput
  }

  /**
   * ABTest deleteMany
   */
  export type ABTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTests to delete
     */
    where?: ABTestWhereInput
    /**
     * Limit how many ABTests to delete.
     */
    limit?: number
  }

  /**
   * ABTest without action
   */
  export type ABTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ABTest
     */
    omit?: ABTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ABTestInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    primaryGoal: 'primaryGoal',
    preferencesJson: 'preferencesJson'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cookingSkillLevel: 'cookingSkillLevel',
    maxPrepTimeMinutes: 'maxPrepTimeMinutes',
    budgetRange: 'budgetRange',
    householdSize: 'householdSize',
    hasOven: 'hasOven',
    hasStove: 'hasStove',
    hasMicrowave: 'hasMicrowave',
    hasBlender: 'hasBlender',
    hasAirFryer: 'hasAirFryer',
    hasSlowCooker: 'hasSlowCooker',
    hasInstantPot: 'hasInstantPot',
    mealsPerDay: 'mealsPerDay',
    snacksPerDay: 'snacksPerDay',
    batchCookingPreference: 'batchCookingPreference',
    energyRestrictionGoal: 'energyRestrictionGoal',
    targetCaloriesMin: 'targetCaloriesMin',
    targetCaloriesMax: 'targetCaloriesMax',
    cuisinePreferences: 'cuisinePreferences',
    spiceTolerance: 'spiceTolerance',
    flavorIntensity: 'flavorIntensity',
    knifeSkillLevel: 'knifeSkillLevel',
    preferredTechniques: 'preferredTechniques',
    recipeComplexityComfort: 'recipeComplexityComfort',
    weeklyFoodBudget: 'weeklyFoodBudget',
    shoppingFrequency: 'shoppingFrequency',
    mealPlanningApproach: 'mealPlanningApproach',
    textureLimitations: 'textureLimitations',
    foodsToAvoid: 'foodsToAvoid',
    mealTimingPreference: 'mealTimingPreference',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const HealthConditionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category'
  };

  export type HealthConditionScalarFieldEnum = (typeof HealthConditionScalarFieldEnum)[keyof typeof HealthConditionScalarFieldEnum]


  export const UserHealthConditionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    healthConditionId: 'healthConditionId',
    severity: 'severity',
    diagnosedDate: 'diagnosedDate'
  };

  export type UserHealthConditionScalarFieldEnum = (typeof UserHealthConditionScalarFieldEnum)[keyof typeof UserHealthConditionScalarFieldEnum]


  export const AllergenScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category'
  };

  export type AllergenScalarFieldEnum = (typeof AllergenScalarFieldEnum)[keyof typeof AllergenScalarFieldEnum]


  export const UserAllergyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    allergenId: 'allergenId',
    severity: 'severity'
  };

  export type UserAllergyScalarFieldEnum = (typeof UserAllergyScalarFieldEnum)[keyof typeof UserAllergyScalarFieldEnum]


  export const ApplianceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    category: 'category'
  };

  export type ApplianceScalarFieldEnum = (typeof ApplianceScalarFieldEnum)[keyof typeof ApplianceScalarFieldEnum]


  export const UserApplianceScalarFieldEnum: {
    id: 'id',
    userPreferencesId: 'userPreferencesId',
    applianceId: 'applianceId',
    usageFrequency: 'usageFrequency'
  };

  export type UserApplianceScalarFieldEnum = (typeof UserApplianceScalarFieldEnum)[keyof typeof UserApplianceScalarFieldEnum]


  export const UserBehaviorScalarFieldEnum: {
    id: 'id',
    userPreferencesId: 'userPreferencesId',
    portionControlMotivation: 'portionControlMotivation',
    habitChangeReadiness: 'habitChangeReadiness',
    socialEatingPattern: 'socialEatingPattern',
    successTrackingPreference: 'successTrackingPreference',
    activityLevel: 'activityLevel',
    healthConditionPriority: 'healthConditionPriority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserBehaviorScalarFieldEnum = (typeof UserBehaviorScalarFieldEnum)[keyof typeof UserBehaviorScalarFieldEnum]


  export const SpiceBlendScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    activeCompounds: 'activeCompounds',
    clinicalEvidence: 'clinicalEvidence',
    primaryBenefit: 'primaryBenefit',
    effectiveDoseGrams: 'effectiveDoseGrams',
    bioavailabilityHack: 'bioavailabilityHack',
    quickApplications: 'quickApplications'
  };

  export type SpiceBlendScalarFieldEnum = (typeof SpiceBlendScalarFieldEnum)[keyof typeof SpiceBlendScalarFieldEnum]


  export const RecipeSpiceBlendScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    spiceBlendId: 'spiceBlendId',
    amountGrams: 'amountGrams'
  };

  export type RecipeSpiceBlendScalarFieldEnum = (typeof RecipeSpiceBlendScalarFieldEnum)[keyof typeof RecipeSpiceBlendScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    servings: 'servings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    prepTimeMinutes: 'prepTimeMinutes',
    cookTimeMinutes: 'cookTimeMinutes',
    totalTimeMinutes: 'totalTimeMinutes',
    complexity: 'complexity',
    costTier: 'costTier',
    requiredAppliances: 'requiredAppliances',
    goalTags: 'goalTags'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const RecipeIngredientScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    name: 'name',
    amount: 'amount',
    unit: 'unit',
    notes: 'notes'
  };

  export type RecipeIngredientScalarFieldEnum = (typeof RecipeIngredientScalarFieldEnum)[keyof typeof RecipeIngredientScalarFieldEnum]


  export const RecipeInstructionScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    stepNumber: 'stepNumber',
    instruction: 'instruction'
  };

  export type RecipeInstructionScalarFieldEnum = (typeof RecipeInstructionScalarFieldEnum)[keyof typeof RecipeInstructionScalarFieldEnum]


  export const NutritionalInfoScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    calories: 'calories',
    protein: 'protein',
    carbohydrates: 'carbohydrates',
    fat: 'fat',
    fiber: 'fiber',
    sugar: 'sugar',
    sodium: 'sodium',
    cholesterol: 'cholesterol',
    vitaminC: 'vitaminC',
    vitaminD: 'vitaminD',
    calcium: 'calcium',
    iron: 'iron',
    potassium: 'potassium'
  };

  export type NutritionalInfoScalarFieldEnum = (typeof NutritionalInfoScalarFieldEnum)[keyof typeof NutritionalInfoScalarFieldEnum]


  export const MedicalTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    condition: 'condition'
  };

  export type MedicalTagScalarFieldEnum = (typeof MedicalTagScalarFieldEnum)[keyof typeof MedicalTagScalarFieldEnum]


  export const RecipeMedicalTagScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    medicalTagId: 'medicalTagId'
  };

  export type RecipeMedicalTagScalarFieldEnum = (typeof RecipeMedicalTagScalarFieldEnum)[keyof typeof RecipeMedicalTagScalarFieldEnum]


  export const DietaryTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category'
  };

  export type DietaryTagScalarFieldEnum = (typeof DietaryTagScalarFieldEnum)[keyof typeof DietaryTagScalarFieldEnum]


  export const RecipeDietaryTagScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    dietaryTagId: 'dietaryTagId'
  };

  export type RecipeDietaryTagScalarFieldEnum = (typeof RecipeDietaryTagScalarFieldEnum)[keyof typeof RecipeDietaryTagScalarFieldEnum]


  export const PracticalTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category'
  };

  export type PracticalTagScalarFieldEnum = (typeof PracticalTagScalarFieldEnum)[keyof typeof PracticalTagScalarFieldEnum]


  export const RecipePracticalTagScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    practicalTagId: 'practicalTagId'
  };

  export type RecipePracticalTagScalarFieldEnum = (typeof RecipePracticalTagScalarFieldEnum)[keyof typeof RecipePracticalTagScalarFieldEnum]


  export const NutritionalTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category'
  };

  export type NutritionalTagScalarFieldEnum = (typeof NutritionalTagScalarFieldEnum)[keyof typeof NutritionalTagScalarFieldEnum]


  export const RecipeNutritionalTagScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    nutritionalTagId: 'nutritionalTagId'
  };

  export type RecipeNutritionalTagScalarFieldEnum = (typeof RecipeNutritionalTagScalarFieldEnum)[keyof typeof RecipeNutritionalTagScalarFieldEnum]


  export const MealPlanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    weekStartDate: 'weekStartDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MealPlanScalarFieldEnum = (typeof MealPlanScalarFieldEnum)[keyof typeof MealPlanScalarFieldEnum]


  export const MealPlanItemScalarFieldEnum: {
    id: 'id',
    mealPlanId: 'mealPlanId',
    recipeId: 'recipeId',
    dayOfWeek: 'dayOfWeek',
    mealType: 'mealType',
    servings: 'servings'
  };

  export type MealPlanItemScalarFieldEnum = (typeof MealPlanItemScalarFieldEnum)[keyof typeof MealPlanItemScalarFieldEnum]


  export const ShoppingListScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mealPlanId: 'mealPlanId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShoppingListScalarFieldEnum = (typeof ShoppingListScalarFieldEnum)[keyof typeof ShoppingListScalarFieldEnum]


  export const ShoppingListItemScalarFieldEnum: {
    id: 'id',
    shoppingListId: 'shoppingListId',
    name: 'name',
    amount: 'amount',
    unit: 'unit',
    category: 'category',
    purchased: 'purchased',
    estimatedPrice: 'estimatedPrice'
  };

  export type ShoppingListItemScalarFieldEnum = (typeof ShoppingListItemScalarFieldEnum)[keyof typeof ShoppingListItemScalarFieldEnum]


  export const UserFavoriteRecipeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    recipeId: 'recipeId',
    addedAt: 'addedAt'
  };

  export type UserFavoriteRecipeScalarFieldEnum = (typeof UserFavoriteRecipeScalarFieldEnum)[keyof typeof UserFavoriteRecipeScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    status: 'status',
    tier: 'tier',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    recipeId: 'recipeId',
    rating: 'rating',
    notes: 'notes',
    timestamp: 'timestamp'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const ABTestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    feature: 'feature',
    variant: 'variant',
    timestamp: 'timestamp'
  };

  export type ABTestScalarFieldEnum = (typeof ABTestScalarFieldEnum)[keyof typeof ABTestScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DietaryGoal'
   */
  export type EnumDietaryGoalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DietaryGoal'>
    


  /**
   * Reference to a field of type 'CookingSkill'
   */
  export type EnumCookingSkillFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CookingSkill'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'BudgetRange'
   */
  export type EnumBudgetRangeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetRange'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'HealthCategory'
   */
  export type EnumHealthCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthCategory'>
    


  /**
   * Reference to a field of type 'Severity'
   */
  export type EnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity'>
    


  /**
   * Reference to a field of type 'AllergenCategory'
   */
  export type EnumAllergenCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AllergenCategory'>
    


  /**
   * Reference to a field of type 'DietaryCategory'
   */
  export type EnumDietaryCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DietaryCategory'>
    


  /**
   * Reference to a field of type 'PracticalCategory'
   */
  export type EnumPracticalCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PracticalCategory'>
    


  /**
   * Reference to a field of type 'NutritionalCategory'
   */
  export type EnumNutritionalCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NutritionalCategory'>
    


  /**
   * Reference to a field of type 'DayOfWeek'
   */
  export type EnumDayOfWeekFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DayOfWeek'>
    


  /**
   * Reference to a field of type 'MealType'
   */
  export type EnumMealTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MealType'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    primaryGoal?: EnumDietaryGoalNullableFilter<"User"> | $Enums.DietaryGoal | null
    preferencesJson?: StringNullableFilter<"User"> | string | null
    healthConditions?: UserHealthConditionListRelationFilter
    allergies?: UserAllergyListRelationFilter
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    mealPlans?: MealPlanListRelationFilter
    shoppingLists?: ShoppingListListRelationFilter
    favoriteRecipes?: UserFavoriteRecipeListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    feedbacks?: FeedbackListRelationFilter
    abTests?: ABTestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryGoal?: SortOrderInput | SortOrder
    preferencesJson?: SortOrderInput | SortOrder
    healthConditions?: UserHealthConditionOrderByRelationAggregateInput
    allergies?: UserAllergyOrderByRelationAggregateInput
    preferences?: UserPreferencesOrderByWithRelationInput
    mealPlans?: MealPlanOrderByRelationAggregateInput
    shoppingLists?: ShoppingListOrderByRelationAggregateInput
    favoriteRecipes?: UserFavoriteRecipeOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
    abTests?: ABTestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    primaryGoal?: EnumDietaryGoalNullableFilter<"User"> | $Enums.DietaryGoal | null
    preferencesJson?: StringNullableFilter<"User"> | string | null
    healthConditions?: UserHealthConditionListRelationFilter
    allergies?: UserAllergyListRelationFilter
    preferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    mealPlans?: MealPlanListRelationFilter
    shoppingLists?: ShoppingListListRelationFilter
    favoriteRecipes?: UserFavoriteRecipeListRelationFilter
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    feedbacks?: FeedbackListRelationFilter
    abTests?: ABTestListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryGoal?: SortOrderInput | SortOrder
    preferencesJson?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    primaryGoal?: EnumDietaryGoalNullableWithAggregatesFilter<"User"> | $Enums.DietaryGoal | null
    preferencesJson?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: StringFilter<"UserPreferences"> | string
    userId?: StringFilter<"UserPreferences"> | string
    cookingSkillLevel?: EnumCookingSkillFilter<"UserPreferences"> | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFilter<"UserPreferences"> | number
    budgetRange?: EnumBudgetRangeFilter<"UserPreferences"> | $Enums.BudgetRange
    householdSize?: IntFilter<"UserPreferences"> | number
    hasOven?: BoolFilter<"UserPreferences"> | boolean
    hasStove?: BoolFilter<"UserPreferences"> | boolean
    hasMicrowave?: BoolFilter<"UserPreferences"> | boolean
    hasBlender?: BoolFilter<"UserPreferences"> | boolean
    hasAirFryer?: BoolFilter<"UserPreferences"> | boolean
    hasSlowCooker?: BoolFilter<"UserPreferences"> | boolean
    hasInstantPot?: BoolFilter<"UserPreferences"> | boolean
    mealsPerDay?: IntFilter<"UserPreferences"> | number
    snacksPerDay?: IntFilter<"UserPreferences"> | number
    batchCookingPreference?: BoolFilter<"UserPreferences"> | boolean
    energyRestrictionGoal?: StringNullableFilter<"UserPreferences"> | string | null
    targetCaloriesMin?: IntNullableFilter<"UserPreferences"> | number | null
    targetCaloriesMax?: IntNullableFilter<"UserPreferences"> | number | null
    cuisinePreferences?: StringNullableFilter<"UserPreferences"> | string | null
    spiceTolerance?: IntFilter<"UserPreferences"> | number
    flavorIntensity?: IntFilter<"UserPreferences"> | number
    knifeSkillLevel?: StringFilter<"UserPreferences"> | string
    preferredTechniques?: StringNullableFilter<"UserPreferences"> | string | null
    recipeComplexityComfort?: IntFilter<"UserPreferences"> | number
    weeklyFoodBudget?: FloatNullableFilter<"UserPreferences"> | number | null
    shoppingFrequency?: StringFilter<"UserPreferences"> | string
    mealPlanningApproach?: IntFilter<"UserPreferences"> | number
    textureLimitations?: StringNullableFilter<"UserPreferences"> | string | null
    foodsToAvoid?: StringNullableFilter<"UserPreferences"> | string | null
    mealTimingPreference?: StringNullableFilter<"UserPreferences"> | string | null
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appliances?: UserApplianceListRelationFilter
    behaviorProfile?: XOR<UserBehaviorNullableScalarRelationFilter, UserBehaviorWhereInput> | null
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cookingSkillLevel?: SortOrder
    maxPrepTimeMinutes?: SortOrder
    budgetRange?: SortOrder
    householdSize?: SortOrder
    hasOven?: SortOrder
    hasStove?: SortOrder
    hasMicrowave?: SortOrder
    hasBlender?: SortOrder
    hasAirFryer?: SortOrder
    hasSlowCooker?: SortOrder
    hasInstantPot?: SortOrder
    mealsPerDay?: SortOrder
    snacksPerDay?: SortOrder
    batchCookingPreference?: SortOrder
    energyRestrictionGoal?: SortOrderInput | SortOrder
    targetCaloriesMin?: SortOrderInput | SortOrder
    targetCaloriesMax?: SortOrderInput | SortOrder
    cuisinePreferences?: SortOrderInput | SortOrder
    spiceTolerance?: SortOrder
    flavorIntensity?: SortOrder
    knifeSkillLevel?: SortOrder
    preferredTechniques?: SortOrderInput | SortOrder
    recipeComplexityComfort?: SortOrder
    weeklyFoodBudget?: SortOrderInput | SortOrder
    shoppingFrequency?: SortOrder
    mealPlanningApproach?: SortOrder
    textureLimitations?: SortOrderInput | SortOrder
    foodsToAvoid?: SortOrderInput | SortOrder
    mealTimingPreference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    appliances?: UserApplianceOrderByRelationAggregateInput
    behaviorProfile?: UserBehaviorOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    cookingSkillLevel?: EnumCookingSkillFilter<"UserPreferences"> | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFilter<"UserPreferences"> | number
    budgetRange?: EnumBudgetRangeFilter<"UserPreferences"> | $Enums.BudgetRange
    householdSize?: IntFilter<"UserPreferences"> | number
    hasOven?: BoolFilter<"UserPreferences"> | boolean
    hasStove?: BoolFilter<"UserPreferences"> | boolean
    hasMicrowave?: BoolFilter<"UserPreferences"> | boolean
    hasBlender?: BoolFilter<"UserPreferences"> | boolean
    hasAirFryer?: BoolFilter<"UserPreferences"> | boolean
    hasSlowCooker?: BoolFilter<"UserPreferences"> | boolean
    hasInstantPot?: BoolFilter<"UserPreferences"> | boolean
    mealsPerDay?: IntFilter<"UserPreferences"> | number
    snacksPerDay?: IntFilter<"UserPreferences"> | number
    batchCookingPreference?: BoolFilter<"UserPreferences"> | boolean
    energyRestrictionGoal?: StringNullableFilter<"UserPreferences"> | string | null
    targetCaloriesMin?: IntNullableFilter<"UserPreferences"> | number | null
    targetCaloriesMax?: IntNullableFilter<"UserPreferences"> | number | null
    cuisinePreferences?: StringNullableFilter<"UserPreferences"> | string | null
    spiceTolerance?: IntFilter<"UserPreferences"> | number
    flavorIntensity?: IntFilter<"UserPreferences"> | number
    knifeSkillLevel?: StringFilter<"UserPreferences"> | string
    preferredTechniques?: StringNullableFilter<"UserPreferences"> | string | null
    recipeComplexityComfort?: IntFilter<"UserPreferences"> | number
    weeklyFoodBudget?: FloatNullableFilter<"UserPreferences"> | number | null
    shoppingFrequency?: StringFilter<"UserPreferences"> | string
    mealPlanningApproach?: IntFilter<"UserPreferences"> | number
    textureLimitations?: StringNullableFilter<"UserPreferences"> | string | null
    foodsToAvoid?: StringNullableFilter<"UserPreferences"> | string | null
    mealTimingPreference?: StringNullableFilter<"UserPreferences"> | string | null
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    appliances?: UserApplianceListRelationFilter
    behaviorProfile?: XOR<UserBehaviorNullableScalarRelationFilter, UserBehaviorWhereInput> | null
  }, "id" | "userId">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cookingSkillLevel?: SortOrder
    maxPrepTimeMinutes?: SortOrder
    budgetRange?: SortOrder
    householdSize?: SortOrder
    hasOven?: SortOrder
    hasStove?: SortOrder
    hasMicrowave?: SortOrder
    hasBlender?: SortOrder
    hasAirFryer?: SortOrder
    hasSlowCooker?: SortOrder
    hasInstantPot?: SortOrder
    mealsPerDay?: SortOrder
    snacksPerDay?: SortOrder
    batchCookingPreference?: SortOrder
    energyRestrictionGoal?: SortOrderInput | SortOrder
    targetCaloriesMin?: SortOrderInput | SortOrder
    targetCaloriesMax?: SortOrderInput | SortOrder
    cuisinePreferences?: SortOrderInput | SortOrder
    spiceTolerance?: SortOrder
    flavorIntensity?: SortOrder
    knifeSkillLevel?: SortOrder
    preferredTechniques?: SortOrderInput | SortOrder
    recipeComplexityComfort?: SortOrder
    weeklyFoodBudget?: SortOrderInput | SortOrder
    shoppingFrequency?: SortOrder
    mealPlanningApproach?: SortOrder
    textureLimitations?: SortOrderInput | SortOrder
    foodsToAvoid?: SortOrderInput | SortOrder
    mealTimingPreference?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _avg?: UserPreferencesAvgOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
    _sum?: UserPreferencesSumOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreferences"> | string
    userId?: StringWithAggregatesFilter<"UserPreferences"> | string
    cookingSkillLevel?: EnumCookingSkillWithAggregatesFilter<"UserPreferences"> | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntWithAggregatesFilter<"UserPreferences"> | number
    budgetRange?: EnumBudgetRangeWithAggregatesFilter<"UserPreferences"> | $Enums.BudgetRange
    householdSize?: IntWithAggregatesFilter<"UserPreferences"> | number
    hasOven?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    hasStove?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    hasMicrowave?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    hasBlender?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    hasAirFryer?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    hasSlowCooker?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    hasInstantPot?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    mealsPerDay?: IntWithAggregatesFilter<"UserPreferences"> | number
    snacksPerDay?: IntWithAggregatesFilter<"UserPreferences"> | number
    batchCookingPreference?: BoolWithAggregatesFilter<"UserPreferences"> | boolean
    energyRestrictionGoal?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    targetCaloriesMin?: IntNullableWithAggregatesFilter<"UserPreferences"> | number | null
    targetCaloriesMax?: IntNullableWithAggregatesFilter<"UserPreferences"> | number | null
    cuisinePreferences?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    spiceTolerance?: IntWithAggregatesFilter<"UserPreferences"> | number
    flavorIntensity?: IntWithAggregatesFilter<"UserPreferences"> | number
    knifeSkillLevel?: StringWithAggregatesFilter<"UserPreferences"> | string
    preferredTechniques?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    recipeComplexityComfort?: IntWithAggregatesFilter<"UserPreferences"> | number
    weeklyFoodBudget?: FloatNullableWithAggregatesFilter<"UserPreferences"> | number | null
    shoppingFrequency?: StringWithAggregatesFilter<"UserPreferences"> | string
    mealPlanningApproach?: IntWithAggregatesFilter<"UserPreferences"> | number
    textureLimitations?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    foodsToAvoid?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    mealTimingPreference?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
  }

  export type HealthConditionWhereInput = {
    AND?: HealthConditionWhereInput | HealthConditionWhereInput[]
    OR?: HealthConditionWhereInput[]
    NOT?: HealthConditionWhereInput | HealthConditionWhereInput[]
    id?: StringFilter<"HealthCondition"> | string
    name?: StringFilter<"HealthCondition"> | string
    description?: StringNullableFilter<"HealthCondition"> | string | null
    category?: EnumHealthCategoryFilter<"HealthCondition"> | $Enums.HealthCategory
    users?: UserHealthConditionListRelationFilter
  }

  export type HealthConditionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    users?: UserHealthConditionOrderByRelationAggregateInput
  }

  export type HealthConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: HealthConditionWhereInput | HealthConditionWhereInput[]
    OR?: HealthConditionWhereInput[]
    NOT?: HealthConditionWhereInput | HealthConditionWhereInput[]
    description?: StringNullableFilter<"HealthCondition"> | string | null
    category?: EnumHealthCategoryFilter<"HealthCondition"> | $Enums.HealthCategory
    users?: UserHealthConditionListRelationFilter
  }, "id" | "name">

  export type HealthConditionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    _count?: HealthConditionCountOrderByAggregateInput
    _max?: HealthConditionMaxOrderByAggregateInput
    _min?: HealthConditionMinOrderByAggregateInput
  }

  export type HealthConditionScalarWhereWithAggregatesInput = {
    AND?: HealthConditionScalarWhereWithAggregatesInput | HealthConditionScalarWhereWithAggregatesInput[]
    OR?: HealthConditionScalarWhereWithAggregatesInput[]
    NOT?: HealthConditionScalarWhereWithAggregatesInput | HealthConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthCondition"> | string
    name?: StringWithAggregatesFilter<"HealthCondition"> | string
    description?: StringNullableWithAggregatesFilter<"HealthCondition"> | string | null
    category?: EnumHealthCategoryWithAggregatesFilter<"HealthCondition"> | $Enums.HealthCategory
  }

  export type UserHealthConditionWhereInput = {
    AND?: UserHealthConditionWhereInput | UserHealthConditionWhereInput[]
    OR?: UserHealthConditionWhereInput[]
    NOT?: UserHealthConditionWhereInput | UserHealthConditionWhereInput[]
    id?: StringFilter<"UserHealthCondition"> | string
    userId?: StringFilter<"UserHealthCondition"> | string
    healthConditionId?: StringFilter<"UserHealthCondition"> | string
    severity?: EnumSeverityFilter<"UserHealthCondition"> | $Enums.Severity
    diagnosedDate?: DateTimeNullableFilter<"UserHealthCondition"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    healthCondition?: XOR<HealthConditionScalarRelationFilter, HealthConditionWhereInput>
  }

  export type UserHealthConditionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    healthConditionId?: SortOrder
    severity?: SortOrder
    diagnosedDate?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    healthCondition?: HealthConditionOrderByWithRelationInput
  }

  export type UserHealthConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_healthConditionId?: UserHealthConditionUserIdHealthConditionIdCompoundUniqueInput
    AND?: UserHealthConditionWhereInput | UserHealthConditionWhereInput[]
    OR?: UserHealthConditionWhereInput[]
    NOT?: UserHealthConditionWhereInput | UserHealthConditionWhereInput[]
    userId?: StringFilter<"UserHealthCondition"> | string
    healthConditionId?: StringFilter<"UserHealthCondition"> | string
    severity?: EnumSeverityFilter<"UserHealthCondition"> | $Enums.Severity
    diagnosedDate?: DateTimeNullableFilter<"UserHealthCondition"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    healthCondition?: XOR<HealthConditionScalarRelationFilter, HealthConditionWhereInput>
  }, "id" | "userId_healthConditionId">

  export type UserHealthConditionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    healthConditionId?: SortOrder
    severity?: SortOrder
    diagnosedDate?: SortOrderInput | SortOrder
    _count?: UserHealthConditionCountOrderByAggregateInput
    _max?: UserHealthConditionMaxOrderByAggregateInput
    _min?: UserHealthConditionMinOrderByAggregateInput
  }

  export type UserHealthConditionScalarWhereWithAggregatesInput = {
    AND?: UserHealthConditionScalarWhereWithAggregatesInput | UserHealthConditionScalarWhereWithAggregatesInput[]
    OR?: UserHealthConditionScalarWhereWithAggregatesInput[]
    NOT?: UserHealthConditionScalarWhereWithAggregatesInput | UserHealthConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserHealthCondition"> | string
    userId?: StringWithAggregatesFilter<"UserHealthCondition"> | string
    healthConditionId?: StringWithAggregatesFilter<"UserHealthCondition"> | string
    severity?: EnumSeverityWithAggregatesFilter<"UserHealthCondition"> | $Enums.Severity
    diagnosedDate?: DateTimeNullableWithAggregatesFilter<"UserHealthCondition"> | Date | string | null
  }

  export type AllergenWhereInput = {
    AND?: AllergenWhereInput | AllergenWhereInput[]
    OR?: AllergenWhereInput[]
    NOT?: AllergenWhereInput | AllergenWhereInput[]
    id?: StringFilter<"Allergen"> | string
    name?: StringFilter<"Allergen"> | string
    description?: StringNullableFilter<"Allergen"> | string | null
    category?: EnumAllergenCategoryFilter<"Allergen"> | $Enums.AllergenCategory
    users?: UserAllergyListRelationFilter
  }

  export type AllergenOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    users?: UserAllergyOrderByRelationAggregateInput
  }

  export type AllergenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AllergenWhereInput | AllergenWhereInput[]
    OR?: AllergenWhereInput[]
    NOT?: AllergenWhereInput | AllergenWhereInput[]
    description?: StringNullableFilter<"Allergen"> | string | null
    category?: EnumAllergenCategoryFilter<"Allergen"> | $Enums.AllergenCategory
    users?: UserAllergyListRelationFilter
  }, "id" | "name">

  export type AllergenOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    _count?: AllergenCountOrderByAggregateInput
    _max?: AllergenMaxOrderByAggregateInput
    _min?: AllergenMinOrderByAggregateInput
  }

  export type AllergenScalarWhereWithAggregatesInput = {
    AND?: AllergenScalarWhereWithAggregatesInput | AllergenScalarWhereWithAggregatesInput[]
    OR?: AllergenScalarWhereWithAggregatesInput[]
    NOT?: AllergenScalarWhereWithAggregatesInput | AllergenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Allergen"> | string
    name?: StringWithAggregatesFilter<"Allergen"> | string
    description?: StringNullableWithAggregatesFilter<"Allergen"> | string | null
    category?: EnumAllergenCategoryWithAggregatesFilter<"Allergen"> | $Enums.AllergenCategory
  }

  export type UserAllergyWhereInput = {
    AND?: UserAllergyWhereInput | UserAllergyWhereInput[]
    OR?: UserAllergyWhereInput[]
    NOT?: UserAllergyWhereInput | UserAllergyWhereInput[]
    id?: StringFilter<"UserAllergy"> | string
    userId?: StringFilter<"UserAllergy"> | string
    allergenId?: StringFilter<"UserAllergy"> | string
    severity?: EnumSeverityFilter<"UserAllergy"> | $Enums.Severity
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    allergen?: XOR<AllergenScalarRelationFilter, AllergenWhereInput>
  }

  export type UserAllergyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    allergenId?: SortOrder
    severity?: SortOrder
    user?: UserOrderByWithRelationInput
    allergen?: AllergenOrderByWithRelationInput
  }

  export type UserAllergyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_allergenId?: UserAllergyUserIdAllergenIdCompoundUniqueInput
    AND?: UserAllergyWhereInput | UserAllergyWhereInput[]
    OR?: UserAllergyWhereInput[]
    NOT?: UserAllergyWhereInput | UserAllergyWhereInput[]
    userId?: StringFilter<"UserAllergy"> | string
    allergenId?: StringFilter<"UserAllergy"> | string
    severity?: EnumSeverityFilter<"UserAllergy"> | $Enums.Severity
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    allergen?: XOR<AllergenScalarRelationFilter, AllergenWhereInput>
  }, "id" | "userId_allergenId">

  export type UserAllergyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    allergenId?: SortOrder
    severity?: SortOrder
    _count?: UserAllergyCountOrderByAggregateInput
    _max?: UserAllergyMaxOrderByAggregateInput
    _min?: UserAllergyMinOrderByAggregateInput
  }

  export type UserAllergyScalarWhereWithAggregatesInput = {
    AND?: UserAllergyScalarWhereWithAggregatesInput | UserAllergyScalarWhereWithAggregatesInput[]
    OR?: UserAllergyScalarWhereWithAggregatesInput[]
    NOT?: UserAllergyScalarWhereWithAggregatesInput | UserAllergyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAllergy"> | string
    userId?: StringWithAggregatesFilter<"UserAllergy"> | string
    allergenId?: StringWithAggregatesFilter<"UserAllergy"> | string
    severity?: EnumSeverityWithAggregatesFilter<"UserAllergy"> | $Enums.Severity
  }

  export type ApplianceWhereInput = {
    AND?: ApplianceWhereInput | ApplianceWhereInput[]
    OR?: ApplianceWhereInput[]
    NOT?: ApplianceWhereInput | ApplianceWhereInput[]
    id?: StringFilter<"Appliance"> | string
    name?: StringFilter<"Appliance"> | string
    displayName?: StringFilter<"Appliance"> | string
    category?: StringFilter<"Appliance"> | string
    users?: UserApplianceListRelationFilter
  }

  export type ApplianceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    category?: SortOrder
    users?: UserApplianceOrderByRelationAggregateInput
  }

  export type ApplianceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ApplianceWhereInput | ApplianceWhereInput[]
    OR?: ApplianceWhereInput[]
    NOT?: ApplianceWhereInput | ApplianceWhereInput[]
    displayName?: StringFilter<"Appliance"> | string
    category?: StringFilter<"Appliance"> | string
    users?: UserApplianceListRelationFilter
  }, "id" | "name">

  export type ApplianceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    category?: SortOrder
    _count?: ApplianceCountOrderByAggregateInput
    _max?: ApplianceMaxOrderByAggregateInput
    _min?: ApplianceMinOrderByAggregateInput
  }

  export type ApplianceScalarWhereWithAggregatesInput = {
    AND?: ApplianceScalarWhereWithAggregatesInput | ApplianceScalarWhereWithAggregatesInput[]
    OR?: ApplianceScalarWhereWithAggregatesInput[]
    NOT?: ApplianceScalarWhereWithAggregatesInput | ApplianceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appliance"> | string
    name?: StringWithAggregatesFilter<"Appliance"> | string
    displayName?: StringWithAggregatesFilter<"Appliance"> | string
    category?: StringWithAggregatesFilter<"Appliance"> | string
  }

  export type UserApplianceWhereInput = {
    AND?: UserApplianceWhereInput | UserApplianceWhereInput[]
    OR?: UserApplianceWhereInput[]
    NOT?: UserApplianceWhereInput | UserApplianceWhereInput[]
    id?: StringFilter<"UserAppliance"> | string
    userPreferencesId?: StringFilter<"UserAppliance"> | string
    applianceId?: StringFilter<"UserAppliance"> | string
    usageFrequency?: IntFilter<"UserAppliance"> | number
    userPreferences?: XOR<UserPreferencesScalarRelationFilter, UserPreferencesWhereInput>
    appliance?: XOR<ApplianceScalarRelationFilter, ApplianceWhereInput>
  }

  export type UserApplianceOrderByWithRelationInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    applianceId?: SortOrder
    usageFrequency?: SortOrder
    userPreferences?: UserPreferencesOrderByWithRelationInput
    appliance?: ApplianceOrderByWithRelationInput
  }

  export type UserApplianceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userPreferencesId_applianceId?: UserApplianceUserPreferencesIdApplianceIdCompoundUniqueInput
    AND?: UserApplianceWhereInput | UserApplianceWhereInput[]
    OR?: UserApplianceWhereInput[]
    NOT?: UserApplianceWhereInput | UserApplianceWhereInput[]
    userPreferencesId?: StringFilter<"UserAppliance"> | string
    applianceId?: StringFilter<"UserAppliance"> | string
    usageFrequency?: IntFilter<"UserAppliance"> | number
    userPreferences?: XOR<UserPreferencesScalarRelationFilter, UserPreferencesWhereInput>
    appliance?: XOR<ApplianceScalarRelationFilter, ApplianceWhereInput>
  }, "id" | "userPreferencesId_applianceId">

  export type UserApplianceOrderByWithAggregationInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    applianceId?: SortOrder
    usageFrequency?: SortOrder
    _count?: UserApplianceCountOrderByAggregateInput
    _avg?: UserApplianceAvgOrderByAggregateInput
    _max?: UserApplianceMaxOrderByAggregateInput
    _min?: UserApplianceMinOrderByAggregateInput
    _sum?: UserApplianceSumOrderByAggregateInput
  }

  export type UserApplianceScalarWhereWithAggregatesInput = {
    AND?: UserApplianceScalarWhereWithAggregatesInput | UserApplianceScalarWhereWithAggregatesInput[]
    OR?: UserApplianceScalarWhereWithAggregatesInput[]
    NOT?: UserApplianceScalarWhereWithAggregatesInput | UserApplianceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAppliance"> | string
    userPreferencesId?: StringWithAggregatesFilter<"UserAppliance"> | string
    applianceId?: StringWithAggregatesFilter<"UserAppliance"> | string
    usageFrequency?: IntWithAggregatesFilter<"UserAppliance"> | number
  }

  export type UserBehaviorWhereInput = {
    AND?: UserBehaviorWhereInput | UserBehaviorWhereInput[]
    OR?: UserBehaviorWhereInput[]
    NOT?: UserBehaviorWhereInput | UserBehaviorWhereInput[]
    id?: StringFilter<"UserBehavior"> | string
    userPreferencesId?: StringFilter<"UserBehavior"> | string
    portionControlMotivation?: IntFilter<"UserBehavior"> | number
    habitChangeReadiness?: StringNullableFilter<"UserBehavior"> | string | null
    socialEatingPattern?: IntFilter<"UserBehavior"> | number
    successTrackingPreference?: StringFilter<"UserBehavior"> | string
    activityLevel?: StringFilter<"UserBehavior"> | string
    healthConditionPriority?: IntFilter<"UserBehavior"> | number
    createdAt?: DateTimeFilter<"UserBehavior"> | Date | string
    updatedAt?: DateTimeFilter<"UserBehavior"> | Date | string
    userPreferences?: XOR<UserPreferencesScalarRelationFilter, UserPreferencesWhereInput>
  }

  export type UserBehaviorOrderByWithRelationInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    portionControlMotivation?: SortOrder
    habitChangeReadiness?: SortOrderInput | SortOrder
    socialEatingPattern?: SortOrder
    successTrackingPreference?: SortOrder
    activityLevel?: SortOrder
    healthConditionPriority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userPreferences?: UserPreferencesOrderByWithRelationInput
  }

  export type UserBehaviorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userPreferencesId?: string
    AND?: UserBehaviorWhereInput | UserBehaviorWhereInput[]
    OR?: UserBehaviorWhereInput[]
    NOT?: UserBehaviorWhereInput | UserBehaviorWhereInput[]
    portionControlMotivation?: IntFilter<"UserBehavior"> | number
    habitChangeReadiness?: StringNullableFilter<"UserBehavior"> | string | null
    socialEatingPattern?: IntFilter<"UserBehavior"> | number
    successTrackingPreference?: StringFilter<"UserBehavior"> | string
    activityLevel?: StringFilter<"UserBehavior"> | string
    healthConditionPriority?: IntFilter<"UserBehavior"> | number
    createdAt?: DateTimeFilter<"UserBehavior"> | Date | string
    updatedAt?: DateTimeFilter<"UserBehavior"> | Date | string
    userPreferences?: XOR<UserPreferencesScalarRelationFilter, UserPreferencesWhereInput>
  }, "id" | "userPreferencesId">

  export type UserBehaviorOrderByWithAggregationInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    portionControlMotivation?: SortOrder
    habitChangeReadiness?: SortOrderInput | SortOrder
    socialEatingPattern?: SortOrder
    successTrackingPreference?: SortOrder
    activityLevel?: SortOrder
    healthConditionPriority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserBehaviorCountOrderByAggregateInput
    _avg?: UserBehaviorAvgOrderByAggregateInput
    _max?: UserBehaviorMaxOrderByAggregateInput
    _min?: UserBehaviorMinOrderByAggregateInput
    _sum?: UserBehaviorSumOrderByAggregateInput
  }

  export type UserBehaviorScalarWhereWithAggregatesInput = {
    AND?: UserBehaviorScalarWhereWithAggregatesInput | UserBehaviorScalarWhereWithAggregatesInput[]
    OR?: UserBehaviorScalarWhereWithAggregatesInput[]
    NOT?: UserBehaviorScalarWhereWithAggregatesInput | UserBehaviorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBehavior"> | string
    userPreferencesId?: StringWithAggregatesFilter<"UserBehavior"> | string
    portionControlMotivation?: IntWithAggregatesFilter<"UserBehavior"> | number
    habitChangeReadiness?: StringNullableWithAggregatesFilter<"UserBehavior"> | string | null
    socialEatingPattern?: IntWithAggregatesFilter<"UserBehavior"> | number
    successTrackingPreference?: StringWithAggregatesFilter<"UserBehavior"> | string
    activityLevel?: StringWithAggregatesFilter<"UserBehavior"> | string
    healthConditionPriority?: IntWithAggregatesFilter<"UserBehavior"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserBehavior"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserBehavior"> | Date | string
  }

  export type SpiceBlendWhereInput = {
    AND?: SpiceBlendWhereInput | SpiceBlendWhereInput[]
    OR?: SpiceBlendWhereInput[]
    NOT?: SpiceBlendWhereInput | SpiceBlendWhereInput[]
    id?: StringFilter<"SpiceBlend"> | string
    name?: StringFilter<"SpiceBlend"> | string
    displayName?: StringFilter<"SpiceBlend"> | string
    activeCompounds?: StringFilter<"SpiceBlend"> | string
    clinicalEvidence?: StringFilter<"SpiceBlend"> | string
    primaryBenefit?: StringFilter<"SpiceBlend"> | string
    effectiveDoseGrams?: FloatFilter<"SpiceBlend"> | number
    bioavailabilityHack?: StringNullableFilter<"SpiceBlend"> | string | null
    quickApplications?: StringFilter<"SpiceBlend"> | string
    recipes?: RecipeSpiceBlendListRelationFilter
  }

  export type SpiceBlendOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    activeCompounds?: SortOrder
    clinicalEvidence?: SortOrder
    primaryBenefit?: SortOrder
    effectiveDoseGrams?: SortOrder
    bioavailabilityHack?: SortOrderInput | SortOrder
    quickApplications?: SortOrder
    recipes?: RecipeSpiceBlendOrderByRelationAggregateInput
  }

  export type SpiceBlendWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SpiceBlendWhereInput | SpiceBlendWhereInput[]
    OR?: SpiceBlendWhereInput[]
    NOT?: SpiceBlendWhereInput | SpiceBlendWhereInput[]
    displayName?: StringFilter<"SpiceBlend"> | string
    activeCompounds?: StringFilter<"SpiceBlend"> | string
    clinicalEvidence?: StringFilter<"SpiceBlend"> | string
    primaryBenefit?: StringFilter<"SpiceBlend"> | string
    effectiveDoseGrams?: FloatFilter<"SpiceBlend"> | number
    bioavailabilityHack?: StringNullableFilter<"SpiceBlend"> | string | null
    quickApplications?: StringFilter<"SpiceBlend"> | string
    recipes?: RecipeSpiceBlendListRelationFilter
  }, "id" | "name">

  export type SpiceBlendOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    activeCompounds?: SortOrder
    clinicalEvidence?: SortOrder
    primaryBenefit?: SortOrder
    effectiveDoseGrams?: SortOrder
    bioavailabilityHack?: SortOrderInput | SortOrder
    quickApplications?: SortOrder
    _count?: SpiceBlendCountOrderByAggregateInput
    _avg?: SpiceBlendAvgOrderByAggregateInput
    _max?: SpiceBlendMaxOrderByAggregateInput
    _min?: SpiceBlendMinOrderByAggregateInput
    _sum?: SpiceBlendSumOrderByAggregateInput
  }

  export type SpiceBlendScalarWhereWithAggregatesInput = {
    AND?: SpiceBlendScalarWhereWithAggregatesInput | SpiceBlendScalarWhereWithAggregatesInput[]
    OR?: SpiceBlendScalarWhereWithAggregatesInput[]
    NOT?: SpiceBlendScalarWhereWithAggregatesInput | SpiceBlendScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpiceBlend"> | string
    name?: StringWithAggregatesFilter<"SpiceBlend"> | string
    displayName?: StringWithAggregatesFilter<"SpiceBlend"> | string
    activeCompounds?: StringWithAggregatesFilter<"SpiceBlend"> | string
    clinicalEvidence?: StringWithAggregatesFilter<"SpiceBlend"> | string
    primaryBenefit?: StringWithAggregatesFilter<"SpiceBlend"> | string
    effectiveDoseGrams?: FloatWithAggregatesFilter<"SpiceBlend"> | number
    bioavailabilityHack?: StringNullableWithAggregatesFilter<"SpiceBlend"> | string | null
    quickApplications?: StringWithAggregatesFilter<"SpiceBlend"> | string
  }

  export type RecipeSpiceBlendWhereInput = {
    AND?: RecipeSpiceBlendWhereInput | RecipeSpiceBlendWhereInput[]
    OR?: RecipeSpiceBlendWhereInput[]
    NOT?: RecipeSpiceBlendWhereInput | RecipeSpiceBlendWhereInput[]
    id?: StringFilter<"RecipeSpiceBlend"> | string
    recipeId?: StringFilter<"RecipeSpiceBlend"> | string
    spiceBlendId?: StringFilter<"RecipeSpiceBlend"> | string
    amountGrams?: FloatFilter<"RecipeSpiceBlend"> | number
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    spiceBlend?: XOR<SpiceBlendScalarRelationFilter, SpiceBlendWhereInput>
  }

  export type RecipeSpiceBlendOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    spiceBlendId?: SortOrder
    amountGrams?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    spiceBlend?: SpiceBlendOrderByWithRelationInput
  }

  export type RecipeSpiceBlendWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    recipeId_spiceBlendId?: RecipeSpiceBlendRecipeIdSpiceBlendIdCompoundUniqueInput
    AND?: RecipeSpiceBlendWhereInput | RecipeSpiceBlendWhereInput[]
    OR?: RecipeSpiceBlendWhereInput[]
    NOT?: RecipeSpiceBlendWhereInput | RecipeSpiceBlendWhereInput[]
    recipeId?: StringFilter<"RecipeSpiceBlend"> | string
    spiceBlendId?: StringFilter<"RecipeSpiceBlend"> | string
    amountGrams?: FloatFilter<"RecipeSpiceBlend"> | number
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    spiceBlend?: XOR<SpiceBlendScalarRelationFilter, SpiceBlendWhereInput>
  }, "id" | "recipeId_spiceBlendId">

  export type RecipeSpiceBlendOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    spiceBlendId?: SortOrder
    amountGrams?: SortOrder
    _count?: RecipeSpiceBlendCountOrderByAggregateInput
    _avg?: RecipeSpiceBlendAvgOrderByAggregateInput
    _max?: RecipeSpiceBlendMaxOrderByAggregateInput
    _min?: RecipeSpiceBlendMinOrderByAggregateInput
    _sum?: RecipeSpiceBlendSumOrderByAggregateInput
  }

  export type RecipeSpiceBlendScalarWhereWithAggregatesInput = {
    AND?: RecipeSpiceBlendScalarWhereWithAggregatesInput | RecipeSpiceBlendScalarWhereWithAggregatesInput[]
    OR?: RecipeSpiceBlendScalarWhereWithAggregatesInput[]
    NOT?: RecipeSpiceBlendScalarWhereWithAggregatesInput | RecipeSpiceBlendScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeSpiceBlend"> | string
    recipeId?: StringWithAggregatesFilter<"RecipeSpiceBlend"> | string
    spiceBlendId?: StringWithAggregatesFilter<"RecipeSpiceBlend"> | string
    amountGrams?: FloatWithAggregatesFilter<"RecipeSpiceBlend"> | number
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: StringFilter<"Recipe"> | string
    name?: StringFilter<"Recipe"> | string
    description?: StringNullableFilter<"Recipe"> | string | null
    servings?: IntFilter<"Recipe"> | number
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    prepTimeMinutes?: IntFilter<"Recipe"> | number
    cookTimeMinutes?: IntFilter<"Recipe"> | number
    totalTimeMinutes?: IntFilter<"Recipe"> | number
    complexity?: IntFilter<"Recipe"> | number
    costTier?: StringFilter<"Recipe"> | string
    requiredAppliances?: StringFilter<"Recipe"> | string
    goalTags?: StringFilter<"Recipe"> | string
    ingredients?: RecipeIngredientListRelationFilter
    instructions?: RecipeInstructionListRelationFilter
    medicalTags?: RecipeMedicalTagListRelationFilter
    dietaryTags?: RecipeDietaryTagListRelationFilter
    practicalTags?: RecipePracticalTagListRelationFilter
    nutritionalTags?: RecipeNutritionalTagListRelationFilter
    spiceBlends?: RecipeSpiceBlendListRelationFilter
    nutritionalInfo?: XOR<NutritionalInfoNullableScalarRelationFilter, NutritionalInfoWhereInput> | null
    favorites?: UserFavoriteRecipeListRelationFilter
    mealPlanItems?: MealPlanItemListRelationFilter
    feedbacks?: FeedbackListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    servings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepTimeMinutes?: SortOrder
    cookTimeMinutes?: SortOrder
    totalTimeMinutes?: SortOrder
    complexity?: SortOrder
    costTier?: SortOrder
    requiredAppliances?: SortOrder
    goalTags?: SortOrder
    ingredients?: RecipeIngredientOrderByRelationAggregateInput
    instructions?: RecipeInstructionOrderByRelationAggregateInput
    medicalTags?: RecipeMedicalTagOrderByRelationAggregateInput
    dietaryTags?: RecipeDietaryTagOrderByRelationAggregateInput
    practicalTags?: RecipePracticalTagOrderByRelationAggregateInput
    nutritionalTags?: RecipeNutritionalTagOrderByRelationAggregateInput
    spiceBlends?: RecipeSpiceBlendOrderByRelationAggregateInput
    nutritionalInfo?: NutritionalInfoOrderByWithRelationInput
    favorites?: UserFavoriteRecipeOrderByRelationAggregateInput
    mealPlanItems?: MealPlanItemOrderByRelationAggregateInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    name?: StringFilter<"Recipe"> | string
    description?: StringNullableFilter<"Recipe"> | string | null
    servings?: IntFilter<"Recipe"> | number
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    prepTimeMinutes?: IntFilter<"Recipe"> | number
    cookTimeMinutes?: IntFilter<"Recipe"> | number
    totalTimeMinutes?: IntFilter<"Recipe"> | number
    complexity?: IntFilter<"Recipe"> | number
    costTier?: StringFilter<"Recipe"> | string
    requiredAppliances?: StringFilter<"Recipe"> | string
    goalTags?: StringFilter<"Recipe"> | string
    ingredients?: RecipeIngredientListRelationFilter
    instructions?: RecipeInstructionListRelationFilter
    medicalTags?: RecipeMedicalTagListRelationFilter
    dietaryTags?: RecipeDietaryTagListRelationFilter
    practicalTags?: RecipePracticalTagListRelationFilter
    nutritionalTags?: RecipeNutritionalTagListRelationFilter
    spiceBlends?: RecipeSpiceBlendListRelationFilter
    nutritionalInfo?: XOR<NutritionalInfoNullableScalarRelationFilter, NutritionalInfoWhereInput> | null
    favorites?: UserFavoriteRecipeListRelationFilter
    mealPlanItems?: MealPlanItemListRelationFilter
    feedbacks?: FeedbackListRelationFilter
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    servings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepTimeMinutes?: SortOrder
    cookTimeMinutes?: SortOrder
    totalTimeMinutes?: SortOrder
    complexity?: SortOrder
    costTier?: SortOrder
    requiredAppliances?: SortOrder
    goalTags?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipe"> | string
    name?: StringWithAggregatesFilter<"Recipe"> | string
    description?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    servings?: IntWithAggregatesFilter<"Recipe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    prepTimeMinutes?: IntWithAggregatesFilter<"Recipe"> | number
    cookTimeMinutes?: IntWithAggregatesFilter<"Recipe"> | number
    totalTimeMinutes?: IntWithAggregatesFilter<"Recipe"> | number
    complexity?: IntWithAggregatesFilter<"Recipe"> | number
    costTier?: StringWithAggregatesFilter<"Recipe"> | string
    requiredAppliances?: StringWithAggregatesFilter<"Recipe"> | string
    goalTags?: StringWithAggregatesFilter<"Recipe"> | string
  }

  export type RecipeIngredientWhereInput = {
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    id?: StringFilter<"RecipeIngredient"> | string
    recipeId?: StringFilter<"RecipeIngredient"> | string
    name?: StringFilter<"RecipeIngredient"> | string
    amount?: FloatFilter<"RecipeIngredient"> | number
    unit?: StringFilter<"RecipeIngredient"> | string
    notes?: StringNullableFilter<"RecipeIngredient"> | string | null
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }

  export type RecipeIngredientOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    recipe?: RecipeOrderByWithRelationInput
  }

  export type RecipeIngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    recipeId?: StringFilter<"RecipeIngredient"> | string
    name?: StringFilter<"RecipeIngredient"> | string
    amount?: FloatFilter<"RecipeIngredient"> | number
    unit?: StringFilter<"RecipeIngredient"> | string
    notes?: StringNullableFilter<"RecipeIngredient"> | string | null
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }, "id">

  export type RecipeIngredientOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: RecipeIngredientCountOrderByAggregateInput
    _avg?: RecipeIngredientAvgOrderByAggregateInput
    _max?: RecipeIngredientMaxOrderByAggregateInput
    _min?: RecipeIngredientMinOrderByAggregateInput
    _sum?: RecipeIngredientSumOrderByAggregateInput
  }

  export type RecipeIngredientScalarWhereWithAggregatesInput = {
    AND?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    OR?: RecipeIngredientScalarWhereWithAggregatesInput[]
    NOT?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    recipeId?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    name?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    amount?: FloatWithAggregatesFilter<"RecipeIngredient"> | number
    unit?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    notes?: StringNullableWithAggregatesFilter<"RecipeIngredient"> | string | null
  }

  export type RecipeInstructionWhereInput = {
    AND?: RecipeInstructionWhereInput | RecipeInstructionWhereInput[]
    OR?: RecipeInstructionWhereInput[]
    NOT?: RecipeInstructionWhereInput | RecipeInstructionWhereInput[]
    id?: StringFilter<"RecipeInstruction"> | string
    recipeId?: StringFilter<"RecipeInstruction"> | string
    stepNumber?: IntFilter<"RecipeInstruction"> | number
    instruction?: StringFilter<"RecipeInstruction"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }

  export type RecipeInstructionOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
  }

  export type RecipeInstructionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeInstructionWhereInput | RecipeInstructionWhereInput[]
    OR?: RecipeInstructionWhereInput[]
    NOT?: RecipeInstructionWhereInput | RecipeInstructionWhereInput[]
    recipeId?: StringFilter<"RecipeInstruction"> | string
    stepNumber?: IntFilter<"RecipeInstruction"> | number
    instruction?: StringFilter<"RecipeInstruction"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }, "id">

  export type RecipeInstructionOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
    _count?: RecipeInstructionCountOrderByAggregateInput
    _avg?: RecipeInstructionAvgOrderByAggregateInput
    _max?: RecipeInstructionMaxOrderByAggregateInput
    _min?: RecipeInstructionMinOrderByAggregateInput
    _sum?: RecipeInstructionSumOrderByAggregateInput
  }

  export type RecipeInstructionScalarWhereWithAggregatesInput = {
    AND?: RecipeInstructionScalarWhereWithAggregatesInput | RecipeInstructionScalarWhereWithAggregatesInput[]
    OR?: RecipeInstructionScalarWhereWithAggregatesInput[]
    NOT?: RecipeInstructionScalarWhereWithAggregatesInput | RecipeInstructionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeInstruction"> | string
    recipeId?: StringWithAggregatesFilter<"RecipeInstruction"> | string
    stepNumber?: IntWithAggregatesFilter<"RecipeInstruction"> | number
    instruction?: StringWithAggregatesFilter<"RecipeInstruction"> | string
  }

  export type NutritionalInfoWhereInput = {
    AND?: NutritionalInfoWhereInput | NutritionalInfoWhereInput[]
    OR?: NutritionalInfoWhereInput[]
    NOT?: NutritionalInfoWhereInput | NutritionalInfoWhereInput[]
    id?: StringFilter<"NutritionalInfo"> | string
    recipeId?: StringFilter<"NutritionalInfo"> | string
    calories?: FloatNullableFilter<"NutritionalInfo"> | number | null
    protein?: FloatNullableFilter<"NutritionalInfo"> | number | null
    carbohydrates?: FloatNullableFilter<"NutritionalInfo"> | number | null
    fat?: FloatNullableFilter<"NutritionalInfo"> | number | null
    fiber?: FloatNullableFilter<"NutritionalInfo"> | number | null
    sugar?: FloatNullableFilter<"NutritionalInfo"> | number | null
    sodium?: FloatNullableFilter<"NutritionalInfo"> | number | null
    cholesterol?: FloatNullableFilter<"NutritionalInfo"> | number | null
    vitaminC?: FloatNullableFilter<"NutritionalInfo"> | number | null
    vitaminD?: FloatNullableFilter<"NutritionalInfo"> | number | null
    calcium?: FloatNullableFilter<"NutritionalInfo"> | number | null
    iron?: FloatNullableFilter<"NutritionalInfo"> | number | null
    potassium?: FloatNullableFilter<"NutritionalInfo"> | number | null
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }

  export type NutritionalInfoOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    calories?: SortOrderInput | SortOrder
    protein?: SortOrderInput | SortOrder
    carbohydrates?: SortOrderInput | SortOrder
    fat?: SortOrderInput | SortOrder
    fiber?: SortOrderInput | SortOrder
    sugar?: SortOrderInput | SortOrder
    sodium?: SortOrderInput | SortOrder
    cholesterol?: SortOrderInput | SortOrder
    vitaminC?: SortOrderInput | SortOrder
    vitaminD?: SortOrderInput | SortOrder
    calcium?: SortOrderInput | SortOrder
    iron?: SortOrderInput | SortOrder
    potassium?: SortOrderInput | SortOrder
    recipe?: RecipeOrderByWithRelationInput
  }

  export type NutritionalInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    recipeId?: string
    AND?: NutritionalInfoWhereInput | NutritionalInfoWhereInput[]
    OR?: NutritionalInfoWhereInput[]
    NOT?: NutritionalInfoWhereInput | NutritionalInfoWhereInput[]
    calories?: FloatNullableFilter<"NutritionalInfo"> | number | null
    protein?: FloatNullableFilter<"NutritionalInfo"> | number | null
    carbohydrates?: FloatNullableFilter<"NutritionalInfo"> | number | null
    fat?: FloatNullableFilter<"NutritionalInfo"> | number | null
    fiber?: FloatNullableFilter<"NutritionalInfo"> | number | null
    sugar?: FloatNullableFilter<"NutritionalInfo"> | number | null
    sodium?: FloatNullableFilter<"NutritionalInfo"> | number | null
    cholesterol?: FloatNullableFilter<"NutritionalInfo"> | number | null
    vitaminC?: FloatNullableFilter<"NutritionalInfo"> | number | null
    vitaminD?: FloatNullableFilter<"NutritionalInfo"> | number | null
    calcium?: FloatNullableFilter<"NutritionalInfo"> | number | null
    iron?: FloatNullableFilter<"NutritionalInfo"> | number | null
    potassium?: FloatNullableFilter<"NutritionalInfo"> | number | null
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }, "id" | "recipeId">

  export type NutritionalInfoOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    calories?: SortOrderInput | SortOrder
    protein?: SortOrderInput | SortOrder
    carbohydrates?: SortOrderInput | SortOrder
    fat?: SortOrderInput | SortOrder
    fiber?: SortOrderInput | SortOrder
    sugar?: SortOrderInput | SortOrder
    sodium?: SortOrderInput | SortOrder
    cholesterol?: SortOrderInput | SortOrder
    vitaminC?: SortOrderInput | SortOrder
    vitaminD?: SortOrderInput | SortOrder
    calcium?: SortOrderInput | SortOrder
    iron?: SortOrderInput | SortOrder
    potassium?: SortOrderInput | SortOrder
    _count?: NutritionalInfoCountOrderByAggregateInput
    _avg?: NutritionalInfoAvgOrderByAggregateInput
    _max?: NutritionalInfoMaxOrderByAggregateInput
    _min?: NutritionalInfoMinOrderByAggregateInput
    _sum?: NutritionalInfoSumOrderByAggregateInput
  }

  export type NutritionalInfoScalarWhereWithAggregatesInput = {
    AND?: NutritionalInfoScalarWhereWithAggregatesInput | NutritionalInfoScalarWhereWithAggregatesInput[]
    OR?: NutritionalInfoScalarWhereWithAggregatesInput[]
    NOT?: NutritionalInfoScalarWhereWithAggregatesInput | NutritionalInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NutritionalInfo"> | string
    recipeId?: StringWithAggregatesFilter<"NutritionalInfo"> | string
    calories?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    protein?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    carbohydrates?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    fat?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    fiber?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    sugar?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    sodium?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    cholesterol?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    vitaminC?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    vitaminD?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    calcium?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    iron?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
    potassium?: FloatNullableWithAggregatesFilter<"NutritionalInfo"> | number | null
  }

  export type MedicalTagWhereInput = {
    AND?: MedicalTagWhereInput | MedicalTagWhereInput[]
    OR?: MedicalTagWhereInput[]
    NOT?: MedicalTagWhereInput | MedicalTagWhereInput[]
    id?: StringFilter<"MedicalTag"> | string
    name?: StringFilter<"MedicalTag"> | string
    description?: StringNullableFilter<"MedicalTag"> | string | null
    condition?: StringFilter<"MedicalTag"> | string
    recipes?: RecipeMedicalTagListRelationFilter
  }

  export type MedicalTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    condition?: SortOrder
    recipes?: RecipeMedicalTagOrderByRelationAggregateInput
  }

  export type MedicalTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MedicalTagWhereInput | MedicalTagWhereInput[]
    OR?: MedicalTagWhereInput[]
    NOT?: MedicalTagWhereInput | MedicalTagWhereInput[]
    description?: StringNullableFilter<"MedicalTag"> | string | null
    condition?: StringFilter<"MedicalTag"> | string
    recipes?: RecipeMedicalTagListRelationFilter
  }, "id" | "name">

  export type MedicalTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    condition?: SortOrder
    _count?: MedicalTagCountOrderByAggregateInput
    _max?: MedicalTagMaxOrderByAggregateInput
    _min?: MedicalTagMinOrderByAggregateInput
  }

  export type MedicalTagScalarWhereWithAggregatesInput = {
    AND?: MedicalTagScalarWhereWithAggregatesInput | MedicalTagScalarWhereWithAggregatesInput[]
    OR?: MedicalTagScalarWhereWithAggregatesInput[]
    NOT?: MedicalTagScalarWhereWithAggregatesInput | MedicalTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalTag"> | string
    name?: StringWithAggregatesFilter<"MedicalTag"> | string
    description?: StringNullableWithAggregatesFilter<"MedicalTag"> | string | null
    condition?: StringWithAggregatesFilter<"MedicalTag"> | string
  }

  export type RecipeMedicalTagWhereInput = {
    AND?: RecipeMedicalTagWhereInput | RecipeMedicalTagWhereInput[]
    OR?: RecipeMedicalTagWhereInput[]
    NOT?: RecipeMedicalTagWhereInput | RecipeMedicalTagWhereInput[]
    id?: StringFilter<"RecipeMedicalTag"> | string
    recipeId?: StringFilter<"RecipeMedicalTag"> | string
    medicalTagId?: StringFilter<"RecipeMedicalTag"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    medicalTag?: XOR<MedicalTagScalarRelationFilter, MedicalTagWhereInput>
  }

  export type RecipeMedicalTagOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    medicalTagId?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    medicalTag?: MedicalTagOrderByWithRelationInput
  }

  export type RecipeMedicalTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    recipeId_medicalTagId?: RecipeMedicalTagRecipeIdMedicalTagIdCompoundUniqueInput
    AND?: RecipeMedicalTagWhereInput | RecipeMedicalTagWhereInput[]
    OR?: RecipeMedicalTagWhereInput[]
    NOT?: RecipeMedicalTagWhereInput | RecipeMedicalTagWhereInput[]
    recipeId?: StringFilter<"RecipeMedicalTag"> | string
    medicalTagId?: StringFilter<"RecipeMedicalTag"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    medicalTag?: XOR<MedicalTagScalarRelationFilter, MedicalTagWhereInput>
  }, "id" | "recipeId_medicalTagId">

  export type RecipeMedicalTagOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    medicalTagId?: SortOrder
    _count?: RecipeMedicalTagCountOrderByAggregateInput
    _max?: RecipeMedicalTagMaxOrderByAggregateInput
    _min?: RecipeMedicalTagMinOrderByAggregateInput
  }

  export type RecipeMedicalTagScalarWhereWithAggregatesInput = {
    AND?: RecipeMedicalTagScalarWhereWithAggregatesInput | RecipeMedicalTagScalarWhereWithAggregatesInput[]
    OR?: RecipeMedicalTagScalarWhereWithAggregatesInput[]
    NOT?: RecipeMedicalTagScalarWhereWithAggregatesInput | RecipeMedicalTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeMedicalTag"> | string
    recipeId?: StringWithAggregatesFilter<"RecipeMedicalTag"> | string
    medicalTagId?: StringWithAggregatesFilter<"RecipeMedicalTag"> | string
  }

  export type DietaryTagWhereInput = {
    AND?: DietaryTagWhereInput | DietaryTagWhereInput[]
    OR?: DietaryTagWhereInput[]
    NOT?: DietaryTagWhereInput | DietaryTagWhereInput[]
    id?: StringFilter<"DietaryTag"> | string
    name?: StringFilter<"DietaryTag"> | string
    description?: StringNullableFilter<"DietaryTag"> | string | null
    category?: EnumDietaryCategoryFilter<"DietaryTag"> | $Enums.DietaryCategory
    recipes?: RecipeDietaryTagListRelationFilter
  }

  export type DietaryTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    recipes?: RecipeDietaryTagOrderByRelationAggregateInput
  }

  export type DietaryTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DietaryTagWhereInput | DietaryTagWhereInput[]
    OR?: DietaryTagWhereInput[]
    NOT?: DietaryTagWhereInput | DietaryTagWhereInput[]
    description?: StringNullableFilter<"DietaryTag"> | string | null
    category?: EnumDietaryCategoryFilter<"DietaryTag"> | $Enums.DietaryCategory
    recipes?: RecipeDietaryTagListRelationFilter
  }, "id" | "name">

  export type DietaryTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    _count?: DietaryTagCountOrderByAggregateInput
    _max?: DietaryTagMaxOrderByAggregateInput
    _min?: DietaryTagMinOrderByAggregateInput
  }

  export type DietaryTagScalarWhereWithAggregatesInput = {
    AND?: DietaryTagScalarWhereWithAggregatesInput | DietaryTagScalarWhereWithAggregatesInput[]
    OR?: DietaryTagScalarWhereWithAggregatesInput[]
    NOT?: DietaryTagScalarWhereWithAggregatesInput | DietaryTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DietaryTag"> | string
    name?: StringWithAggregatesFilter<"DietaryTag"> | string
    description?: StringNullableWithAggregatesFilter<"DietaryTag"> | string | null
    category?: EnumDietaryCategoryWithAggregatesFilter<"DietaryTag"> | $Enums.DietaryCategory
  }

  export type RecipeDietaryTagWhereInput = {
    AND?: RecipeDietaryTagWhereInput | RecipeDietaryTagWhereInput[]
    OR?: RecipeDietaryTagWhereInput[]
    NOT?: RecipeDietaryTagWhereInput | RecipeDietaryTagWhereInput[]
    id?: StringFilter<"RecipeDietaryTag"> | string
    recipeId?: StringFilter<"RecipeDietaryTag"> | string
    dietaryTagId?: StringFilter<"RecipeDietaryTag"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    dietaryTag?: XOR<DietaryTagScalarRelationFilter, DietaryTagWhereInput>
  }

  export type RecipeDietaryTagOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    dietaryTagId?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    dietaryTag?: DietaryTagOrderByWithRelationInput
  }

  export type RecipeDietaryTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    recipeId_dietaryTagId?: RecipeDietaryTagRecipeIdDietaryTagIdCompoundUniqueInput
    AND?: RecipeDietaryTagWhereInput | RecipeDietaryTagWhereInput[]
    OR?: RecipeDietaryTagWhereInput[]
    NOT?: RecipeDietaryTagWhereInput | RecipeDietaryTagWhereInput[]
    recipeId?: StringFilter<"RecipeDietaryTag"> | string
    dietaryTagId?: StringFilter<"RecipeDietaryTag"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    dietaryTag?: XOR<DietaryTagScalarRelationFilter, DietaryTagWhereInput>
  }, "id" | "recipeId_dietaryTagId">

  export type RecipeDietaryTagOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    dietaryTagId?: SortOrder
    _count?: RecipeDietaryTagCountOrderByAggregateInput
    _max?: RecipeDietaryTagMaxOrderByAggregateInput
    _min?: RecipeDietaryTagMinOrderByAggregateInput
  }

  export type RecipeDietaryTagScalarWhereWithAggregatesInput = {
    AND?: RecipeDietaryTagScalarWhereWithAggregatesInput | RecipeDietaryTagScalarWhereWithAggregatesInput[]
    OR?: RecipeDietaryTagScalarWhereWithAggregatesInput[]
    NOT?: RecipeDietaryTagScalarWhereWithAggregatesInput | RecipeDietaryTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeDietaryTag"> | string
    recipeId?: StringWithAggregatesFilter<"RecipeDietaryTag"> | string
    dietaryTagId?: StringWithAggregatesFilter<"RecipeDietaryTag"> | string
  }

  export type PracticalTagWhereInput = {
    AND?: PracticalTagWhereInput | PracticalTagWhereInput[]
    OR?: PracticalTagWhereInput[]
    NOT?: PracticalTagWhereInput | PracticalTagWhereInput[]
    id?: StringFilter<"PracticalTag"> | string
    name?: StringFilter<"PracticalTag"> | string
    description?: StringNullableFilter<"PracticalTag"> | string | null
    category?: EnumPracticalCategoryFilter<"PracticalTag"> | $Enums.PracticalCategory
    recipes?: RecipePracticalTagListRelationFilter
  }

  export type PracticalTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    recipes?: RecipePracticalTagOrderByRelationAggregateInput
  }

  export type PracticalTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: PracticalTagWhereInput | PracticalTagWhereInput[]
    OR?: PracticalTagWhereInput[]
    NOT?: PracticalTagWhereInput | PracticalTagWhereInput[]
    description?: StringNullableFilter<"PracticalTag"> | string | null
    category?: EnumPracticalCategoryFilter<"PracticalTag"> | $Enums.PracticalCategory
    recipes?: RecipePracticalTagListRelationFilter
  }, "id" | "name">

  export type PracticalTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    _count?: PracticalTagCountOrderByAggregateInput
    _max?: PracticalTagMaxOrderByAggregateInput
    _min?: PracticalTagMinOrderByAggregateInput
  }

  export type PracticalTagScalarWhereWithAggregatesInput = {
    AND?: PracticalTagScalarWhereWithAggregatesInput | PracticalTagScalarWhereWithAggregatesInput[]
    OR?: PracticalTagScalarWhereWithAggregatesInput[]
    NOT?: PracticalTagScalarWhereWithAggregatesInput | PracticalTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PracticalTag"> | string
    name?: StringWithAggregatesFilter<"PracticalTag"> | string
    description?: StringNullableWithAggregatesFilter<"PracticalTag"> | string | null
    category?: EnumPracticalCategoryWithAggregatesFilter<"PracticalTag"> | $Enums.PracticalCategory
  }

  export type RecipePracticalTagWhereInput = {
    AND?: RecipePracticalTagWhereInput | RecipePracticalTagWhereInput[]
    OR?: RecipePracticalTagWhereInput[]
    NOT?: RecipePracticalTagWhereInput | RecipePracticalTagWhereInput[]
    id?: StringFilter<"RecipePracticalTag"> | string
    recipeId?: StringFilter<"RecipePracticalTag"> | string
    practicalTagId?: StringFilter<"RecipePracticalTag"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    practicalTag?: XOR<PracticalTagScalarRelationFilter, PracticalTagWhereInput>
  }

  export type RecipePracticalTagOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    practicalTagId?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    practicalTag?: PracticalTagOrderByWithRelationInput
  }

  export type RecipePracticalTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    recipeId_practicalTagId?: RecipePracticalTagRecipeIdPracticalTagIdCompoundUniqueInput
    AND?: RecipePracticalTagWhereInput | RecipePracticalTagWhereInput[]
    OR?: RecipePracticalTagWhereInput[]
    NOT?: RecipePracticalTagWhereInput | RecipePracticalTagWhereInput[]
    recipeId?: StringFilter<"RecipePracticalTag"> | string
    practicalTagId?: StringFilter<"RecipePracticalTag"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    practicalTag?: XOR<PracticalTagScalarRelationFilter, PracticalTagWhereInput>
  }, "id" | "recipeId_practicalTagId">

  export type RecipePracticalTagOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    practicalTagId?: SortOrder
    _count?: RecipePracticalTagCountOrderByAggregateInput
    _max?: RecipePracticalTagMaxOrderByAggregateInput
    _min?: RecipePracticalTagMinOrderByAggregateInput
  }

  export type RecipePracticalTagScalarWhereWithAggregatesInput = {
    AND?: RecipePracticalTagScalarWhereWithAggregatesInput | RecipePracticalTagScalarWhereWithAggregatesInput[]
    OR?: RecipePracticalTagScalarWhereWithAggregatesInput[]
    NOT?: RecipePracticalTagScalarWhereWithAggregatesInput | RecipePracticalTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipePracticalTag"> | string
    recipeId?: StringWithAggregatesFilter<"RecipePracticalTag"> | string
    practicalTagId?: StringWithAggregatesFilter<"RecipePracticalTag"> | string
  }

  export type NutritionalTagWhereInput = {
    AND?: NutritionalTagWhereInput | NutritionalTagWhereInput[]
    OR?: NutritionalTagWhereInput[]
    NOT?: NutritionalTagWhereInput | NutritionalTagWhereInput[]
    id?: StringFilter<"NutritionalTag"> | string
    name?: StringFilter<"NutritionalTag"> | string
    description?: StringNullableFilter<"NutritionalTag"> | string | null
    category?: EnumNutritionalCategoryFilter<"NutritionalTag"> | $Enums.NutritionalCategory
    recipes?: RecipeNutritionalTagListRelationFilter
  }

  export type NutritionalTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    recipes?: RecipeNutritionalTagOrderByRelationAggregateInput
  }

  export type NutritionalTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: NutritionalTagWhereInput | NutritionalTagWhereInput[]
    OR?: NutritionalTagWhereInput[]
    NOT?: NutritionalTagWhereInput | NutritionalTagWhereInput[]
    description?: StringNullableFilter<"NutritionalTag"> | string | null
    category?: EnumNutritionalCategoryFilter<"NutritionalTag"> | $Enums.NutritionalCategory
    recipes?: RecipeNutritionalTagListRelationFilter
  }, "id" | "name">

  export type NutritionalTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    _count?: NutritionalTagCountOrderByAggregateInput
    _max?: NutritionalTagMaxOrderByAggregateInput
    _min?: NutritionalTagMinOrderByAggregateInput
  }

  export type NutritionalTagScalarWhereWithAggregatesInput = {
    AND?: NutritionalTagScalarWhereWithAggregatesInput | NutritionalTagScalarWhereWithAggregatesInput[]
    OR?: NutritionalTagScalarWhereWithAggregatesInput[]
    NOT?: NutritionalTagScalarWhereWithAggregatesInput | NutritionalTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NutritionalTag"> | string
    name?: StringWithAggregatesFilter<"NutritionalTag"> | string
    description?: StringNullableWithAggregatesFilter<"NutritionalTag"> | string | null
    category?: EnumNutritionalCategoryWithAggregatesFilter<"NutritionalTag"> | $Enums.NutritionalCategory
  }

  export type RecipeNutritionalTagWhereInput = {
    AND?: RecipeNutritionalTagWhereInput | RecipeNutritionalTagWhereInput[]
    OR?: RecipeNutritionalTagWhereInput[]
    NOT?: RecipeNutritionalTagWhereInput | RecipeNutritionalTagWhereInput[]
    id?: StringFilter<"RecipeNutritionalTag"> | string
    recipeId?: StringFilter<"RecipeNutritionalTag"> | string
    nutritionalTagId?: StringFilter<"RecipeNutritionalTag"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    nutritionalTag?: XOR<NutritionalTagScalarRelationFilter, NutritionalTagWhereInput>
  }

  export type RecipeNutritionalTagOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    nutritionalTagId?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    nutritionalTag?: NutritionalTagOrderByWithRelationInput
  }

  export type RecipeNutritionalTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    recipeId_nutritionalTagId?: RecipeNutritionalTagRecipeIdNutritionalTagIdCompoundUniqueInput
    AND?: RecipeNutritionalTagWhereInput | RecipeNutritionalTagWhereInput[]
    OR?: RecipeNutritionalTagWhereInput[]
    NOT?: RecipeNutritionalTagWhereInput | RecipeNutritionalTagWhereInput[]
    recipeId?: StringFilter<"RecipeNutritionalTag"> | string
    nutritionalTagId?: StringFilter<"RecipeNutritionalTag"> | string
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
    nutritionalTag?: XOR<NutritionalTagScalarRelationFilter, NutritionalTagWhereInput>
  }, "id" | "recipeId_nutritionalTagId">

  export type RecipeNutritionalTagOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    nutritionalTagId?: SortOrder
    _count?: RecipeNutritionalTagCountOrderByAggregateInput
    _max?: RecipeNutritionalTagMaxOrderByAggregateInput
    _min?: RecipeNutritionalTagMinOrderByAggregateInput
  }

  export type RecipeNutritionalTagScalarWhereWithAggregatesInput = {
    AND?: RecipeNutritionalTagScalarWhereWithAggregatesInput | RecipeNutritionalTagScalarWhereWithAggregatesInput[]
    OR?: RecipeNutritionalTagScalarWhereWithAggregatesInput[]
    NOT?: RecipeNutritionalTagScalarWhereWithAggregatesInput | RecipeNutritionalTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RecipeNutritionalTag"> | string
    recipeId?: StringWithAggregatesFilter<"RecipeNutritionalTag"> | string
    nutritionalTagId?: StringWithAggregatesFilter<"RecipeNutritionalTag"> | string
  }

  export type MealPlanWhereInput = {
    AND?: MealPlanWhereInput | MealPlanWhereInput[]
    OR?: MealPlanWhereInput[]
    NOT?: MealPlanWhereInput | MealPlanWhereInput[]
    id?: StringFilter<"MealPlan"> | string
    userId?: StringFilter<"MealPlan"> | string
    name?: StringFilter<"MealPlan"> | string
    weekStartDate?: DateTimeFilter<"MealPlan"> | Date | string
    createdAt?: DateTimeFilter<"MealPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MealPlan"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    meals?: MealPlanItemListRelationFilter
    shoppingList?: XOR<ShoppingListNullableScalarRelationFilter, ShoppingListWhereInput> | null
  }

  export type MealPlanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    weekStartDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    meals?: MealPlanItemOrderByRelationAggregateInput
    shoppingList?: ShoppingListOrderByWithRelationInput
  }

  export type MealPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MealPlanWhereInput | MealPlanWhereInput[]
    OR?: MealPlanWhereInput[]
    NOT?: MealPlanWhereInput | MealPlanWhereInput[]
    userId?: StringFilter<"MealPlan"> | string
    name?: StringFilter<"MealPlan"> | string
    weekStartDate?: DateTimeFilter<"MealPlan"> | Date | string
    createdAt?: DateTimeFilter<"MealPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MealPlan"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    meals?: MealPlanItemListRelationFilter
    shoppingList?: XOR<ShoppingListNullableScalarRelationFilter, ShoppingListWhereInput> | null
  }, "id">

  export type MealPlanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    weekStartDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MealPlanCountOrderByAggregateInput
    _max?: MealPlanMaxOrderByAggregateInput
    _min?: MealPlanMinOrderByAggregateInput
  }

  export type MealPlanScalarWhereWithAggregatesInput = {
    AND?: MealPlanScalarWhereWithAggregatesInput | MealPlanScalarWhereWithAggregatesInput[]
    OR?: MealPlanScalarWhereWithAggregatesInput[]
    NOT?: MealPlanScalarWhereWithAggregatesInput | MealPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MealPlan"> | string
    userId?: StringWithAggregatesFilter<"MealPlan"> | string
    name?: StringWithAggregatesFilter<"MealPlan"> | string
    weekStartDate?: DateTimeWithAggregatesFilter<"MealPlan"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MealPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MealPlan"> | Date | string
  }

  export type MealPlanItemWhereInput = {
    AND?: MealPlanItemWhereInput | MealPlanItemWhereInput[]
    OR?: MealPlanItemWhereInput[]
    NOT?: MealPlanItemWhereInput | MealPlanItemWhereInput[]
    id?: StringFilter<"MealPlanItem"> | string
    mealPlanId?: StringFilter<"MealPlanItem"> | string
    recipeId?: StringFilter<"MealPlanItem"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"MealPlanItem"> | $Enums.DayOfWeek
    mealType?: EnumMealTypeFilter<"MealPlanItem"> | $Enums.MealType
    servings?: IntFilter<"MealPlanItem"> | number
    mealPlan?: XOR<MealPlanScalarRelationFilter, MealPlanWhereInput>
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }

  export type MealPlanItemOrderByWithRelationInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    recipeId?: SortOrder
    dayOfWeek?: SortOrder
    mealType?: SortOrder
    servings?: SortOrder
    mealPlan?: MealPlanOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
  }

  export type MealPlanItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MealPlanItemWhereInput | MealPlanItemWhereInput[]
    OR?: MealPlanItemWhereInput[]
    NOT?: MealPlanItemWhereInput | MealPlanItemWhereInput[]
    mealPlanId?: StringFilter<"MealPlanItem"> | string
    recipeId?: StringFilter<"MealPlanItem"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"MealPlanItem"> | $Enums.DayOfWeek
    mealType?: EnumMealTypeFilter<"MealPlanItem"> | $Enums.MealType
    servings?: IntFilter<"MealPlanItem"> | number
    mealPlan?: XOR<MealPlanScalarRelationFilter, MealPlanWhereInput>
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }, "id">

  export type MealPlanItemOrderByWithAggregationInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    recipeId?: SortOrder
    dayOfWeek?: SortOrder
    mealType?: SortOrder
    servings?: SortOrder
    _count?: MealPlanItemCountOrderByAggregateInput
    _avg?: MealPlanItemAvgOrderByAggregateInput
    _max?: MealPlanItemMaxOrderByAggregateInput
    _min?: MealPlanItemMinOrderByAggregateInput
    _sum?: MealPlanItemSumOrderByAggregateInput
  }

  export type MealPlanItemScalarWhereWithAggregatesInput = {
    AND?: MealPlanItemScalarWhereWithAggregatesInput | MealPlanItemScalarWhereWithAggregatesInput[]
    OR?: MealPlanItemScalarWhereWithAggregatesInput[]
    NOT?: MealPlanItemScalarWhereWithAggregatesInput | MealPlanItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MealPlanItem"> | string
    mealPlanId?: StringWithAggregatesFilter<"MealPlanItem"> | string
    recipeId?: StringWithAggregatesFilter<"MealPlanItem"> | string
    dayOfWeek?: EnumDayOfWeekWithAggregatesFilter<"MealPlanItem"> | $Enums.DayOfWeek
    mealType?: EnumMealTypeWithAggregatesFilter<"MealPlanItem"> | $Enums.MealType
    servings?: IntWithAggregatesFilter<"MealPlanItem"> | number
  }

  export type ShoppingListWhereInput = {
    AND?: ShoppingListWhereInput | ShoppingListWhereInput[]
    OR?: ShoppingListWhereInput[]
    NOT?: ShoppingListWhereInput | ShoppingListWhereInput[]
    id?: StringFilter<"ShoppingList"> | string
    userId?: StringFilter<"ShoppingList"> | string
    mealPlanId?: StringNullableFilter<"ShoppingList"> | string | null
    name?: StringFilter<"ShoppingList"> | string
    createdAt?: DateTimeFilter<"ShoppingList"> | Date | string
    updatedAt?: DateTimeFilter<"ShoppingList"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mealPlan?: XOR<MealPlanNullableScalarRelationFilter, MealPlanWhereInput> | null
    items?: ShoppingListItemListRelationFilter
  }

  export type ShoppingListOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mealPlanId?: SortOrderInput | SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    mealPlan?: MealPlanOrderByWithRelationInput
    items?: ShoppingListItemOrderByRelationAggregateInput
  }

  export type ShoppingListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mealPlanId?: string
    AND?: ShoppingListWhereInput | ShoppingListWhereInput[]
    OR?: ShoppingListWhereInput[]
    NOT?: ShoppingListWhereInput | ShoppingListWhereInput[]
    userId?: StringFilter<"ShoppingList"> | string
    name?: StringFilter<"ShoppingList"> | string
    createdAt?: DateTimeFilter<"ShoppingList"> | Date | string
    updatedAt?: DateTimeFilter<"ShoppingList"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    mealPlan?: XOR<MealPlanNullableScalarRelationFilter, MealPlanWhereInput> | null
    items?: ShoppingListItemListRelationFilter
  }, "id" | "mealPlanId">

  export type ShoppingListOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mealPlanId?: SortOrderInput | SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShoppingListCountOrderByAggregateInput
    _max?: ShoppingListMaxOrderByAggregateInput
    _min?: ShoppingListMinOrderByAggregateInput
  }

  export type ShoppingListScalarWhereWithAggregatesInput = {
    AND?: ShoppingListScalarWhereWithAggregatesInput | ShoppingListScalarWhereWithAggregatesInput[]
    OR?: ShoppingListScalarWhereWithAggregatesInput[]
    NOT?: ShoppingListScalarWhereWithAggregatesInput | ShoppingListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShoppingList"> | string
    userId?: StringWithAggregatesFilter<"ShoppingList"> | string
    mealPlanId?: StringNullableWithAggregatesFilter<"ShoppingList"> | string | null
    name?: StringWithAggregatesFilter<"ShoppingList"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ShoppingList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ShoppingList"> | Date | string
  }

  export type ShoppingListItemWhereInput = {
    AND?: ShoppingListItemWhereInput | ShoppingListItemWhereInput[]
    OR?: ShoppingListItemWhereInput[]
    NOT?: ShoppingListItemWhereInput | ShoppingListItemWhereInput[]
    id?: StringFilter<"ShoppingListItem"> | string
    shoppingListId?: StringFilter<"ShoppingListItem"> | string
    name?: StringFilter<"ShoppingListItem"> | string
    amount?: FloatFilter<"ShoppingListItem"> | number
    unit?: StringFilter<"ShoppingListItem"> | string
    category?: StringNullableFilter<"ShoppingListItem"> | string | null
    purchased?: BoolFilter<"ShoppingListItem"> | boolean
    estimatedPrice?: FloatNullableFilter<"ShoppingListItem"> | number | null
    shoppingList?: XOR<ShoppingListScalarRelationFilter, ShoppingListWhereInput>
  }

  export type ShoppingListItemOrderByWithRelationInput = {
    id?: SortOrder
    shoppingListId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    category?: SortOrderInput | SortOrder
    purchased?: SortOrder
    estimatedPrice?: SortOrderInput | SortOrder
    shoppingList?: ShoppingListOrderByWithRelationInput
  }

  export type ShoppingListItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShoppingListItemWhereInput | ShoppingListItemWhereInput[]
    OR?: ShoppingListItemWhereInput[]
    NOT?: ShoppingListItemWhereInput | ShoppingListItemWhereInput[]
    shoppingListId?: StringFilter<"ShoppingListItem"> | string
    name?: StringFilter<"ShoppingListItem"> | string
    amount?: FloatFilter<"ShoppingListItem"> | number
    unit?: StringFilter<"ShoppingListItem"> | string
    category?: StringNullableFilter<"ShoppingListItem"> | string | null
    purchased?: BoolFilter<"ShoppingListItem"> | boolean
    estimatedPrice?: FloatNullableFilter<"ShoppingListItem"> | number | null
    shoppingList?: XOR<ShoppingListScalarRelationFilter, ShoppingListWhereInput>
  }, "id">

  export type ShoppingListItemOrderByWithAggregationInput = {
    id?: SortOrder
    shoppingListId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    category?: SortOrderInput | SortOrder
    purchased?: SortOrder
    estimatedPrice?: SortOrderInput | SortOrder
    _count?: ShoppingListItemCountOrderByAggregateInput
    _avg?: ShoppingListItemAvgOrderByAggregateInput
    _max?: ShoppingListItemMaxOrderByAggregateInput
    _min?: ShoppingListItemMinOrderByAggregateInput
    _sum?: ShoppingListItemSumOrderByAggregateInput
  }

  export type ShoppingListItemScalarWhereWithAggregatesInput = {
    AND?: ShoppingListItemScalarWhereWithAggregatesInput | ShoppingListItemScalarWhereWithAggregatesInput[]
    OR?: ShoppingListItemScalarWhereWithAggregatesInput[]
    NOT?: ShoppingListItemScalarWhereWithAggregatesInput | ShoppingListItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShoppingListItem"> | string
    shoppingListId?: StringWithAggregatesFilter<"ShoppingListItem"> | string
    name?: StringWithAggregatesFilter<"ShoppingListItem"> | string
    amount?: FloatWithAggregatesFilter<"ShoppingListItem"> | number
    unit?: StringWithAggregatesFilter<"ShoppingListItem"> | string
    category?: StringNullableWithAggregatesFilter<"ShoppingListItem"> | string | null
    purchased?: BoolWithAggregatesFilter<"ShoppingListItem"> | boolean
    estimatedPrice?: FloatNullableWithAggregatesFilter<"ShoppingListItem"> | number | null
  }

  export type UserFavoriteRecipeWhereInput = {
    AND?: UserFavoriteRecipeWhereInput | UserFavoriteRecipeWhereInput[]
    OR?: UserFavoriteRecipeWhereInput[]
    NOT?: UserFavoriteRecipeWhereInput | UserFavoriteRecipeWhereInput[]
    id?: StringFilter<"UserFavoriteRecipe"> | string
    userId?: StringFilter<"UserFavoriteRecipe"> | string
    recipeId?: StringFilter<"UserFavoriteRecipe"> | string
    addedAt?: DateTimeFilter<"UserFavoriteRecipe"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }

  export type UserFavoriteRecipeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    addedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
  }

  export type UserFavoriteRecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_recipeId?: UserFavoriteRecipeUserIdRecipeIdCompoundUniqueInput
    AND?: UserFavoriteRecipeWhereInput | UserFavoriteRecipeWhereInput[]
    OR?: UserFavoriteRecipeWhereInput[]
    NOT?: UserFavoriteRecipeWhereInput | UserFavoriteRecipeWhereInput[]
    userId?: StringFilter<"UserFavoriteRecipe"> | string
    recipeId?: StringFilter<"UserFavoriteRecipe"> | string
    addedAt?: DateTimeFilter<"UserFavoriteRecipe"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }, "id" | "userId_recipeId">

  export type UserFavoriteRecipeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    addedAt?: SortOrder
    _count?: UserFavoriteRecipeCountOrderByAggregateInput
    _max?: UserFavoriteRecipeMaxOrderByAggregateInput
    _min?: UserFavoriteRecipeMinOrderByAggregateInput
  }

  export type UserFavoriteRecipeScalarWhereWithAggregatesInput = {
    AND?: UserFavoriteRecipeScalarWhereWithAggregatesInput | UserFavoriteRecipeScalarWhereWithAggregatesInput[]
    OR?: UserFavoriteRecipeScalarWhereWithAggregatesInput[]
    NOT?: UserFavoriteRecipeScalarWhereWithAggregatesInput | UserFavoriteRecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFavoriteRecipe"> | string
    userId?: StringWithAggregatesFilter<"UserFavoriteRecipe"> | string
    recipeId?: StringWithAggregatesFilter<"UserFavoriteRecipe"> | string
    addedAt?: DateTimeWithAggregatesFilter<"UserFavoriteRecipe"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    tier?: SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    tier?: EnumSubscriptionTierFilter<"Subscription"> | $Enums.SubscriptionTier
    currentPeriodStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "stripeCustomerId" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    tier?: SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    tier?: EnumSubscriptionTierWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionTier
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter<"Feedback"> | string
    userId?: StringFilter<"Feedback"> | string
    recipeId?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    notes?: StringNullableFilter<"Feedback"> | string | null
    timestamp?: DateTimeFilter<"Feedback"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    rating?: SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_recipeId?: FeedbackUserIdRecipeIdCompoundUniqueInput
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    userId?: StringFilter<"Feedback"> | string
    recipeId?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    notes?: StringNullableFilter<"Feedback"> | string | null
    timestamp?: DateTimeFilter<"Feedback"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    recipe?: XOR<RecipeScalarRelationFilter, RecipeWhereInput>
  }, "id" | "userId_recipeId">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    rating?: SortOrder
    notes?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feedback"> | string
    userId?: StringWithAggregatesFilter<"Feedback"> | string
    recipeId?: StringWithAggregatesFilter<"Feedback"> | string
    rating?: IntWithAggregatesFilter<"Feedback"> | number
    notes?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
  }

  export type ABTestWhereInput = {
    AND?: ABTestWhereInput | ABTestWhereInput[]
    OR?: ABTestWhereInput[]
    NOT?: ABTestWhereInput | ABTestWhereInput[]
    id?: StringFilter<"ABTest"> | string
    userId?: StringFilter<"ABTest"> | string
    feature?: StringFilter<"ABTest"> | string
    variant?: StringFilter<"ABTest"> | string
    timestamp?: DateTimeFilter<"ABTest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ABTestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    variant?: SortOrder
    timestamp?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ABTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ABTestWhereInput | ABTestWhereInput[]
    OR?: ABTestWhereInput[]
    NOT?: ABTestWhereInput | ABTestWhereInput[]
    userId?: StringFilter<"ABTest"> | string
    feature?: StringFilter<"ABTest"> | string
    variant?: StringFilter<"ABTest"> | string
    timestamp?: DateTimeFilter<"ABTest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ABTestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    variant?: SortOrder
    timestamp?: SortOrder
    _count?: ABTestCountOrderByAggregateInput
    _max?: ABTestMaxOrderByAggregateInput
    _min?: ABTestMinOrderByAggregateInput
  }

  export type ABTestScalarWhereWithAggregatesInput = {
    AND?: ABTestScalarWhereWithAggregatesInput | ABTestScalarWhereWithAggregatesInput[]
    OR?: ABTestScalarWhereWithAggregatesInput[]
    NOT?: ABTestScalarWhereWithAggregatesInput | ABTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ABTest"> | string
    userId?: StringWithAggregatesFilter<"ABTest"> | string
    feature?: StringWithAggregatesFilter<"ABTest"> | string
    variant?: StringWithAggregatesFilter<"ABTest"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ABTest"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionCreateNestedManyWithoutUserInput
    allergies?: UserAllergyCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    abTests?: ABTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionUncheckedCreateNestedManyWithoutUserInput
    allergies?: UserAllergyUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListUncheckedCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    abTests?: ABTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    abTests?: ABTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUncheckedUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    abTests?: ABTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserPreferencesCreateInput = {
    id?: string
    cookingSkillLevel?: $Enums.CookingSkill
    maxPrepTimeMinutes?: number
    budgetRange?: $Enums.BudgetRange
    householdSize?: number
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: number
    snacksPerDay?: number
    batchCookingPreference?: boolean
    energyRestrictionGoal?: string | null
    targetCaloriesMin?: number | null
    targetCaloriesMax?: number | null
    cuisinePreferences?: string | null
    spiceTolerance?: number
    flavorIntensity?: number
    knifeSkillLevel?: string
    preferredTechniques?: string | null
    recipeComplexityComfort?: number
    weeklyFoodBudget?: number | null
    shoppingFrequency?: string
    mealPlanningApproach?: number
    textureLimitations?: string | null
    foodsToAvoid?: string | null
    mealTimingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPreferencesInput
    appliances?: UserApplianceCreateNestedManyWithoutUserPreferencesInput
    behaviorProfile?: UserBehaviorCreateNestedOneWithoutUserPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    cookingSkillLevel?: $Enums.CookingSkill
    maxPrepTimeMinutes?: number
    budgetRange?: $Enums.BudgetRange
    householdSize?: number
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: number
    snacksPerDay?: number
    batchCookingPreference?: boolean
    energyRestrictionGoal?: string | null
    targetCaloriesMin?: number | null
    targetCaloriesMax?: number | null
    cuisinePreferences?: string | null
    spiceTolerance?: number
    flavorIntensity?: number
    knifeSkillLevel?: string
    preferredTechniques?: string | null
    recipeComplexityComfort?: number
    weeklyFoodBudget?: number | null
    shoppingFrequency?: string
    mealPlanningApproach?: number
    textureLimitations?: string | null
    foodsToAvoid?: string | null
    mealTimingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appliances?: UserApplianceUncheckedCreateNestedManyWithoutUserPreferencesInput
    behaviorProfile?: UserBehaviorUncheckedCreateNestedOneWithoutUserPreferencesInput
  }

  export type UserPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
    appliances?: UserApplianceUpdateManyWithoutUserPreferencesNestedInput
    behaviorProfile?: UserBehaviorUpdateOneWithoutUserPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appliances?: UserApplianceUncheckedUpdateManyWithoutUserPreferencesNestedInput
    behaviorProfile?: UserBehaviorUncheckedUpdateOneWithoutUserPreferencesNestedInput
  }

  export type UserPreferencesCreateManyInput = {
    id?: string
    userId: string
    cookingSkillLevel?: $Enums.CookingSkill
    maxPrepTimeMinutes?: number
    budgetRange?: $Enums.BudgetRange
    householdSize?: number
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: number
    snacksPerDay?: number
    batchCookingPreference?: boolean
    energyRestrictionGoal?: string | null
    targetCaloriesMin?: number | null
    targetCaloriesMax?: number | null
    cuisinePreferences?: string | null
    spiceTolerance?: number
    flavorIntensity?: number
    knifeSkillLevel?: string
    preferredTechniques?: string | null
    recipeComplexityComfort?: number
    weeklyFoodBudget?: number | null
    shoppingFrequency?: string
    mealPlanningApproach?: number
    textureLimitations?: string | null
    foodsToAvoid?: string | null
    mealTimingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthConditionCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.HealthCategory
    users?: UserHealthConditionCreateNestedManyWithoutHealthConditionInput
  }

  export type HealthConditionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.HealthCategory
    users?: UserHealthConditionUncheckedCreateNestedManyWithoutHealthConditionInput
  }

  export type HealthConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumHealthCategoryFieldUpdateOperationsInput | $Enums.HealthCategory
    users?: UserHealthConditionUpdateManyWithoutHealthConditionNestedInput
  }

  export type HealthConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumHealthCategoryFieldUpdateOperationsInput | $Enums.HealthCategory
    users?: UserHealthConditionUncheckedUpdateManyWithoutHealthConditionNestedInput
  }

  export type HealthConditionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.HealthCategory
  }

  export type HealthConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumHealthCategoryFieldUpdateOperationsInput | $Enums.HealthCategory
  }

  export type HealthConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumHealthCategoryFieldUpdateOperationsInput | $Enums.HealthCategory
  }

  export type UserHealthConditionCreateInput = {
    id?: string
    severity?: $Enums.Severity
    diagnosedDate?: Date | string | null
    user: UserCreateNestedOneWithoutHealthConditionsInput
    healthCondition: HealthConditionCreateNestedOneWithoutUsersInput
  }

  export type UserHealthConditionUncheckedCreateInput = {
    id?: string
    userId: string
    healthConditionId: string
    severity?: $Enums.Severity
    diagnosedDate?: Date | string | null
  }

  export type UserHealthConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutHealthConditionsNestedInput
    healthCondition?: HealthConditionUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserHealthConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    healthConditionId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserHealthConditionCreateManyInput = {
    id?: string
    userId: string
    healthConditionId: string
    severity?: $Enums.Severity
    diagnosedDate?: Date | string | null
  }

  export type UserHealthConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserHealthConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    healthConditionId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AllergenCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.AllergenCategory
    users?: UserAllergyCreateNestedManyWithoutAllergenInput
  }

  export type AllergenUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.AllergenCategory
    users?: UserAllergyUncheckedCreateNestedManyWithoutAllergenInput
  }

  export type AllergenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAllergenCategoryFieldUpdateOperationsInput | $Enums.AllergenCategory
    users?: UserAllergyUpdateManyWithoutAllergenNestedInput
  }

  export type AllergenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAllergenCategoryFieldUpdateOperationsInput | $Enums.AllergenCategory
    users?: UserAllergyUncheckedUpdateManyWithoutAllergenNestedInput
  }

  export type AllergenCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.AllergenCategory
  }

  export type AllergenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAllergenCategoryFieldUpdateOperationsInput | $Enums.AllergenCategory
  }

  export type AllergenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAllergenCategoryFieldUpdateOperationsInput | $Enums.AllergenCategory
  }

  export type UserAllergyCreateInput = {
    id?: string
    severity?: $Enums.Severity
    user: UserCreateNestedOneWithoutAllergiesInput
    allergen: AllergenCreateNestedOneWithoutUsersInput
  }

  export type UserAllergyUncheckedCreateInput = {
    id?: string
    userId: string
    allergenId: string
    severity?: $Enums.Severity
  }

  export type UserAllergyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    user?: UserUpdateOneRequiredWithoutAllergiesNestedInput
    allergen?: AllergenUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserAllergyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    allergenId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
  }

  export type UserAllergyCreateManyInput = {
    id?: string
    userId: string
    allergenId: string
    severity?: $Enums.Severity
  }

  export type UserAllergyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
  }

  export type UserAllergyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    allergenId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
  }

  export type ApplianceCreateInput = {
    id?: string
    name: string
    displayName: string
    category: string
    users?: UserApplianceCreateNestedManyWithoutApplianceInput
  }

  export type ApplianceUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    category: string
    users?: UserApplianceUncheckedCreateNestedManyWithoutApplianceInput
  }

  export type ApplianceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    users?: UserApplianceUpdateManyWithoutApplianceNestedInput
  }

  export type ApplianceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    users?: UserApplianceUncheckedUpdateManyWithoutApplianceNestedInput
  }

  export type ApplianceCreateManyInput = {
    id?: string
    name: string
    displayName: string
    category: string
  }

  export type ApplianceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type ApplianceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type UserApplianceCreateInput = {
    id?: string
    usageFrequency?: number
    userPreferences: UserPreferencesCreateNestedOneWithoutAppliancesInput
    appliance: ApplianceCreateNestedOneWithoutUsersInput
  }

  export type UserApplianceUncheckedCreateInput = {
    id?: string
    userPreferencesId: string
    applianceId: string
    usageFrequency?: number
  }

  export type UserApplianceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
    userPreferences?: UserPreferencesUpdateOneRequiredWithoutAppliancesNestedInput
    appliance?: ApplianceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserApplianceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPreferencesId?: StringFieldUpdateOperationsInput | string
    applianceId?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type UserApplianceCreateManyInput = {
    id?: string
    userPreferencesId: string
    applianceId: string
    usageFrequency?: number
  }

  export type UserApplianceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type UserApplianceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPreferencesId?: StringFieldUpdateOperationsInput | string
    applianceId?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type UserBehaviorCreateInput = {
    id?: string
    portionControlMotivation?: number
    habitChangeReadiness?: string | null
    socialEatingPattern?: number
    successTrackingPreference?: string
    activityLevel?: string
    healthConditionPriority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userPreferences: UserPreferencesCreateNestedOneWithoutBehaviorProfileInput
  }

  export type UserBehaviorUncheckedCreateInput = {
    id?: string
    userPreferencesId: string
    portionControlMotivation?: number
    habitChangeReadiness?: string | null
    socialEatingPattern?: number
    successTrackingPreference?: string
    activityLevel?: string
    healthConditionPriority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBehaviorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    portionControlMotivation?: IntFieldUpdateOperationsInput | number
    habitChangeReadiness?: NullableStringFieldUpdateOperationsInput | string | null
    socialEatingPattern?: IntFieldUpdateOperationsInput | number
    successTrackingPreference?: StringFieldUpdateOperationsInput | string
    activityLevel?: StringFieldUpdateOperationsInput | string
    healthConditionPriority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPreferences?: UserPreferencesUpdateOneRequiredWithoutBehaviorProfileNestedInput
  }

  export type UserBehaviorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPreferencesId?: StringFieldUpdateOperationsInput | string
    portionControlMotivation?: IntFieldUpdateOperationsInput | number
    habitChangeReadiness?: NullableStringFieldUpdateOperationsInput | string | null
    socialEatingPattern?: IntFieldUpdateOperationsInput | number
    successTrackingPreference?: StringFieldUpdateOperationsInput | string
    activityLevel?: StringFieldUpdateOperationsInput | string
    healthConditionPriority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBehaviorCreateManyInput = {
    id?: string
    userPreferencesId: string
    portionControlMotivation?: number
    habitChangeReadiness?: string | null
    socialEatingPattern?: number
    successTrackingPreference?: string
    activityLevel?: string
    healthConditionPriority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBehaviorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    portionControlMotivation?: IntFieldUpdateOperationsInput | number
    habitChangeReadiness?: NullableStringFieldUpdateOperationsInput | string | null
    socialEatingPattern?: IntFieldUpdateOperationsInput | number
    successTrackingPreference?: StringFieldUpdateOperationsInput | string
    activityLevel?: StringFieldUpdateOperationsInput | string
    healthConditionPriority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBehaviorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPreferencesId?: StringFieldUpdateOperationsInput | string
    portionControlMotivation?: IntFieldUpdateOperationsInput | number
    habitChangeReadiness?: NullableStringFieldUpdateOperationsInput | string | null
    socialEatingPattern?: IntFieldUpdateOperationsInput | number
    successTrackingPreference?: StringFieldUpdateOperationsInput | string
    activityLevel?: StringFieldUpdateOperationsInput | string
    healthConditionPriority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpiceBlendCreateInput = {
    id?: string
    name: string
    displayName: string
    activeCompounds: string
    clinicalEvidence: string
    primaryBenefit: string
    effectiveDoseGrams: number
    bioavailabilityHack?: string | null
    quickApplications: string
    recipes?: RecipeSpiceBlendCreateNestedManyWithoutSpiceBlendInput
  }

  export type SpiceBlendUncheckedCreateInput = {
    id?: string
    name: string
    displayName: string
    activeCompounds: string
    clinicalEvidence: string
    primaryBenefit: string
    effectiveDoseGrams: number
    bioavailabilityHack?: string | null
    quickApplications: string
    recipes?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutSpiceBlendInput
  }

  export type SpiceBlendUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    activeCompounds?: StringFieldUpdateOperationsInput | string
    clinicalEvidence?: StringFieldUpdateOperationsInput | string
    primaryBenefit?: StringFieldUpdateOperationsInput | string
    effectiveDoseGrams?: FloatFieldUpdateOperationsInput | number
    bioavailabilityHack?: NullableStringFieldUpdateOperationsInput | string | null
    quickApplications?: StringFieldUpdateOperationsInput | string
    recipes?: RecipeSpiceBlendUpdateManyWithoutSpiceBlendNestedInput
  }

  export type SpiceBlendUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    activeCompounds?: StringFieldUpdateOperationsInput | string
    clinicalEvidence?: StringFieldUpdateOperationsInput | string
    primaryBenefit?: StringFieldUpdateOperationsInput | string
    effectiveDoseGrams?: FloatFieldUpdateOperationsInput | number
    bioavailabilityHack?: NullableStringFieldUpdateOperationsInput | string | null
    quickApplications?: StringFieldUpdateOperationsInput | string
    recipes?: RecipeSpiceBlendUncheckedUpdateManyWithoutSpiceBlendNestedInput
  }

  export type SpiceBlendCreateManyInput = {
    id?: string
    name: string
    displayName: string
    activeCompounds: string
    clinicalEvidence: string
    primaryBenefit: string
    effectiveDoseGrams: number
    bioavailabilityHack?: string | null
    quickApplications: string
  }

  export type SpiceBlendUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    activeCompounds?: StringFieldUpdateOperationsInput | string
    clinicalEvidence?: StringFieldUpdateOperationsInput | string
    primaryBenefit?: StringFieldUpdateOperationsInput | string
    effectiveDoseGrams?: FloatFieldUpdateOperationsInput | number
    bioavailabilityHack?: NullableStringFieldUpdateOperationsInput | string | null
    quickApplications?: StringFieldUpdateOperationsInput | string
  }

  export type SpiceBlendUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    activeCompounds?: StringFieldUpdateOperationsInput | string
    clinicalEvidence?: StringFieldUpdateOperationsInput | string
    primaryBenefit?: StringFieldUpdateOperationsInput | string
    effectiveDoseGrams?: FloatFieldUpdateOperationsInput | number
    bioavailabilityHack?: NullableStringFieldUpdateOperationsInput | string | null
    quickApplications?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeSpiceBlendCreateInput = {
    id?: string
    amountGrams: number
    recipe: RecipeCreateNestedOneWithoutSpiceBlendsInput
    spiceBlend: SpiceBlendCreateNestedOneWithoutRecipesInput
  }

  export type RecipeSpiceBlendUncheckedCreateInput = {
    id?: string
    recipeId: string
    spiceBlendId: string
    amountGrams: number
  }

  export type RecipeSpiceBlendUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutSpiceBlendsNestedInput
    spiceBlend?: SpiceBlendUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeSpiceBlendUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    spiceBlendId?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeSpiceBlendCreateManyInput = {
    id?: string
    recipeId: string
    spiceBlendId: string
    amountGrams: number
  }

  export type RecipeSpiceBlendUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeSpiceBlendUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    spiceBlendId?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeCreateInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeIngredientCreateInput = {
    id?: string
    name: string
    amount: number
    unit: string
    notes?: string | null
    recipe: RecipeCreateNestedOneWithoutIngredientsInput
  }

  export type RecipeIngredientUncheckedCreateInput = {
    id?: string
    recipeId: string
    name: string
    amount: number
    unit: string
    notes?: string | null
  }

  export type RecipeIngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recipe?: RecipeUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type RecipeIngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeIngredientCreateManyInput = {
    id?: string
    recipeId: string
    name: string
    amount: number
    unit: string
    notes?: string | null
  }

  export type RecipeIngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeIngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeInstructionCreateInput = {
    id?: string
    stepNumber: number
    instruction: string
    recipe: RecipeCreateNestedOneWithoutInstructionsInput
  }

  export type RecipeInstructionUncheckedCreateInput = {
    id?: string
    recipeId: string
    stepNumber: number
    instruction: string
  }

  export type RecipeInstructionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutInstructionsNestedInput
  }

  export type RecipeInstructionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeInstructionCreateManyInput = {
    id?: string
    recipeId: string
    stepNumber: number
    instruction: string
  }

  export type RecipeInstructionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeInstructionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
  }

  export type NutritionalInfoCreateInput = {
    id?: string
    calories?: number | null
    protein?: number | null
    carbohydrates?: number | null
    fat?: number | null
    fiber?: number | null
    sugar?: number | null
    sodium?: number | null
    cholesterol?: number | null
    vitaminC?: number | null
    vitaminD?: number | null
    calcium?: number | null
    iron?: number | null
    potassium?: number | null
    recipe: RecipeCreateNestedOneWithoutNutritionalInfoInput
  }

  export type NutritionalInfoUncheckedCreateInput = {
    id?: string
    recipeId: string
    calories?: number | null
    protein?: number | null
    carbohydrates?: number | null
    fat?: number | null
    fiber?: number | null
    sugar?: number | null
    sodium?: number | null
    cholesterol?: number | null
    vitaminC?: number | null
    vitaminD?: number | null
    calcium?: number | null
    iron?: number | null
    potassium?: number | null
  }

  export type NutritionalInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    calories?: NullableFloatFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbohydrates?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    fiber?: NullableFloatFieldUpdateOperationsInput | number | null
    sugar?: NullableFloatFieldUpdateOperationsInput | number | null
    sodium?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesterol?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminC?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminD?: NullableFloatFieldUpdateOperationsInput | number | null
    calcium?: NullableFloatFieldUpdateOperationsInput | number | null
    iron?: NullableFloatFieldUpdateOperationsInput | number | null
    potassium?: NullableFloatFieldUpdateOperationsInput | number | null
    recipe?: RecipeUpdateOneRequiredWithoutNutritionalInfoNestedInput
  }

  export type NutritionalInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    calories?: NullableFloatFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbohydrates?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    fiber?: NullableFloatFieldUpdateOperationsInput | number | null
    sugar?: NullableFloatFieldUpdateOperationsInput | number | null
    sodium?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesterol?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminC?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminD?: NullableFloatFieldUpdateOperationsInput | number | null
    calcium?: NullableFloatFieldUpdateOperationsInput | number | null
    iron?: NullableFloatFieldUpdateOperationsInput | number | null
    potassium?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type NutritionalInfoCreateManyInput = {
    id?: string
    recipeId: string
    calories?: number | null
    protein?: number | null
    carbohydrates?: number | null
    fat?: number | null
    fiber?: number | null
    sugar?: number | null
    sodium?: number | null
    cholesterol?: number | null
    vitaminC?: number | null
    vitaminD?: number | null
    calcium?: number | null
    iron?: number | null
    potassium?: number | null
  }

  export type NutritionalInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    calories?: NullableFloatFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbohydrates?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    fiber?: NullableFloatFieldUpdateOperationsInput | number | null
    sugar?: NullableFloatFieldUpdateOperationsInput | number | null
    sodium?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesterol?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminC?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminD?: NullableFloatFieldUpdateOperationsInput | number | null
    calcium?: NullableFloatFieldUpdateOperationsInput | number | null
    iron?: NullableFloatFieldUpdateOperationsInput | number | null
    potassium?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type NutritionalInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    calories?: NullableFloatFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbohydrates?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    fiber?: NullableFloatFieldUpdateOperationsInput | number | null
    sugar?: NullableFloatFieldUpdateOperationsInput | number | null
    sodium?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesterol?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminC?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminD?: NullableFloatFieldUpdateOperationsInput | number | null
    calcium?: NullableFloatFieldUpdateOperationsInput | number | null
    iron?: NullableFloatFieldUpdateOperationsInput | number | null
    potassium?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MedicalTagCreateInput = {
    id?: string
    name: string
    description?: string | null
    condition: string
    recipes?: RecipeMedicalTagCreateNestedManyWithoutMedicalTagInput
  }

  export type MedicalTagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    condition: string
    recipes?: RecipeMedicalTagUncheckedCreateNestedManyWithoutMedicalTagInput
  }

  export type MedicalTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    recipes?: RecipeMedicalTagUpdateManyWithoutMedicalTagNestedInput
  }

  export type MedicalTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
    recipes?: RecipeMedicalTagUncheckedUpdateManyWithoutMedicalTagNestedInput
  }

  export type MedicalTagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    condition: string
  }

  export type MedicalTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeMedicalTagCreateInput = {
    id?: string
    recipe: RecipeCreateNestedOneWithoutMedicalTagsInput
    medicalTag: MedicalTagCreateNestedOneWithoutRecipesInput
  }

  export type RecipeMedicalTagUncheckedCreateInput = {
    id?: string
    recipeId: string
    medicalTagId: string
  }

  export type RecipeMedicalTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutMedicalTagsNestedInput
    medicalTag?: MedicalTagUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeMedicalTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    medicalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeMedicalTagCreateManyInput = {
    id?: string
    recipeId: string
    medicalTagId: string
  }

  export type RecipeMedicalTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeMedicalTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    medicalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type DietaryTagCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.DietaryCategory
    recipes?: RecipeDietaryTagCreateNestedManyWithoutDietaryTagInput
  }

  export type DietaryTagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.DietaryCategory
    recipes?: RecipeDietaryTagUncheckedCreateNestedManyWithoutDietaryTagInput
  }

  export type DietaryTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDietaryCategoryFieldUpdateOperationsInput | $Enums.DietaryCategory
    recipes?: RecipeDietaryTagUpdateManyWithoutDietaryTagNestedInput
  }

  export type DietaryTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDietaryCategoryFieldUpdateOperationsInput | $Enums.DietaryCategory
    recipes?: RecipeDietaryTagUncheckedUpdateManyWithoutDietaryTagNestedInput
  }

  export type DietaryTagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.DietaryCategory
  }

  export type DietaryTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDietaryCategoryFieldUpdateOperationsInput | $Enums.DietaryCategory
  }

  export type DietaryTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDietaryCategoryFieldUpdateOperationsInput | $Enums.DietaryCategory
  }

  export type RecipeDietaryTagCreateInput = {
    id?: string
    recipe: RecipeCreateNestedOneWithoutDietaryTagsInput
    dietaryTag: DietaryTagCreateNestedOneWithoutRecipesInput
  }

  export type RecipeDietaryTagUncheckedCreateInput = {
    id?: string
    recipeId: string
    dietaryTagId: string
  }

  export type RecipeDietaryTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutDietaryTagsNestedInput
    dietaryTag?: DietaryTagUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeDietaryTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    dietaryTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeDietaryTagCreateManyInput = {
    id?: string
    recipeId: string
    dietaryTagId: string
  }

  export type RecipeDietaryTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeDietaryTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    dietaryTagId?: StringFieldUpdateOperationsInput | string
  }

  export type PracticalTagCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.PracticalCategory
    recipes?: RecipePracticalTagCreateNestedManyWithoutPracticalTagInput
  }

  export type PracticalTagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.PracticalCategory
    recipes?: RecipePracticalTagUncheckedCreateNestedManyWithoutPracticalTagInput
  }

  export type PracticalTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPracticalCategoryFieldUpdateOperationsInput | $Enums.PracticalCategory
    recipes?: RecipePracticalTagUpdateManyWithoutPracticalTagNestedInput
  }

  export type PracticalTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPracticalCategoryFieldUpdateOperationsInput | $Enums.PracticalCategory
    recipes?: RecipePracticalTagUncheckedUpdateManyWithoutPracticalTagNestedInput
  }

  export type PracticalTagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.PracticalCategory
  }

  export type PracticalTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPracticalCategoryFieldUpdateOperationsInput | $Enums.PracticalCategory
  }

  export type PracticalTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPracticalCategoryFieldUpdateOperationsInput | $Enums.PracticalCategory
  }

  export type RecipePracticalTagCreateInput = {
    id?: string
    recipe: RecipeCreateNestedOneWithoutPracticalTagsInput
    practicalTag: PracticalTagCreateNestedOneWithoutRecipesInput
  }

  export type RecipePracticalTagUncheckedCreateInput = {
    id?: string
    recipeId: string
    practicalTagId: string
  }

  export type RecipePracticalTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutPracticalTagsNestedInput
    practicalTag?: PracticalTagUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipePracticalTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    practicalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipePracticalTagCreateManyInput = {
    id?: string
    recipeId: string
    practicalTagId: string
  }

  export type RecipePracticalTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type RecipePracticalTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    practicalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type NutritionalTagCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.NutritionalCategory
    recipes?: RecipeNutritionalTagCreateNestedManyWithoutNutritionalTagInput
  }

  export type NutritionalTagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.NutritionalCategory
    recipes?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutNutritionalTagInput
  }

  export type NutritionalTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNutritionalCategoryFieldUpdateOperationsInput | $Enums.NutritionalCategory
    recipes?: RecipeNutritionalTagUpdateManyWithoutNutritionalTagNestedInput
  }

  export type NutritionalTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNutritionalCategoryFieldUpdateOperationsInput | $Enums.NutritionalCategory
    recipes?: RecipeNutritionalTagUncheckedUpdateManyWithoutNutritionalTagNestedInput
  }

  export type NutritionalTagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.NutritionalCategory
  }

  export type NutritionalTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNutritionalCategoryFieldUpdateOperationsInput | $Enums.NutritionalCategory
  }

  export type NutritionalTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNutritionalCategoryFieldUpdateOperationsInput | $Enums.NutritionalCategory
  }

  export type RecipeNutritionalTagCreateInput = {
    id?: string
    recipe: RecipeCreateNestedOneWithoutNutritionalTagsInput
    nutritionalTag: NutritionalTagCreateNestedOneWithoutRecipesInput
  }

  export type RecipeNutritionalTagUncheckedCreateInput = {
    id?: string
    recipeId: string
    nutritionalTagId: string
  }

  export type RecipeNutritionalTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutNutritionalTagsNestedInput
    nutritionalTag?: NutritionalTagUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeNutritionalTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    nutritionalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeNutritionalTagCreateManyInput = {
    id?: string
    recipeId: string
    nutritionalTagId: string
  }

  export type RecipeNutritionalTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeNutritionalTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    nutritionalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type MealPlanCreateInput = {
    id?: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMealPlansInput
    meals?: MealPlanItemCreateNestedManyWithoutMealPlanInput
    shoppingList?: ShoppingListCreateNestedOneWithoutMealPlanInput
  }

  export type MealPlanUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: MealPlanItemUncheckedCreateNestedManyWithoutMealPlanInput
    shoppingList?: ShoppingListUncheckedCreateNestedOneWithoutMealPlanInput
  }

  export type MealPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMealPlansNestedInput
    meals?: MealPlanItemUpdateManyWithoutMealPlanNestedInput
    shoppingList?: ShoppingListUpdateOneWithoutMealPlanNestedInput
  }

  export type MealPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: MealPlanItemUncheckedUpdateManyWithoutMealPlanNestedInput
    shoppingList?: ShoppingListUncheckedUpdateOneWithoutMealPlanNestedInput
  }

  export type MealPlanCreateManyInput = {
    id?: string
    userId: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MealPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealPlanItemCreateInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings?: number
    mealPlan: MealPlanCreateNestedOneWithoutMealsInput
    recipe: RecipeCreateNestedOneWithoutMealPlanItemsInput
  }

  export type MealPlanItemUncheckedCreateInput = {
    id?: string
    mealPlanId: string
    recipeId: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings?: number
  }

  export type MealPlanItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
    mealPlan?: MealPlanUpdateOneRequiredWithoutMealsNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutMealPlanItemsNestedInput
  }

  export type MealPlanItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealPlanId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
  }

  export type MealPlanItemCreateManyInput = {
    id?: string
    mealPlanId: string
    recipeId: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings?: number
  }

  export type MealPlanItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
  }

  export type MealPlanItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealPlanId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
  }

  export type ShoppingListCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShoppingListsInput
    mealPlan?: MealPlanCreateNestedOneWithoutShoppingListInput
    items?: ShoppingListItemCreateNestedManyWithoutShoppingListInput
  }

  export type ShoppingListUncheckedCreateInput = {
    id?: string
    userId: string
    mealPlanId?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ShoppingListItemUncheckedCreateNestedManyWithoutShoppingListInput
  }

  export type ShoppingListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShoppingListsNestedInput
    mealPlan?: MealPlanUpdateOneWithoutShoppingListNestedInput
    items?: ShoppingListItemUpdateManyWithoutShoppingListNestedInput
  }

  export type ShoppingListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mealPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShoppingListItemUncheckedUpdateManyWithoutShoppingListNestedInput
  }

  export type ShoppingListCreateManyInput = {
    id?: string
    userId: string
    mealPlanId?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShoppingListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShoppingListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mealPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShoppingListItemCreateInput = {
    id?: string
    name: string
    amount: number
    unit: string
    category?: string | null
    purchased?: boolean
    estimatedPrice?: number | null
    shoppingList: ShoppingListCreateNestedOneWithoutItemsInput
  }

  export type ShoppingListItemUncheckedCreateInput = {
    id?: string
    shoppingListId: string
    name: string
    amount: number
    unit: string
    category?: string | null
    purchased?: boolean
    estimatedPrice?: number | null
  }

  export type ShoppingListItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    purchased?: BoolFieldUpdateOperationsInput | boolean
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingList?: ShoppingListUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ShoppingListItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shoppingListId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    purchased?: BoolFieldUpdateOperationsInput | boolean
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ShoppingListItemCreateManyInput = {
    id?: string
    shoppingListId: string
    name: string
    amount: number
    unit: string
    category?: string | null
    purchased?: boolean
    estimatedPrice?: number | null
  }

  export type ShoppingListItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    purchased?: BoolFieldUpdateOperationsInput | boolean
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ShoppingListItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shoppingListId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    purchased?: BoolFieldUpdateOperationsInput | boolean
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserFavoriteRecipeCreateInput = {
    id?: string
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutFavoriteRecipesInput
    recipe: RecipeCreateNestedOneWithoutFavoritesInput
  }

  export type UserFavoriteRecipeUncheckedCreateInput = {
    id?: string
    userId: string
    recipeId: string
    addedAt?: Date | string
  }

  export type UserFavoriteRecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoriteRecipesNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type UserFavoriteRecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteRecipeCreateManyInput = {
    id?: string
    userId: string
    recipeId: string
    addedAt?: Date | string
  }

  export type UserFavoriteRecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteRecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status: $Enums.SubscriptionStatus
    tier: $Enums.SubscriptionTier
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status: $Enums.SubscriptionStatus
    tier: $Enums.SubscriptionTier
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status: $Enums.SubscriptionStatus
    tier: $Enums.SubscriptionTier
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateInput = {
    id?: string
    rating: number
    notes?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutFeedbacksInput
    recipe: RecipeCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    userId: string
    recipeId: string
    rating: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type FeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackCreateManyInput = {
    id?: string
    userId: string
    recipeId: string
    rating: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type FeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestCreateInput = {
    id?: string
    feature: string
    variant: string
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutAbTestsInput
  }

  export type ABTestUncheckedCreateInput = {
    id?: string
    userId: string
    feature: string
    variant: string
    timestamp?: Date | string
  }

  export type ABTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAbTestsNestedInput
  }

  export type ABTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestCreateManyInput = {
    id?: string
    userId: string
    feature: string
    variant: string
    timestamp?: Date | string
  }

  export type ABTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumDietaryGoalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryGoal | EnumDietaryGoalFieldRefInput<$PrismaModel> | null
    in?: $Enums.DietaryGoal[] | null
    notIn?: $Enums.DietaryGoal[] | null
    not?: NestedEnumDietaryGoalNullableFilter<$PrismaModel> | $Enums.DietaryGoal | null
  }

  export type UserHealthConditionListRelationFilter = {
    every?: UserHealthConditionWhereInput
    some?: UserHealthConditionWhereInput
    none?: UserHealthConditionWhereInput
  }

  export type UserAllergyListRelationFilter = {
    every?: UserAllergyWhereInput
    some?: UserAllergyWhereInput
    none?: UserAllergyWhereInput
  }

  export type UserPreferencesNullableScalarRelationFilter = {
    is?: UserPreferencesWhereInput | null
    isNot?: UserPreferencesWhereInput | null
  }

  export type MealPlanListRelationFilter = {
    every?: MealPlanWhereInput
    some?: MealPlanWhereInput
    none?: MealPlanWhereInput
  }

  export type ShoppingListListRelationFilter = {
    every?: ShoppingListWhereInput
    some?: ShoppingListWhereInput
    none?: ShoppingListWhereInput
  }

  export type UserFavoriteRecipeListRelationFilter = {
    every?: UserFavoriteRecipeWhereInput
    some?: UserFavoriteRecipeWhereInput
    none?: UserFavoriteRecipeWhereInput
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type ABTestListRelationFilter = {
    every?: ABTestWhereInput
    some?: ABTestWhereInput
    none?: ABTestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserHealthConditionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAllergyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MealPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShoppingListOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFavoriteRecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ABTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryGoal?: SortOrder
    preferencesJson?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryGoal?: SortOrder
    preferencesJson?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    primaryGoal?: SortOrder
    preferencesJson?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumDietaryGoalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryGoal | EnumDietaryGoalFieldRefInput<$PrismaModel> | null
    in?: $Enums.DietaryGoal[] | null
    notIn?: $Enums.DietaryGoal[] | null
    not?: NestedEnumDietaryGoalNullableWithAggregatesFilter<$PrismaModel> | $Enums.DietaryGoal | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDietaryGoalNullableFilter<$PrismaModel>
    _max?: NestedEnumDietaryGoalNullableFilter<$PrismaModel>
  }

  export type EnumCookingSkillFilter<$PrismaModel = never> = {
    equals?: $Enums.CookingSkill | EnumCookingSkillFieldRefInput<$PrismaModel>
    in?: $Enums.CookingSkill[]
    notIn?: $Enums.CookingSkill[]
    not?: NestedEnumCookingSkillFilter<$PrismaModel> | $Enums.CookingSkill
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumBudgetRangeFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetRange | EnumBudgetRangeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetRange[]
    notIn?: $Enums.BudgetRange[]
    not?: NestedEnumBudgetRangeFilter<$PrismaModel> | $Enums.BudgetRange
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserApplianceListRelationFilter = {
    every?: UserApplianceWhereInput
    some?: UserApplianceWhereInput
    none?: UserApplianceWhereInput
  }

  export type UserBehaviorNullableScalarRelationFilter = {
    is?: UserBehaviorWhereInput | null
    isNot?: UserBehaviorWhereInput | null
  }

  export type UserApplianceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cookingSkillLevel?: SortOrder
    maxPrepTimeMinutes?: SortOrder
    budgetRange?: SortOrder
    householdSize?: SortOrder
    hasOven?: SortOrder
    hasStove?: SortOrder
    hasMicrowave?: SortOrder
    hasBlender?: SortOrder
    hasAirFryer?: SortOrder
    hasSlowCooker?: SortOrder
    hasInstantPot?: SortOrder
    mealsPerDay?: SortOrder
    snacksPerDay?: SortOrder
    batchCookingPreference?: SortOrder
    energyRestrictionGoal?: SortOrder
    targetCaloriesMin?: SortOrder
    targetCaloriesMax?: SortOrder
    cuisinePreferences?: SortOrder
    spiceTolerance?: SortOrder
    flavorIntensity?: SortOrder
    knifeSkillLevel?: SortOrder
    preferredTechniques?: SortOrder
    recipeComplexityComfort?: SortOrder
    weeklyFoodBudget?: SortOrder
    shoppingFrequency?: SortOrder
    mealPlanningApproach?: SortOrder
    textureLimitations?: SortOrder
    foodsToAvoid?: SortOrder
    mealTimingPreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesAvgOrderByAggregateInput = {
    maxPrepTimeMinutes?: SortOrder
    householdSize?: SortOrder
    mealsPerDay?: SortOrder
    snacksPerDay?: SortOrder
    targetCaloriesMin?: SortOrder
    targetCaloriesMax?: SortOrder
    spiceTolerance?: SortOrder
    flavorIntensity?: SortOrder
    recipeComplexityComfort?: SortOrder
    weeklyFoodBudget?: SortOrder
    mealPlanningApproach?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cookingSkillLevel?: SortOrder
    maxPrepTimeMinutes?: SortOrder
    budgetRange?: SortOrder
    householdSize?: SortOrder
    hasOven?: SortOrder
    hasStove?: SortOrder
    hasMicrowave?: SortOrder
    hasBlender?: SortOrder
    hasAirFryer?: SortOrder
    hasSlowCooker?: SortOrder
    hasInstantPot?: SortOrder
    mealsPerDay?: SortOrder
    snacksPerDay?: SortOrder
    batchCookingPreference?: SortOrder
    energyRestrictionGoal?: SortOrder
    targetCaloriesMin?: SortOrder
    targetCaloriesMax?: SortOrder
    cuisinePreferences?: SortOrder
    spiceTolerance?: SortOrder
    flavorIntensity?: SortOrder
    knifeSkillLevel?: SortOrder
    preferredTechniques?: SortOrder
    recipeComplexityComfort?: SortOrder
    weeklyFoodBudget?: SortOrder
    shoppingFrequency?: SortOrder
    mealPlanningApproach?: SortOrder
    textureLimitations?: SortOrder
    foodsToAvoid?: SortOrder
    mealTimingPreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cookingSkillLevel?: SortOrder
    maxPrepTimeMinutes?: SortOrder
    budgetRange?: SortOrder
    householdSize?: SortOrder
    hasOven?: SortOrder
    hasStove?: SortOrder
    hasMicrowave?: SortOrder
    hasBlender?: SortOrder
    hasAirFryer?: SortOrder
    hasSlowCooker?: SortOrder
    hasInstantPot?: SortOrder
    mealsPerDay?: SortOrder
    snacksPerDay?: SortOrder
    batchCookingPreference?: SortOrder
    energyRestrictionGoal?: SortOrder
    targetCaloriesMin?: SortOrder
    targetCaloriesMax?: SortOrder
    cuisinePreferences?: SortOrder
    spiceTolerance?: SortOrder
    flavorIntensity?: SortOrder
    knifeSkillLevel?: SortOrder
    preferredTechniques?: SortOrder
    recipeComplexityComfort?: SortOrder
    weeklyFoodBudget?: SortOrder
    shoppingFrequency?: SortOrder
    mealPlanningApproach?: SortOrder
    textureLimitations?: SortOrder
    foodsToAvoid?: SortOrder
    mealTimingPreference?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesSumOrderByAggregateInput = {
    maxPrepTimeMinutes?: SortOrder
    householdSize?: SortOrder
    mealsPerDay?: SortOrder
    snacksPerDay?: SortOrder
    targetCaloriesMin?: SortOrder
    targetCaloriesMax?: SortOrder
    spiceTolerance?: SortOrder
    flavorIntensity?: SortOrder
    recipeComplexityComfort?: SortOrder
    weeklyFoodBudget?: SortOrder
    mealPlanningApproach?: SortOrder
  }

  export type EnumCookingSkillWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CookingSkill | EnumCookingSkillFieldRefInput<$PrismaModel>
    in?: $Enums.CookingSkill[]
    notIn?: $Enums.CookingSkill[]
    not?: NestedEnumCookingSkillWithAggregatesFilter<$PrismaModel> | $Enums.CookingSkill
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCookingSkillFilter<$PrismaModel>
    _max?: NestedEnumCookingSkillFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumBudgetRangeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetRange | EnumBudgetRangeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetRange[]
    notIn?: $Enums.BudgetRange[]
    not?: NestedEnumBudgetRangeWithAggregatesFilter<$PrismaModel> | $Enums.BudgetRange
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetRangeFilter<$PrismaModel>
    _max?: NestedEnumBudgetRangeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumHealthCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthCategory | EnumHealthCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.HealthCategory[]
    notIn?: $Enums.HealthCategory[]
    not?: NestedEnumHealthCategoryFilter<$PrismaModel> | $Enums.HealthCategory
  }

  export type HealthConditionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type HealthConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type HealthConditionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type EnumHealthCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthCategory | EnumHealthCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.HealthCategory[]
    notIn?: $Enums.HealthCategory[]
    not?: NestedEnumHealthCategoryWithAggregatesFilter<$PrismaModel> | $Enums.HealthCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHealthCategoryFilter<$PrismaModel>
    _max?: NestedEnumHealthCategoryFilter<$PrismaModel>
  }

  export type EnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[]
    notIn?: $Enums.Severity[]
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type HealthConditionScalarRelationFilter = {
    is?: HealthConditionWhereInput
    isNot?: HealthConditionWhereInput
  }

  export type UserHealthConditionUserIdHealthConditionIdCompoundUniqueInput = {
    userId: string
    healthConditionId: string
  }

  export type UserHealthConditionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    healthConditionId?: SortOrder
    severity?: SortOrder
    diagnosedDate?: SortOrder
  }

  export type UserHealthConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    healthConditionId?: SortOrder
    severity?: SortOrder
    diagnosedDate?: SortOrder
  }

  export type UserHealthConditionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    healthConditionId?: SortOrder
    severity?: SortOrder
    diagnosedDate?: SortOrder
  }

  export type EnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[]
    notIn?: $Enums.Severity[]
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAllergenCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AllergenCategory | EnumAllergenCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AllergenCategory[]
    notIn?: $Enums.AllergenCategory[]
    not?: NestedEnumAllergenCategoryFilter<$PrismaModel> | $Enums.AllergenCategory
  }

  export type AllergenCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type AllergenMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type AllergenMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type EnumAllergenCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllergenCategory | EnumAllergenCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AllergenCategory[]
    notIn?: $Enums.AllergenCategory[]
    not?: NestedEnumAllergenCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AllergenCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllergenCategoryFilter<$PrismaModel>
    _max?: NestedEnumAllergenCategoryFilter<$PrismaModel>
  }

  export type AllergenScalarRelationFilter = {
    is?: AllergenWhereInput
    isNot?: AllergenWhereInput
  }

  export type UserAllergyUserIdAllergenIdCompoundUniqueInput = {
    userId: string
    allergenId: string
  }

  export type UserAllergyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    allergenId?: SortOrder
    severity?: SortOrder
  }

  export type UserAllergyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    allergenId?: SortOrder
    severity?: SortOrder
  }

  export type UserAllergyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    allergenId?: SortOrder
    severity?: SortOrder
  }

  export type ApplianceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    category?: SortOrder
  }

  export type ApplianceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    category?: SortOrder
  }

  export type ApplianceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    category?: SortOrder
  }

  export type UserPreferencesScalarRelationFilter = {
    is?: UserPreferencesWhereInput
    isNot?: UserPreferencesWhereInput
  }

  export type ApplianceScalarRelationFilter = {
    is?: ApplianceWhereInput
    isNot?: ApplianceWhereInput
  }

  export type UserApplianceUserPreferencesIdApplianceIdCompoundUniqueInput = {
    userPreferencesId: string
    applianceId: string
  }

  export type UserApplianceCountOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    applianceId?: SortOrder
    usageFrequency?: SortOrder
  }

  export type UserApplianceAvgOrderByAggregateInput = {
    usageFrequency?: SortOrder
  }

  export type UserApplianceMaxOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    applianceId?: SortOrder
    usageFrequency?: SortOrder
  }

  export type UserApplianceMinOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    applianceId?: SortOrder
    usageFrequency?: SortOrder
  }

  export type UserApplianceSumOrderByAggregateInput = {
    usageFrequency?: SortOrder
  }

  export type UserBehaviorCountOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    portionControlMotivation?: SortOrder
    habitChangeReadiness?: SortOrder
    socialEatingPattern?: SortOrder
    successTrackingPreference?: SortOrder
    activityLevel?: SortOrder
    healthConditionPriority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBehaviorAvgOrderByAggregateInput = {
    portionControlMotivation?: SortOrder
    socialEatingPattern?: SortOrder
    healthConditionPriority?: SortOrder
  }

  export type UserBehaviorMaxOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    portionControlMotivation?: SortOrder
    habitChangeReadiness?: SortOrder
    socialEatingPattern?: SortOrder
    successTrackingPreference?: SortOrder
    activityLevel?: SortOrder
    healthConditionPriority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBehaviorMinOrderByAggregateInput = {
    id?: SortOrder
    userPreferencesId?: SortOrder
    portionControlMotivation?: SortOrder
    habitChangeReadiness?: SortOrder
    socialEatingPattern?: SortOrder
    successTrackingPreference?: SortOrder
    activityLevel?: SortOrder
    healthConditionPriority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBehaviorSumOrderByAggregateInput = {
    portionControlMotivation?: SortOrder
    socialEatingPattern?: SortOrder
    healthConditionPriority?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RecipeSpiceBlendListRelationFilter = {
    every?: RecipeSpiceBlendWhereInput
    some?: RecipeSpiceBlendWhereInput
    none?: RecipeSpiceBlendWhereInput
  }

  export type RecipeSpiceBlendOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpiceBlendCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    activeCompounds?: SortOrder
    clinicalEvidence?: SortOrder
    primaryBenefit?: SortOrder
    effectiveDoseGrams?: SortOrder
    bioavailabilityHack?: SortOrder
    quickApplications?: SortOrder
  }

  export type SpiceBlendAvgOrderByAggregateInput = {
    effectiveDoseGrams?: SortOrder
  }

  export type SpiceBlendMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    activeCompounds?: SortOrder
    clinicalEvidence?: SortOrder
    primaryBenefit?: SortOrder
    effectiveDoseGrams?: SortOrder
    bioavailabilityHack?: SortOrder
    quickApplications?: SortOrder
  }

  export type SpiceBlendMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    activeCompounds?: SortOrder
    clinicalEvidence?: SortOrder
    primaryBenefit?: SortOrder
    effectiveDoseGrams?: SortOrder
    bioavailabilityHack?: SortOrder
    quickApplications?: SortOrder
  }

  export type SpiceBlendSumOrderByAggregateInput = {
    effectiveDoseGrams?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RecipeScalarRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type SpiceBlendScalarRelationFilter = {
    is?: SpiceBlendWhereInput
    isNot?: SpiceBlendWhereInput
  }

  export type RecipeSpiceBlendRecipeIdSpiceBlendIdCompoundUniqueInput = {
    recipeId: string
    spiceBlendId: string
  }

  export type RecipeSpiceBlendCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    spiceBlendId?: SortOrder
    amountGrams?: SortOrder
  }

  export type RecipeSpiceBlendAvgOrderByAggregateInput = {
    amountGrams?: SortOrder
  }

  export type RecipeSpiceBlendMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    spiceBlendId?: SortOrder
    amountGrams?: SortOrder
  }

  export type RecipeSpiceBlendMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    spiceBlendId?: SortOrder
    amountGrams?: SortOrder
  }

  export type RecipeSpiceBlendSumOrderByAggregateInput = {
    amountGrams?: SortOrder
  }

  export type RecipeIngredientListRelationFilter = {
    every?: RecipeIngredientWhereInput
    some?: RecipeIngredientWhereInput
    none?: RecipeIngredientWhereInput
  }

  export type RecipeInstructionListRelationFilter = {
    every?: RecipeInstructionWhereInput
    some?: RecipeInstructionWhereInput
    none?: RecipeInstructionWhereInput
  }

  export type RecipeMedicalTagListRelationFilter = {
    every?: RecipeMedicalTagWhereInput
    some?: RecipeMedicalTagWhereInput
    none?: RecipeMedicalTagWhereInput
  }

  export type RecipeDietaryTagListRelationFilter = {
    every?: RecipeDietaryTagWhereInput
    some?: RecipeDietaryTagWhereInput
    none?: RecipeDietaryTagWhereInput
  }

  export type RecipePracticalTagListRelationFilter = {
    every?: RecipePracticalTagWhereInput
    some?: RecipePracticalTagWhereInput
    none?: RecipePracticalTagWhereInput
  }

  export type RecipeNutritionalTagListRelationFilter = {
    every?: RecipeNutritionalTagWhereInput
    some?: RecipeNutritionalTagWhereInput
    none?: RecipeNutritionalTagWhereInput
  }

  export type NutritionalInfoNullableScalarRelationFilter = {
    is?: NutritionalInfoWhereInput | null
    isNot?: NutritionalInfoWhereInput | null
  }

  export type MealPlanItemListRelationFilter = {
    every?: MealPlanItemWhereInput
    some?: MealPlanItemWhereInput
    none?: MealPlanItemWhereInput
  }

  export type RecipeIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeInstructionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeMedicalTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeDietaryTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipePracticalTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeNutritionalTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MealPlanItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    servings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepTimeMinutes?: SortOrder
    cookTimeMinutes?: SortOrder
    totalTimeMinutes?: SortOrder
    complexity?: SortOrder
    costTier?: SortOrder
    requiredAppliances?: SortOrder
    goalTags?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    servings?: SortOrder
    prepTimeMinutes?: SortOrder
    cookTimeMinutes?: SortOrder
    totalTimeMinutes?: SortOrder
    complexity?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    servings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepTimeMinutes?: SortOrder
    cookTimeMinutes?: SortOrder
    totalTimeMinutes?: SortOrder
    complexity?: SortOrder
    costTier?: SortOrder
    requiredAppliances?: SortOrder
    goalTags?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    servings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prepTimeMinutes?: SortOrder
    cookTimeMinutes?: SortOrder
    totalTimeMinutes?: SortOrder
    complexity?: SortOrder
    costTier?: SortOrder
    requiredAppliances?: SortOrder
    goalTags?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    servings?: SortOrder
    prepTimeMinutes?: SortOrder
    cookTimeMinutes?: SortOrder
    totalTimeMinutes?: SortOrder
    complexity?: SortOrder
  }

  export type RecipeIngredientCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
  }

  export type RecipeIngredientAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RecipeIngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
  }

  export type RecipeIngredientMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
  }

  export type RecipeIngredientSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RecipeInstructionCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
  }

  export type RecipeInstructionAvgOrderByAggregateInput = {
    stepNumber?: SortOrder
  }

  export type RecipeInstructionMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
  }

  export type RecipeInstructionMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    stepNumber?: SortOrder
    instruction?: SortOrder
  }

  export type RecipeInstructionSumOrderByAggregateInput = {
    stepNumber?: SortOrder
  }

  export type NutritionalInfoCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbohydrates?: SortOrder
    fat?: SortOrder
    fiber?: SortOrder
    sugar?: SortOrder
    sodium?: SortOrder
    cholesterol?: SortOrder
    vitaminC?: SortOrder
    vitaminD?: SortOrder
    calcium?: SortOrder
    iron?: SortOrder
    potassium?: SortOrder
  }

  export type NutritionalInfoAvgOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbohydrates?: SortOrder
    fat?: SortOrder
    fiber?: SortOrder
    sugar?: SortOrder
    sodium?: SortOrder
    cholesterol?: SortOrder
    vitaminC?: SortOrder
    vitaminD?: SortOrder
    calcium?: SortOrder
    iron?: SortOrder
    potassium?: SortOrder
  }

  export type NutritionalInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbohydrates?: SortOrder
    fat?: SortOrder
    fiber?: SortOrder
    sugar?: SortOrder
    sodium?: SortOrder
    cholesterol?: SortOrder
    vitaminC?: SortOrder
    vitaminD?: SortOrder
    calcium?: SortOrder
    iron?: SortOrder
    potassium?: SortOrder
  }

  export type NutritionalInfoMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    calories?: SortOrder
    protein?: SortOrder
    carbohydrates?: SortOrder
    fat?: SortOrder
    fiber?: SortOrder
    sugar?: SortOrder
    sodium?: SortOrder
    cholesterol?: SortOrder
    vitaminC?: SortOrder
    vitaminD?: SortOrder
    calcium?: SortOrder
    iron?: SortOrder
    potassium?: SortOrder
  }

  export type NutritionalInfoSumOrderByAggregateInput = {
    calories?: SortOrder
    protein?: SortOrder
    carbohydrates?: SortOrder
    fat?: SortOrder
    fiber?: SortOrder
    sugar?: SortOrder
    sodium?: SortOrder
    cholesterol?: SortOrder
    vitaminC?: SortOrder
    vitaminD?: SortOrder
    calcium?: SortOrder
    iron?: SortOrder
    potassium?: SortOrder
  }

  export type MedicalTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    condition?: SortOrder
  }

  export type MedicalTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    condition?: SortOrder
  }

  export type MedicalTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    condition?: SortOrder
  }

  export type MedicalTagScalarRelationFilter = {
    is?: MedicalTagWhereInput
    isNot?: MedicalTagWhereInput
  }

  export type RecipeMedicalTagRecipeIdMedicalTagIdCompoundUniqueInput = {
    recipeId: string
    medicalTagId: string
  }

  export type RecipeMedicalTagCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    medicalTagId?: SortOrder
  }

  export type RecipeMedicalTagMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    medicalTagId?: SortOrder
  }

  export type RecipeMedicalTagMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    medicalTagId?: SortOrder
  }

  export type EnumDietaryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryCategory | EnumDietaryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DietaryCategory[]
    notIn?: $Enums.DietaryCategory[]
    not?: NestedEnumDietaryCategoryFilter<$PrismaModel> | $Enums.DietaryCategory
  }

  export type DietaryTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type DietaryTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type DietaryTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type EnumDietaryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryCategory | EnumDietaryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DietaryCategory[]
    notIn?: $Enums.DietaryCategory[]
    not?: NestedEnumDietaryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DietaryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDietaryCategoryFilter<$PrismaModel>
    _max?: NestedEnumDietaryCategoryFilter<$PrismaModel>
  }

  export type DietaryTagScalarRelationFilter = {
    is?: DietaryTagWhereInput
    isNot?: DietaryTagWhereInput
  }

  export type RecipeDietaryTagRecipeIdDietaryTagIdCompoundUniqueInput = {
    recipeId: string
    dietaryTagId: string
  }

  export type RecipeDietaryTagCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    dietaryTagId?: SortOrder
  }

  export type RecipeDietaryTagMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    dietaryTagId?: SortOrder
  }

  export type RecipeDietaryTagMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    dietaryTagId?: SortOrder
  }

  export type EnumPracticalCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PracticalCategory | EnumPracticalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PracticalCategory[]
    notIn?: $Enums.PracticalCategory[]
    not?: NestedEnumPracticalCategoryFilter<$PrismaModel> | $Enums.PracticalCategory
  }

  export type PracticalTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type PracticalTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type PracticalTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type EnumPracticalCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PracticalCategory | EnumPracticalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PracticalCategory[]
    notIn?: $Enums.PracticalCategory[]
    not?: NestedEnumPracticalCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PracticalCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPracticalCategoryFilter<$PrismaModel>
    _max?: NestedEnumPracticalCategoryFilter<$PrismaModel>
  }

  export type PracticalTagScalarRelationFilter = {
    is?: PracticalTagWhereInput
    isNot?: PracticalTagWhereInput
  }

  export type RecipePracticalTagRecipeIdPracticalTagIdCompoundUniqueInput = {
    recipeId: string
    practicalTagId: string
  }

  export type RecipePracticalTagCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    practicalTagId?: SortOrder
  }

  export type RecipePracticalTagMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    practicalTagId?: SortOrder
  }

  export type RecipePracticalTagMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    practicalTagId?: SortOrder
  }

  export type EnumNutritionalCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NutritionalCategory | EnumNutritionalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NutritionalCategory[]
    notIn?: $Enums.NutritionalCategory[]
    not?: NestedEnumNutritionalCategoryFilter<$PrismaModel> | $Enums.NutritionalCategory
  }

  export type NutritionalTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type NutritionalTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type NutritionalTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type EnumNutritionalCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NutritionalCategory | EnumNutritionalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NutritionalCategory[]
    notIn?: $Enums.NutritionalCategory[]
    not?: NestedEnumNutritionalCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NutritionalCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNutritionalCategoryFilter<$PrismaModel>
    _max?: NestedEnumNutritionalCategoryFilter<$PrismaModel>
  }

  export type NutritionalTagScalarRelationFilter = {
    is?: NutritionalTagWhereInput
    isNot?: NutritionalTagWhereInput
  }

  export type RecipeNutritionalTagRecipeIdNutritionalTagIdCompoundUniqueInput = {
    recipeId: string
    nutritionalTagId: string
  }

  export type RecipeNutritionalTagCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    nutritionalTagId?: SortOrder
  }

  export type RecipeNutritionalTagMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    nutritionalTagId?: SortOrder
  }

  export type RecipeNutritionalTagMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    nutritionalTagId?: SortOrder
  }

  export type ShoppingListNullableScalarRelationFilter = {
    is?: ShoppingListWhereInput | null
    isNot?: ShoppingListWhereInput | null
  }

  export type MealPlanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    weekStartDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MealPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    weekStartDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MealPlanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    weekStartDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type EnumMealTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MealType | EnumMealTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MealType[]
    notIn?: $Enums.MealType[]
    not?: NestedEnumMealTypeFilter<$PrismaModel> | $Enums.MealType
  }

  export type MealPlanScalarRelationFilter = {
    is?: MealPlanWhereInput
    isNot?: MealPlanWhereInput
  }

  export type MealPlanItemCountOrderByAggregateInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    recipeId?: SortOrder
    dayOfWeek?: SortOrder
    mealType?: SortOrder
    servings?: SortOrder
  }

  export type MealPlanItemAvgOrderByAggregateInput = {
    servings?: SortOrder
  }

  export type MealPlanItemMaxOrderByAggregateInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    recipeId?: SortOrder
    dayOfWeek?: SortOrder
    mealType?: SortOrder
    servings?: SortOrder
  }

  export type MealPlanItemMinOrderByAggregateInput = {
    id?: SortOrder
    mealPlanId?: SortOrder
    recipeId?: SortOrder
    dayOfWeek?: SortOrder
    mealType?: SortOrder
    servings?: SortOrder
  }

  export type MealPlanItemSumOrderByAggregateInput = {
    servings?: SortOrder
  }

  export type EnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type EnumMealTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MealType | EnumMealTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MealType[]
    notIn?: $Enums.MealType[]
    not?: NestedEnumMealTypeWithAggregatesFilter<$PrismaModel> | $Enums.MealType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMealTypeFilter<$PrismaModel>
    _max?: NestedEnumMealTypeFilter<$PrismaModel>
  }

  export type MealPlanNullableScalarRelationFilter = {
    is?: MealPlanWhereInput | null
    isNot?: MealPlanWhereInput | null
  }

  export type ShoppingListItemListRelationFilter = {
    every?: ShoppingListItemWhereInput
    some?: ShoppingListItemWhereInput
    none?: ShoppingListItemWhereInput
  }

  export type ShoppingListItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShoppingListCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mealPlanId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShoppingListMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mealPlanId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShoppingListMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mealPlanId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShoppingListScalarRelationFilter = {
    is?: ShoppingListWhereInput
    isNot?: ShoppingListWhereInput
  }

  export type ShoppingListItemCountOrderByAggregateInput = {
    id?: SortOrder
    shoppingListId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    category?: SortOrder
    purchased?: SortOrder
    estimatedPrice?: SortOrder
  }

  export type ShoppingListItemAvgOrderByAggregateInput = {
    amount?: SortOrder
    estimatedPrice?: SortOrder
  }

  export type ShoppingListItemMaxOrderByAggregateInput = {
    id?: SortOrder
    shoppingListId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    category?: SortOrder
    purchased?: SortOrder
    estimatedPrice?: SortOrder
  }

  export type ShoppingListItemMinOrderByAggregateInput = {
    id?: SortOrder
    shoppingListId?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    unit?: SortOrder
    category?: SortOrder
    purchased?: SortOrder
    estimatedPrice?: SortOrder
  }

  export type ShoppingListItemSumOrderByAggregateInput = {
    amount?: SortOrder
    estimatedPrice?: SortOrder
  }

  export type UserFavoriteRecipeUserIdRecipeIdCompoundUniqueInput = {
    userId: string
    recipeId: string
  }

  export type UserFavoriteRecipeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    addedAt?: SortOrder
  }

  export type UserFavoriteRecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    addedAt?: SortOrder
  }

  export type UserFavoriteRecipeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    addedAt?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[]
    notIn?: $Enums.SubscriptionTier[]
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    tier?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    tier?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    status?: SortOrder
    tier?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[]
    notIn?: $Enums.SubscriptionTier[]
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type FeedbackUserIdRecipeIdCompoundUniqueInput = {
    userId: string
    recipeId: string
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    recipeId?: SortOrder
    rating?: SortOrder
    notes?: SortOrder
    timestamp?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ABTestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    variant?: SortOrder
    timestamp?: SortOrder
  }

  export type ABTestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    variant?: SortOrder
    timestamp?: SortOrder
  }

  export type ABTestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    variant?: SortOrder
    timestamp?: SortOrder
  }

  export type UserHealthConditionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserHealthConditionCreateWithoutUserInput, UserHealthConditionUncheckedCreateWithoutUserInput> | UserHealthConditionCreateWithoutUserInput[] | UserHealthConditionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserHealthConditionCreateOrConnectWithoutUserInput | UserHealthConditionCreateOrConnectWithoutUserInput[]
    createMany?: UserHealthConditionCreateManyUserInputEnvelope
    connect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
  }

  export type UserAllergyCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAllergyCreateWithoutUserInput, UserAllergyUncheckedCreateWithoutUserInput> | UserAllergyCreateWithoutUserInput[] | UserAllergyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAllergyCreateOrConnectWithoutUserInput | UserAllergyCreateOrConnectWithoutUserInput[]
    createMany?: UserAllergyCreateManyUserInputEnvelope
    connect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
  }

  export type UserPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type MealPlanCreateNestedManyWithoutUserInput = {
    create?: XOR<MealPlanCreateWithoutUserInput, MealPlanUncheckedCreateWithoutUserInput> | MealPlanCreateWithoutUserInput[] | MealPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MealPlanCreateOrConnectWithoutUserInput | MealPlanCreateOrConnectWithoutUserInput[]
    createMany?: MealPlanCreateManyUserInputEnvelope
    connect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
  }

  export type ShoppingListCreateNestedManyWithoutUserInput = {
    create?: XOR<ShoppingListCreateWithoutUserInput, ShoppingListUncheckedCreateWithoutUserInput> | ShoppingListCreateWithoutUserInput[] | ShoppingListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShoppingListCreateOrConnectWithoutUserInput | ShoppingListCreateOrConnectWithoutUserInput[]
    createMany?: ShoppingListCreateManyUserInputEnvelope
    connect?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
  }

  export type UserFavoriteRecipeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteRecipeCreateWithoutUserInput, UserFavoriteRecipeUncheckedCreateWithoutUserInput> | UserFavoriteRecipeCreateWithoutUserInput[] | UserFavoriteRecipeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteRecipeCreateOrConnectWithoutUserInput | UserFavoriteRecipeCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteRecipeCreateManyUserInputEnvelope
    connect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type FeedbackCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ABTestCreateNestedManyWithoutUserInput = {
    create?: XOR<ABTestCreateWithoutUserInput, ABTestUncheckedCreateWithoutUserInput> | ABTestCreateWithoutUserInput[] | ABTestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ABTestCreateOrConnectWithoutUserInput | ABTestCreateOrConnectWithoutUserInput[]
    createMany?: ABTestCreateManyUserInputEnvelope
    connect?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
  }

  export type UserHealthConditionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserHealthConditionCreateWithoutUserInput, UserHealthConditionUncheckedCreateWithoutUserInput> | UserHealthConditionCreateWithoutUserInput[] | UserHealthConditionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserHealthConditionCreateOrConnectWithoutUserInput | UserHealthConditionCreateOrConnectWithoutUserInput[]
    createMany?: UserHealthConditionCreateManyUserInputEnvelope
    connect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
  }

  export type UserAllergyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAllergyCreateWithoutUserInput, UserAllergyUncheckedCreateWithoutUserInput> | UserAllergyCreateWithoutUserInput[] | UserAllergyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAllergyCreateOrConnectWithoutUserInput | UserAllergyCreateOrConnectWithoutUserInput[]
    createMany?: UserAllergyCreateManyUserInputEnvelope
    connect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
  }

  export type UserPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type MealPlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MealPlanCreateWithoutUserInput, MealPlanUncheckedCreateWithoutUserInput> | MealPlanCreateWithoutUserInput[] | MealPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MealPlanCreateOrConnectWithoutUserInput | MealPlanCreateOrConnectWithoutUserInput[]
    createMany?: MealPlanCreateManyUserInputEnvelope
    connect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
  }

  export type ShoppingListUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShoppingListCreateWithoutUserInput, ShoppingListUncheckedCreateWithoutUserInput> | ShoppingListCreateWithoutUserInput[] | ShoppingListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShoppingListCreateOrConnectWithoutUserInput | ShoppingListCreateOrConnectWithoutUserInput[]
    createMany?: ShoppingListCreateManyUserInputEnvelope
    connect?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
  }

  export type UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteRecipeCreateWithoutUserInput, UserFavoriteRecipeUncheckedCreateWithoutUserInput> | UserFavoriteRecipeCreateWithoutUserInput[] | UserFavoriteRecipeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteRecipeCreateOrConnectWithoutUserInput | UserFavoriteRecipeCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteRecipeCreateManyUserInputEnvelope
    connect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type FeedbackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ABTestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ABTestCreateWithoutUserInput, ABTestUncheckedCreateWithoutUserInput> | ABTestCreateWithoutUserInput[] | ABTestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ABTestCreateOrConnectWithoutUserInput | ABTestCreateOrConnectWithoutUserInput[]
    createMany?: ABTestCreateManyUserInputEnvelope
    connect?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableEnumDietaryGoalFieldUpdateOperationsInput = {
    set?: $Enums.DietaryGoal | null
  }

  export type UserHealthConditionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserHealthConditionCreateWithoutUserInput, UserHealthConditionUncheckedCreateWithoutUserInput> | UserHealthConditionCreateWithoutUserInput[] | UserHealthConditionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserHealthConditionCreateOrConnectWithoutUserInput | UserHealthConditionCreateOrConnectWithoutUserInput[]
    upsert?: UserHealthConditionUpsertWithWhereUniqueWithoutUserInput | UserHealthConditionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserHealthConditionCreateManyUserInputEnvelope
    set?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    disconnect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    delete?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    connect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    update?: UserHealthConditionUpdateWithWhereUniqueWithoutUserInput | UserHealthConditionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserHealthConditionUpdateManyWithWhereWithoutUserInput | UserHealthConditionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserHealthConditionScalarWhereInput | UserHealthConditionScalarWhereInput[]
  }

  export type UserAllergyUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAllergyCreateWithoutUserInput, UserAllergyUncheckedCreateWithoutUserInput> | UserAllergyCreateWithoutUserInput[] | UserAllergyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAllergyCreateOrConnectWithoutUserInput | UserAllergyCreateOrConnectWithoutUserInput[]
    upsert?: UserAllergyUpsertWithWhereUniqueWithoutUserInput | UserAllergyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAllergyCreateManyUserInputEnvelope
    set?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    disconnect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    delete?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    connect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    update?: UserAllergyUpdateWithWhereUniqueWithoutUserInput | UserAllergyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAllergyUpdateManyWithWhereWithoutUserInput | UserAllergyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAllergyScalarWhereInput | UserAllergyScalarWhereInput[]
  }

  export type UserPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type MealPlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<MealPlanCreateWithoutUserInput, MealPlanUncheckedCreateWithoutUserInput> | MealPlanCreateWithoutUserInput[] | MealPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MealPlanCreateOrConnectWithoutUserInput | MealPlanCreateOrConnectWithoutUserInput[]
    upsert?: MealPlanUpsertWithWhereUniqueWithoutUserInput | MealPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MealPlanCreateManyUserInputEnvelope
    set?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    disconnect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    delete?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    connect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    update?: MealPlanUpdateWithWhereUniqueWithoutUserInput | MealPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MealPlanUpdateManyWithWhereWithoutUserInput | MealPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MealPlanScalarWhereInput | MealPlanScalarWhereInput[]
  }

  export type ShoppingListUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShoppingListCreateWithoutUserInput, ShoppingListUncheckedCreateWithoutUserInput> | ShoppingListCreateWithoutUserInput[] | ShoppingListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShoppingListCreateOrConnectWithoutUserInput | ShoppingListCreateOrConnectWithoutUserInput[]
    upsert?: ShoppingListUpsertWithWhereUniqueWithoutUserInput | ShoppingListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShoppingListCreateManyUserInputEnvelope
    set?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
    disconnect?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
    delete?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
    connect?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
    update?: ShoppingListUpdateWithWhereUniqueWithoutUserInput | ShoppingListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShoppingListUpdateManyWithWhereWithoutUserInput | ShoppingListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShoppingListScalarWhereInput | ShoppingListScalarWhereInput[]
  }

  export type UserFavoriteRecipeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteRecipeCreateWithoutUserInput, UserFavoriteRecipeUncheckedCreateWithoutUserInput> | UserFavoriteRecipeCreateWithoutUserInput[] | UserFavoriteRecipeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteRecipeCreateOrConnectWithoutUserInput | UserFavoriteRecipeCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteRecipeUpsertWithWhereUniqueWithoutUserInput | UserFavoriteRecipeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteRecipeCreateManyUserInputEnvelope
    set?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    disconnect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    delete?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    connect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    update?: UserFavoriteRecipeUpdateWithWhereUniqueWithoutUserInput | UserFavoriteRecipeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteRecipeUpdateManyWithWhereWithoutUserInput | UserFavoriteRecipeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteRecipeScalarWhereInput | UserFavoriteRecipeScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ABTestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ABTestCreateWithoutUserInput, ABTestUncheckedCreateWithoutUserInput> | ABTestCreateWithoutUserInput[] | ABTestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ABTestCreateOrConnectWithoutUserInput | ABTestCreateOrConnectWithoutUserInput[]
    upsert?: ABTestUpsertWithWhereUniqueWithoutUserInput | ABTestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ABTestCreateManyUserInputEnvelope
    set?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
    disconnect?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
    delete?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
    connect?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
    update?: ABTestUpdateWithWhereUniqueWithoutUserInput | ABTestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ABTestUpdateManyWithWhereWithoutUserInput | ABTestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ABTestScalarWhereInput | ABTestScalarWhereInput[]
  }

  export type UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserHealthConditionCreateWithoutUserInput, UserHealthConditionUncheckedCreateWithoutUserInput> | UserHealthConditionCreateWithoutUserInput[] | UserHealthConditionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserHealthConditionCreateOrConnectWithoutUserInput | UserHealthConditionCreateOrConnectWithoutUserInput[]
    upsert?: UserHealthConditionUpsertWithWhereUniqueWithoutUserInput | UserHealthConditionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserHealthConditionCreateManyUserInputEnvelope
    set?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    disconnect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    delete?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    connect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    update?: UserHealthConditionUpdateWithWhereUniqueWithoutUserInput | UserHealthConditionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserHealthConditionUpdateManyWithWhereWithoutUserInput | UserHealthConditionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserHealthConditionScalarWhereInput | UserHealthConditionScalarWhereInput[]
  }

  export type UserAllergyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAllergyCreateWithoutUserInput, UserAllergyUncheckedCreateWithoutUserInput> | UserAllergyCreateWithoutUserInput[] | UserAllergyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAllergyCreateOrConnectWithoutUserInput | UserAllergyCreateOrConnectWithoutUserInput[]
    upsert?: UserAllergyUpsertWithWhereUniqueWithoutUserInput | UserAllergyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAllergyCreateManyUserInputEnvelope
    set?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    disconnect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    delete?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    connect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    update?: UserAllergyUpdateWithWhereUniqueWithoutUserInput | UserAllergyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAllergyUpdateManyWithWhereWithoutUserInput | UserAllergyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAllergyScalarWhereInput | UserAllergyScalarWhereInput[]
  }

  export type UserPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type MealPlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MealPlanCreateWithoutUserInput, MealPlanUncheckedCreateWithoutUserInput> | MealPlanCreateWithoutUserInput[] | MealPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MealPlanCreateOrConnectWithoutUserInput | MealPlanCreateOrConnectWithoutUserInput[]
    upsert?: MealPlanUpsertWithWhereUniqueWithoutUserInput | MealPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MealPlanCreateManyUserInputEnvelope
    set?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    disconnect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    delete?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    connect?: MealPlanWhereUniqueInput | MealPlanWhereUniqueInput[]
    update?: MealPlanUpdateWithWhereUniqueWithoutUserInput | MealPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MealPlanUpdateManyWithWhereWithoutUserInput | MealPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MealPlanScalarWhereInput | MealPlanScalarWhereInput[]
  }

  export type ShoppingListUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShoppingListCreateWithoutUserInput, ShoppingListUncheckedCreateWithoutUserInput> | ShoppingListCreateWithoutUserInput[] | ShoppingListUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShoppingListCreateOrConnectWithoutUserInput | ShoppingListCreateOrConnectWithoutUserInput[]
    upsert?: ShoppingListUpsertWithWhereUniqueWithoutUserInput | ShoppingListUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShoppingListCreateManyUserInputEnvelope
    set?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
    disconnect?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
    delete?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
    connect?: ShoppingListWhereUniqueInput | ShoppingListWhereUniqueInput[]
    update?: ShoppingListUpdateWithWhereUniqueWithoutUserInput | ShoppingListUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShoppingListUpdateManyWithWhereWithoutUserInput | ShoppingListUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShoppingListScalarWhereInput | ShoppingListScalarWhereInput[]
  }

  export type UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteRecipeCreateWithoutUserInput, UserFavoriteRecipeUncheckedCreateWithoutUserInput> | UserFavoriteRecipeCreateWithoutUserInput[] | UserFavoriteRecipeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteRecipeCreateOrConnectWithoutUserInput | UserFavoriteRecipeCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteRecipeUpsertWithWhereUniqueWithoutUserInput | UserFavoriteRecipeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteRecipeCreateManyUserInputEnvelope
    set?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    disconnect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    delete?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    connect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    update?: UserFavoriteRecipeUpdateWithWhereUniqueWithoutUserInput | UserFavoriteRecipeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteRecipeUpdateManyWithWhereWithoutUserInput | UserFavoriteRecipeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteRecipeScalarWhereInput | UserFavoriteRecipeScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput
    upsert?: SubscriptionUpsertWithoutUserInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutUserInput, SubscriptionUpdateWithoutUserInput>, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput> | FeedbackCreateWithoutUserInput[] | FeedbackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutUserInput | FeedbackCreateOrConnectWithoutUserInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutUserInput | FeedbackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FeedbackCreateManyUserInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutUserInput | FeedbackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutUserInput | FeedbackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type ABTestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ABTestCreateWithoutUserInput, ABTestUncheckedCreateWithoutUserInput> | ABTestCreateWithoutUserInput[] | ABTestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ABTestCreateOrConnectWithoutUserInput | ABTestCreateOrConnectWithoutUserInput[]
    upsert?: ABTestUpsertWithWhereUniqueWithoutUserInput | ABTestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ABTestCreateManyUserInputEnvelope
    set?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
    disconnect?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
    delete?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
    connect?: ABTestWhereUniqueInput | ABTestWhereUniqueInput[]
    update?: ABTestUpdateWithWhereUniqueWithoutUserInput | ABTestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ABTestUpdateManyWithWhereWithoutUserInput | ABTestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ABTestScalarWhereInput | ABTestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserApplianceCreateNestedManyWithoutUserPreferencesInput = {
    create?: XOR<UserApplianceCreateWithoutUserPreferencesInput, UserApplianceUncheckedCreateWithoutUserPreferencesInput> | UserApplianceCreateWithoutUserPreferencesInput[] | UserApplianceUncheckedCreateWithoutUserPreferencesInput[]
    connectOrCreate?: UserApplianceCreateOrConnectWithoutUserPreferencesInput | UserApplianceCreateOrConnectWithoutUserPreferencesInput[]
    createMany?: UserApplianceCreateManyUserPreferencesInputEnvelope
    connect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
  }

  export type UserBehaviorCreateNestedOneWithoutUserPreferencesInput = {
    create?: XOR<UserBehaviorCreateWithoutUserPreferencesInput, UserBehaviorUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserBehaviorCreateOrConnectWithoutUserPreferencesInput
    connect?: UserBehaviorWhereUniqueInput
  }

  export type UserApplianceUncheckedCreateNestedManyWithoutUserPreferencesInput = {
    create?: XOR<UserApplianceCreateWithoutUserPreferencesInput, UserApplianceUncheckedCreateWithoutUserPreferencesInput> | UserApplianceCreateWithoutUserPreferencesInput[] | UserApplianceUncheckedCreateWithoutUserPreferencesInput[]
    connectOrCreate?: UserApplianceCreateOrConnectWithoutUserPreferencesInput | UserApplianceCreateOrConnectWithoutUserPreferencesInput[]
    createMany?: UserApplianceCreateManyUserPreferencesInputEnvelope
    connect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
  }

  export type UserBehaviorUncheckedCreateNestedOneWithoutUserPreferencesInput = {
    create?: XOR<UserBehaviorCreateWithoutUserPreferencesInput, UserBehaviorUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserBehaviorCreateOrConnectWithoutUserPreferencesInput
    connect?: UserBehaviorWhereUniqueInput
  }

  export type EnumCookingSkillFieldUpdateOperationsInput = {
    set?: $Enums.CookingSkill
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBudgetRangeFieldUpdateOperationsInput = {
    set?: $Enums.BudgetRange
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserApplianceUpdateManyWithoutUserPreferencesNestedInput = {
    create?: XOR<UserApplianceCreateWithoutUserPreferencesInput, UserApplianceUncheckedCreateWithoutUserPreferencesInput> | UserApplianceCreateWithoutUserPreferencesInput[] | UserApplianceUncheckedCreateWithoutUserPreferencesInput[]
    connectOrCreate?: UserApplianceCreateOrConnectWithoutUserPreferencesInput | UserApplianceCreateOrConnectWithoutUserPreferencesInput[]
    upsert?: UserApplianceUpsertWithWhereUniqueWithoutUserPreferencesInput | UserApplianceUpsertWithWhereUniqueWithoutUserPreferencesInput[]
    createMany?: UserApplianceCreateManyUserPreferencesInputEnvelope
    set?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    disconnect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    delete?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    connect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    update?: UserApplianceUpdateWithWhereUniqueWithoutUserPreferencesInput | UserApplianceUpdateWithWhereUniqueWithoutUserPreferencesInput[]
    updateMany?: UserApplianceUpdateManyWithWhereWithoutUserPreferencesInput | UserApplianceUpdateManyWithWhereWithoutUserPreferencesInput[]
    deleteMany?: UserApplianceScalarWhereInput | UserApplianceScalarWhereInput[]
  }

  export type UserBehaviorUpdateOneWithoutUserPreferencesNestedInput = {
    create?: XOR<UserBehaviorCreateWithoutUserPreferencesInput, UserBehaviorUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserBehaviorCreateOrConnectWithoutUserPreferencesInput
    upsert?: UserBehaviorUpsertWithoutUserPreferencesInput
    disconnect?: UserBehaviorWhereInput | boolean
    delete?: UserBehaviorWhereInput | boolean
    connect?: UserBehaviorWhereUniqueInput
    update?: XOR<XOR<UserBehaviorUpdateToOneWithWhereWithoutUserPreferencesInput, UserBehaviorUpdateWithoutUserPreferencesInput>, UserBehaviorUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type UserApplianceUncheckedUpdateManyWithoutUserPreferencesNestedInput = {
    create?: XOR<UserApplianceCreateWithoutUserPreferencesInput, UserApplianceUncheckedCreateWithoutUserPreferencesInput> | UserApplianceCreateWithoutUserPreferencesInput[] | UserApplianceUncheckedCreateWithoutUserPreferencesInput[]
    connectOrCreate?: UserApplianceCreateOrConnectWithoutUserPreferencesInput | UserApplianceCreateOrConnectWithoutUserPreferencesInput[]
    upsert?: UserApplianceUpsertWithWhereUniqueWithoutUserPreferencesInput | UserApplianceUpsertWithWhereUniqueWithoutUserPreferencesInput[]
    createMany?: UserApplianceCreateManyUserPreferencesInputEnvelope
    set?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    disconnect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    delete?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    connect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    update?: UserApplianceUpdateWithWhereUniqueWithoutUserPreferencesInput | UserApplianceUpdateWithWhereUniqueWithoutUserPreferencesInput[]
    updateMany?: UserApplianceUpdateManyWithWhereWithoutUserPreferencesInput | UserApplianceUpdateManyWithWhereWithoutUserPreferencesInput[]
    deleteMany?: UserApplianceScalarWhereInput | UserApplianceScalarWhereInput[]
  }

  export type UserBehaviorUncheckedUpdateOneWithoutUserPreferencesNestedInput = {
    create?: XOR<UserBehaviorCreateWithoutUserPreferencesInput, UserBehaviorUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserBehaviorCreateOrConnectWithoutUserPreferencesInput
    upsert?: UserBehaviorUpsertWithoutUserPreferencesInput
    disconnect?: UserBehaviorWhereInput | boolean
    delete?: UserBehaviorWhereInput | boolean
    connect?: UserBehaviorWhereUniqueInput
    update?: XOR<XOR<UserBehaviorUpdateToOneWithWhereWithoutUserPreferencesInput, UserBehaviorUpdateWithoutUserPreferencesInput>, UserBehaviorUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type UserHealthConditionCreateNestedManyWithoutHealthConditionInput = {
    create?: XOR<UserHealthConditionCreateWithoutHealthConditionInput, UserHealthConditionUncheckedCreateWithoutHealthConditionInput> | UserHealthConditionCreateWithoutHealthConditionInput[] | UserHealthConditionUncheckedCreateWithoutHealthConditionInput[]
    connectOrCreate?: UserHealthConditionCreateOrConnectWithoutHealthConditionInput | UserHealthConditionCreateOrConnectWithoutHealthConditionInput[]
    createMany?: UserHealthConditionCreateManyHealthConditionInputEnvelope
    connect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
  }

  export type UserHealthConditionUncheckedCreateNestedManyWithoutHealthConditionInput = {
    create?: XOR<UserHealthConditionCreateWithoutHealthConditionInput, UserHealthConditionUncheckedCreateWithoutHealthConditionInput> | UserHealthConditionCreateWithoutHealthConditionInput[] | UserHealthConditionUncheckedCreateWithoutHealthConditionInput[]
    connectOrCreate?: UserHealthConditionCreateOrConnectWithoutHealthConditionInput | UserHealthConditionCreateOrConnectWithoutHealthConditionInput[]
    createMany?: UserHealthConditionCreateManyHealthConditionInputEnvelope
    connect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
  }

  export type EnumHealthCategoryFieldUpdateOperationsInput = {
    set?: $Enums.HealthCategory
  }

  export type UserHealthConditionUpdateManyWithoutHealthConditionNestedInput = {
    create?: XOR<UserHealthConditionCreateWithoutHealthConditionInput, UserHealthConditionUncheckedCreateWithoutHealthConditionInput> | UserHealthConditionCreateWithoutHealthConditionInput[] | UserHealthConditionUncheckedCreateWithoutHealthConditionInput[]
    connectOrCreate?: UserHealthConditionCreateOrConnectWithoutHealthConditionInput | UserHealthConditionCreateOrConnectWithoutHealthConditionInput[]
    upsert?: UserHealthConditionUpsertWithWhereUniqueWithoutHealthConditionInput | UserHealthConditionUpsertWithWhereUniqueWithoutHealthConditionInput[]
    createMany?: UserHealthConditionCreateManyHealthConditionInputEnvelope
    set?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    disconnect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    delete?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    connect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    update?: UserHealthConditionUpdateWithWhereUniqueWithoutHealthConditionInput | UserHealthConditionUpdateWithWhereUniqueWithoutHealthConditionInput[]
    updateMany?: UserHealthConditionUpdateManyWithWhereWithoutHealthConditionInput | UserHealthConditionUpdateManyWithWhereWithoutHealthConditionInput[]
    deleteMany?: UserHealthConditionScalarWhereInput | UserHealthConditionScalarWhereInput[]
  }

  export type UserHealthConditionUncheckedUpdateManyWithoutHealthConditionNestedInput = {
    create?: XOR<UserHealthConditionCreateWithoutHealthConditionInput, UserHealthConditionUncheckedCreateWithoutHealthConditionInput> | UserHealthConditionCreateWithoutHealthConditionInput[] | UserHealthConditionUncheckedCreateWithoutHealthConditionInput[]
    connectOrCreate?: UserHealthConditionCreateOrConnectWithoutHealthConditionInput | UserHealthConditionCreateOrConnectWithoutHealthConditionInput[]
    upsert?: UserHealthConditionUpsertWithWhereUniqueWithoutHealthConditionInput | UserHealthConditionUpsertWithWhereUniqueWithoutHealthConditionInput[]
    createMany?: UserHealthConditionCreateManyHealthConditionInputEnvelope
    set?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    disconnect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    delete?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    connect?: UserHealthConditionWhereUniqueInput | UserHealthConditionWhereUniqueInput[]
    update?: UserHealthConditionUpdateWithWhereUniqueWithoutHealthConditionInput | UserHealthConditionUpdateWithWhereUniqueWithoutHealthConditionInput[]
    updateMany?: UserHealthConditionUpdateManyWithWhereWithoutHealthConditionInput | UserHealthConditionUpdateManyWithWhereWithoutHealthConditionInput[]
    deleteMany?: UserHealthConditionScalarWhereInput | UserHealthConditionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHealthConditionsInput = {
    create?: XOR<UserCreateWithoutHealthConditionsInput, UserUncheckedCreateWithoutHealthConditionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHealthConditionsInput
    connect?: UserWhereUniqueInput
  }

  export type HealthConditionCreateNestedOneWithoutUsersInput = {
    create?: XOR<HealthConditionCreateWithoutUsersInput, HealthConditionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: HealthConditionCreateOrConnectWithoutUsersInput
    connect?: HealthConditionWhereUniqueInput
  }

  export type EnumSeverityFieldUpdateOperationsInput = {
    set?: $Enums.Severity
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutHealthConditionsNestedInput = {
    create?: XOR<UserCreateWithoutHealthConditionsInput, UserUncheckedCreateWithoutHealthConditionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHealthConditionsInput
    upsert?: UserUpsertWithoutHealthConditionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHealthConditionsInput, UserUpdateWithoutHealthConditionsInput>, UserUncheckedUpdateWithoutHealthConditionsInput>
  }

  export type HealthConditionUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<HealthConditionCreateWithoutUsersInput, HealthConditionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: HealthConditionCreateOrConnectWithoutUsersInput
    upsert?: HealthConditionUpsertWithoutUsersInput
    connect?: HealthConditionWhereUniqueInput
    update?: XOR<XOR<HealthConditionUpdateToOneWithWhereWithoutUsersInput, HealthConditionUpdateWithoutUsersInput>, HealthConditionUncheckedUpdateWithoutUsersInput>
  }

  export type UserAllergyCreateNestedManyWithoutAllergenInput = {
    create?: XOR<UserAllergyCreateWithoutAllergenInput, UserAllergyUncheckedCreateWithoutAllergenInput> | UserAllergyCreateWithoutAllergenInput[] | UserAllergyUncheckedCreateWithoutAllergenInput[]
    connectOrCreate?: UserAllergyCreateOrConnectWithoutAllergenInput | UserAllergyCreateOrConnectWithoutAllergenInput[]
    createMany?: UserAllergyCreateManyAllergenInputEnvelope
    connect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
  }

  export type UserAllergyUncheckedCreateNestedManyWithoutAllergenInput = {
    create?: XOR<UserAllergyCreateWithoutAllergenInput, UserAllergyUncheckedCreateWithoutAllergenInput> | UserAllergyCreateWithoutAllergenInput[] | UserAllergyUncheckedCreateWithoutAllergenInput[]
    connectOrCreate?: UserAllergyCreateOrConnectWithoutAllergenInput | UserAllergyCreateOrConnectWithoutAllergenInput[]
    createMany?: UserAllergyCreateManyAllergenInputEnvelope
    connect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
  }

  export type EnumAllergenCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AllergenCategory
  }

  export type UserAllergyUpdateManyWithoutAllergenNestedInput = {
    create?: XOR<UserAllergyCreateWithoutAllergenInput, UserAllergyUncheckedCreateWithoutAllergenInput> | UserAllergyCreateWithoutAllergenInput[] | UserAllergyUncheckedCreateWithoutAllergenInput[]
    connectOrCreate?: UserAllergyCreateOrConnectWithoutAllergenInput | UserAllergyCreateOrConnectWithoutAllergenInput[]
    upsert?: UserAllergyUpsertWithWhereUniqueWithoutAllergenInput | UserAllergyUpsertWithWhereUniqueWithoutAllergenInput[]
    createMany?: UserAllergyCreateManyAllergenInputEnvelope
    set?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    disconnect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    delete?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    connect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    update?: UserAllergyUpdateWithWhereUniqueWithoutAllergenInput | UserAllergyUpdateWithWhereUniqueWithoutAllergenInput[]
    updateMany?: UserAllergyUpdateManyWithWhereWithoutAllergenInput | UserAllergyUpdateManyWithWhereWithoutAllergenInput[]
    deleteMany?: UserAllergyScalarWhereInput | UserAllergyScalarWhereInput[]
  }

  export type UserAllergyUncheckedUpdateManyWithoutAllergenNestedInput = {
    create?: XOR<UserAllergyCreateWithoutAllergenInput, UserAllergyUncheckedCreateWithoutAllergenInput> | UserAllergyCreateWithoutAllergenInput[] | UserAllergyUncheckedCreateWithoutAllergenInput[]
    connectOrCreate?: UserAllergyCreateOrConnectWithoutAllergenInput | UserAllergyCreateOrConnectWithoutAllergenInput[]
    upsert?: UserAllergyUpsertWithWhereUniqueWithoutAllergenInput | UserAllergyUpsertWithWhereUniqueWithoutAllergenInput[]
    createMany?: UserAllergyCreateManyAllergenInputEnvelope
    set?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    disconnect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    delete?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    connect?: UserAllergyWhereUniqueInput | UserAllergyWhereUniqueInput[]
    update?: UserAllergyUpdateWithWhereUniqueWithoutAllergenInput | UserAllergyUpdateWithWhereUniqueWithoutAllergenInput[]
    updateMany?: UserAllergyUpdateManyWithWhereWithoutAllergenInput | UserAllergyUpdateManyWithWhereWithoutAllergenInput[]
    deleteMany?: UserAllergyScalarWhereInput | UserAllergyScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAllergiesInput = {
    create?: XOR<UserCreateWithoutAllergiesInput, UserUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAllergiesInput
    connect?: UserWhereUniqueInput
  }

  export type AllergenCreateNestedOneWithoutUsersInput = {
    create?: XOR<AllergenCreateWithoutUsersInput, AllergenUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AllergenCreateOrConnectWithoutUsersInput
    connect?: AllergenWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAllergiesNestedInput = {
    create?: XOR<UserCreateWithoutAllergiesInput, UserUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAllergiesInput
    upsert?: UserUpsertWithoutAllergiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAllergiesInput, UserUpdateWithoutAllergiesInput>, UserUncheckedUpdateWithoutAllergiesInput>
  }

  export type AllergenUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<AllergenCreateWithoutUsersInput, AllergenUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AllergenCreateOrConnectWithoutUsersInput
    upsert?: AllergenUpsertWithoutUsersInput
    connect?: AllergenWhereUniqueInput
    update?: XOR<XOR<AllergenUpdateToOneWithWhereWithoutUsersInput, AllergenUpdateWithoutUsersInput>, AllergenUncheckedUpdateWithoutUsersInput>
  }

  export type UserApplianceCreateNestedManyWithoutApplianceInput = {
    create?: XOR<UserApplianceCreateWithoutApplianceInput, UserApplianceUncheckedCreateWithoutApplianceInput> | UserApplianceCreateWithoutApplianceInput[] | UserApplianceUncheckedCreateWithoutApplianceInput[]
    connectOrCreate?: UserApplianceCreateOrConnectWithoutApplianceInput | UserApplianceCreateOrConnectWithoutApplianceInput[]
    createMany?: UserApplianceCreateManyApplianceInputEnvelope
    connect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
  }

  export type UserApplianceUncheckedCreateNestedManyWithoutApplianceInput = {
    create?: XOR<UserApplianceCreateWithoutApplianceInput, UserApplianceUncheckedCreateWithoutApplianceInput> | UserApplianceCreateWithoutApplianceInput[] | UserApplianceUncheckedCreateWithoutApplianceInput[]
    connectOrCreate?: UserApplianceCreateOrConnectWithoutApplianceInput | UserApplianceCreateOrConnectWithoutApplianceInput[]
    createMany?: UserApplianceCreateManyApplianceInputEnvelope
    connect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
  }

  export type UserApplianceUpdateManyWithoutApplianceNestedInput = {
    create?: XOR<UserApplianceCreateWithoutApplianceInput, UserApplianceUncheckedCreateWithoutApplianceInput> | UserApplianceCreateWithoutApplianceInput[] | UserApplianceUncheckedCreateWithoutApplianceInput[]
    connectOrCreate?: UserApplianceCreateOrConnectWithoutApplianceInput | UserApplianceCreateOrConnectWithoutApplianceInput[]
    upsert?: UserApplianceUpsertWithWhereUniqueWithoutApplianceInput | UserApplianceUpsertWithWhereUniqueWithoutApplianceInput[]
    createMany?: UserApplianceCreateManyApplianceInputEnvelope
    set?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    disconnect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    delete?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    connect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    update?: UserApplianceUpdateWithWhereUniqueWithoutApplianceInput | UserApplianceUpdateWithWhereUniqueWithoutApplianceInput[]
    updateMany?: UserApplianceUpdateManyWithWhereWithoutApplianceInput | UserApplianceUpdateManyWithWhereWithoutApplianceInput[]
    deleteMany?: UserApplianceScalarWhereInput | UserApplianceScalarWhereInput[]
  }

  export type UserApplianceUncheckedUpdateManyWithoutApplianceNestedInput = {
    create?: XOR<UserApplianceCreateWithoutApplianceInput, UserApplianceUncheckedCreateWithoutApplianceInput> | UserApplianceCreateWithoutApplianceInput[] | UserApplianceUncheckedCreateWithoutApplianceInput[]
    connectOrCreate?: UserApplianceCreateOrConnectWithoutApplianceInput | UserApplianceCreateOrConnectWithoutApplianceInput[]
    upsert?: UserApplianceUpsertWithWhereUniqueWithoutApplianceInput | UserApplianceUpsertWithWhereUniqueWithoutApplianceInput[]
    createMany?: UserApplianceCreateManyApplianceInputEnvelope
    set?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    disconnect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    delete?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    connect?: UserApplianceWhereUniqueInput | UserApplianceWhereUniqueInput[]
    update?: UserApplianceUpdateWithWhereUniqueWithoutApplianceInput | UserApplianceUpdateWithWhereUniqueWithoutApplianceInput[]
    updateMany?: UserApplianceUpdateManyWithWhereWithoutApplianceInput | UserApplianceUpdateManyWithWhereWithoutApplianceInput[]
    deleteMany?: UserApplianceScalarWhereInput | UserApplianceScalarWhereInput[]
  }

  export type UserPreferencesCreateNestedOneWithoutAppliancesInput = {
    create?: XOR<UserPreferencesCreateWithoutAppliancesInput, UserPreferencesUncheckedCreateWithoutAppliancesInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutAppliancesInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type ApplianceCreateNestedOneWithoutUsersInput = {
    create?: XOR<ApplianceCreateWithoutUsersInput, ApplianceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ApplianceCreateOrConnectWithoutUsersInput
    connect?: ApplianceWhereUniqueInput
  }

  export type UserPreferencesUpdateOneRequiredWithoutAppliancesNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutAppliancesInput, UserPreferencesUncheckedCreateWithoutAppliancesInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutAppliancesInput
    upsert?: UserPreferencesUpsertWithoutAppliancesInput
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutAppliancesInput, UserPreferencesUpdateWithoutAppliancesInput>, UserPreferencesUncheckedUpdateWithoutAppliancesInput>
  }

  export type ApplianceUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ApplianceCreateWithoutUsersInput, ApplianceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ApplianceCreateOrConnectWithoutUsersInput
    upsert?: ApplianceUpsertWithoutUsersInput
    connect?: ApplianceWhereUniqueInput
    update?: XOR<XOR<ApplianceUpdateToOneWithWhereWithoutUsersInput, ApplianceUpdateWithoutUsersInput>, ApplianceUncheckedUpdateWithoutUsersInput>
  }

  export type UserPreferencesCreateNestedOneWithoutBehaviorProfileInput = {
    create?: XOR<UserPreferencesCreateWithoutBehaviorProfileInput, UserPreferencesUncheckedCreateWithoutBehaviorProfileInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutBehaviorProfileInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type UserPreferencesUpdateOneRequiredWithoutBehaviorProfileNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutBehaviorProfileInput, UserPreferencesUncheckedCreateWithoutBehaviorProfileInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutBehaviorProfileInput
    upsert?: UserPreferencesUpsertWithoutBehaviorProfileInput
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutBehaviorProfileInput, UserPreferencesUpdateWithoutBehaviorProfileInput>, UserPreferencesUncheckedUpdateWithoutBehaviorProfileInput>
  }

  export type RecipeSpiceBlendCreateNestedManyWithoutSpiceBlendInput = {
    create?: XOR<RecipeSpiceBlendCreateWithoutSpiceBlendInput, RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput> | RecipeSpiceBlendCreateWithoutSpiceBlendInput[] | RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput[]
    connectOrCreate?: RecipeSpiceBlendCreateOrConnectWithoutSpiceBlendInput | RecipeSpiceBlendCreateOrConnectWithoutSpiceBlendInput[]
    createMany?: RecipeSpiceBlendCreateManySpiceBlendInputEnvelope
    connect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
  }

  export type RecipeSpiceBlendUncheckedCreateNestedManyWithoutSpiceBlendInput = {
    create?: XOR<RecipeSpiceBlendCreateWithoutSpiceBlendInput, RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput> | RecipeSpiceBlendCreateWithoutSpiceBlendInput[] | RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput[]
    connectOrCreate?: RecipeSpiceBlendCreateOrConnectWithoutSpiceBlendInput | RecipeSpiceBlendCreateOrConnectWithoutSpiceBlendInput[]
    createMany?: RecipeSpiceBlendCreateManySpiceBlendInputEnvelope
    connect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RecipeSpiceBlendUpdateManyWithoutSpiceBlendNestedInput = {
    create?: XOR<RecipeSpiceBlendCreateWithoutSpiceBlendInput, RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput> | RecipeSpiceBlendCreateWithoutSpiceBlendInput[] | RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput[]
    connectOrCreate?: RecipeSpiceBlendCreateOrConnectWithoutSpiceBlendInput | RecipeSpiceBlendCreateOrConnectWithoutSpiceBlendInput[]
    upsert?: RecipeSpiceBlendUpsertWithWhereUniqueWithoutSpiceBlendInput | RecipeSpiceBlendUpsertWithWhereUniqueWithoutSpiceBlendInput[]
    createMany?: RecipeSpiceBlendCreateManySpiceBlendInputEnvelope
    set?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    disconnect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    delete?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    connect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    update?: RecipeSpiceBlendUpdateWithWhereUniqueWithoutSpiceBlendInput | RecipeSpiceBlendUpdateWithWhereUniqueWithoutSpiceBlendInput[]
    updateMany?: RecipeSpiceBlendUpdateManyWithWhereWithoutSpiceBlendInput | RecipeSpiceBlendUpdateManyWithWhereWithoutSpiceBlendInput[]
    deleteMany?: RecipeSpiceBlendScalarWhereInput | RecipeSpiceBlendScalarWhereInput[]
  }

  export type RecipeSpiceBlendUncheckedUpdateManyWithoutSpiceBlendNestedInput = {
    create?: XOR<RecipeSpiceBlendCreateWithoutSpiceBlendInput, RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput> | RecipeSpiceBlendCreateWithoutSpiceBlendInput[] | RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput[]
    connectOrCreate?: RecipeSpiceBlendCreateOrConnectWithoutSpiceBlendInput | RecipeSpiceBlendCreateOrConnectWithoutSpiceBlendInput[]
    upsert?: RecipeSpiceBlendUpsertWithWhereUniqueWithoutSpiceBlendInput | RecipeSpiceBlendUpsertWithWhereUniqueWithoutSpiceBlendInput[]
    createMany?: RecipeSpiceBlendCreateManySpiceBlendInputEnvelope
    set?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    disconnect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    delete?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    connect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    update?: RecipeSpiceBlendUpdateWithWhereUniqueWithoutSpiceBlendInput | RecipeSpiceBlendUpdateWithWhereUniqueWithoutSpiceBlendInput[]
    updateMany?: RecipeSpiceBlendUpdateManyWithWhereWithoutSpiceBlendInput | RecipeSpiceBlendUpdateManyWithWhereWithoutSpiceBlendInput[]
    deleteMany?: RecipeSpiceBlendScalarWhereInput | RecipeSpiceBlendScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutSpiceBlendsInput = {
    create?: XOR<RecipeCreateWithoutSpiceBlendsInput, RecipeUncheckedCreateWithoutSpiceBlendsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutSpiceBlendsInput
    connect?: RecipeWhereUniqueInput
  }

  export type SpiceBlendCreateNestedOneWithoutRecipesInput = {
    create?: XOR<SpiceBlendCreateWithoutRecipesInput, SpiceBlendUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: SpiceBlendCreateOrConnectWithoutRecipesInput
    connect?: SpiceBlendWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutSpiceBlendsNestedInput = {
    create?: XOR<RecipeCreateWithoutSpiceBlendsInput, RecipeUncheckedCreateWithoutSpiceBlendsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutSpiceBlendsInput
    upsert?: RecipeUpsertWithoutSpiceBlendsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutSpiceBlendsInput, RecipeUpdateWithoutSpiceBlendsInput>, RecipeUncheckedUpdateWithoutSpiceBlendsInput>
  }

  export type SpiceBlendUpdateOneRequiredWithoutRecipesNestedInput = {
    create?: XOR<SpiceBlendCreateWithoutRecipesInput, SpiceBlendUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: SpiceBlendCreateOrConnectWithoutRecipesInput
    upsert?: SpiceBlendUpsertWithoutRecipesInput
    connect?: SpiceBlendWhereUniqueInput
    update?: XOR<XOR<SpiceBlendUpdateToOneWithWhereWithoutRecipesInput, SpiceBlendUpdateWithoutRecipesInput>, SpiceBlendUncheckedUpdateWithoutRecipesInput>
  }

  export type RecipeIngredientCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type RecipeInstructionCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput> | RecipeInstructionCreateWithoutRecipeInput[] | RecipeInstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInstructionCreateOrConnectWithoutRecipeInput | RecipeInstructionCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeInstructionCreateManyRecipeInputEnvelope
    connect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
  }

  export type RecipeMedicalTagCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeMedicalTagCreateWithoutRecipeInput, RecipeMedicalTagUncheckedCreateWithoutRecipeInput> | RecipeMedicalTagCreateWithoutRecipeInput[] | RecipeMedicalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeMedicalTagCreateOrConnectWithoutRecipeInput | RecipeMedicalTagCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeMedicalTagCreateManyRecipeInputEnvelope
    connect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
  }

  export type RecipeDietaryTagCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeDietaryTagCreateWithoutRecipeInput, RecipeDietaryTagUncheckedCreateWithoutRecipeInput> | RecipeDietaryTagCreateWithoutRecipeInput[] | RecipeDietaryTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeDietaryTagCreateOrConnectWithoutRecipeInput | RecipeDietaryTagCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeDietaryTagCreateManyRecipeInputEnvelope
    connect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
  }

  export type RecipePracticalTagCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipePracticalTagCreateWithoutRecipeInput, RecipePracticalTagUncheckedCreateWithoutRecipeInput> | RecipePracticalTagCreateWithoutRecipeInput[] | RecipePracticalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipePracticalTagCreateOrConnectWithoutRecipeInput | RecipePracticalTagCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipePracticalTagCreateManyRecipeInputEnvelope
    connect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
  }

  export type RecipeNutritionalTagCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeNutritionalTagCreateWithoutRecipeInput, RecipeNutritionalTagUncheckedCreateWithoutRecipeInput> | RecipeNutritionalTagCreateWithoutRecipeInput[] | RecipeNutritionalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeNutritionalTagCreateOrConnectWithoutRecipeInput | RecipeNutritionalTagCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeNutritionalTagCreateManyRecipeInputEnvelope
    connect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
  }

  export type RecipeSpiceBlendCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeSpiceBlendCreateWithoutRecipeInput, RecipeSpiceBlendUncheckedCreateWithoutRecipeInput> | RecipeSpiceBlendCreateWithoutRecipeInput[] | RecipeSpiceBlendUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeSpiceBlendCreateOrConnectWithoutRecipeInput | RecipeSpiceBlendCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeSpiceBlendCreateManyRecipeInputEnvelope
    connect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
  }

  export type NutritionalInfoCreateNestedOneWithoutRecipeInput = {
    create?: XOR<NutritionalInfoCreateWithoutRecipeInput, NutritionalInfoUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: NutritionalInfoCreateOrConnectWithoutRecipeInput
    connect?: NutritionalInfoWhereUniqueInput
  }

  export type UserFavoriteRecipeCreateNestedManyWithoutRecipeInput = {
    create?: XOR<UserFavoriteRecipeCreateWithoutRecipeInput, UserFavoriteRecipeUncheckedCreateWithoutRecipeInput> | UserFavoriteRecipeCreateWithoutRecipeInput[] | UserFavoriteRecipeUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: UserFavoriteRecipeCreateOrConnectWithoutRecipeInput | UserFavoriteRecipeCreateOrConnectWithoutRecipeInput[]
    createMany?: UserFavoriteRecipeCreateManyRecipeInputEnvelope
    connect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
  }

  export type MealPlanItemCreateNestedManyWithoutRecipeInput = {
    create?: XOR<MealPlanItemCreateWithoutRecipeInput, MealPlanItemUncheckedCreateWithoutRecipeInput> | MealPlanItemCreateWithoutRecipeInput[] | MealPlanItemUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: MealPlanItemCreateOrConnectWithoutRecipeInput | MealPlanItemCreateOrConnectWithoutRecipeInput[]
    createMany?: MealPlanItemCreateManyRecipeInputEnvelope
    connect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutRecipeInput = {
    create?: XOR<FeedbackCreateWithoutRecipeInput, FeedbackUncheckedCreateWithoutRecipeInput> | FeedbackCreateWithoutRecipeInput[] | FeedbackUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutRecipeInput | FeedbackCreateOrConnectWithoutRecipeInput[]
    createMany?: FeedbackCreateManyRecipeInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput> | RecipeInstructionCreateWithoutRecipeInput[] | RecipeInstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInstructionCreateOrConnectWithoutRecipeInput | RecipeInstructionCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeInstructionCreateManyRecipeInputEnvelope
    connect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
  }

  export type RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeMedicalTagCreateWithoutRecipeInput, RecipeMedicalTagUncheckedCreateWithoutRecipeInput> | RecipeMedicalTagCreateWithoutRecipeInput[] | RecipeMedicalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeMedicalTagCreateOrConnectWithoutRecipeInput | RecipeMedicalTagCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeMedicalTagCreateManyRecipeInputEnvelope
    connect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
  }

  export type RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeDietaryTagCreateWithoutRecipeInput, RecipeDietaryTagUncheckedCreateWithoutRecipeInput> | RecipeDietaryTagCreateWithoutRecipeInput[] | RecipeDietaryTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeDietaryTagCreateOrConnectWithoutRecipeInput | RecipeDietaryTagCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeDietaryTagCreateManyRecipeInputEnvelope
    connect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
  }

  export type RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipePracticalTagCreateWithoutRecipeInput, RecipePracticalTagUncheckedCreateWithoutRecipeInput> | RecipePracticalTagCreateWithoutRecipeInput[] | RecipePracticalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipePracticalTagCreateOrConnectWithoutRecipeInput | RecipePracticalTagCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipePracticalTagCreateManyRecipeInputEnvelope
    connect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
  }

  export type RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeNutritionalTagCreateWithoutRecipeInput, RecipeNutritionalTagUncheckedCreateWithoutRecipeInput> | RecipeNutritionalTagCreateWithoutRecipeInput[] | RecipeNutritionalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeNutritionalTagCreateOrConnectWithoutRecipeInput | RecipeNutritionalTagCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeNutritionalTagCreateManyRecipeInputEnvelope
    connect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
  }

  export type RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeSpiceBlendCreateWithoutRecipeInput, RecipeSpiceBlendUncheckedCreateWithoutRecipeInput> | RecipeSpiceBlendCreateWithoutRecipeInput[] | RecipeSpiceBlendUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeSpiceBlendCreateOrConnectWithoutRecipeInput | RecipeSpiceBlendCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeSpiceBlendCreateManyRecipeInputEnvelope
    connect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
  }

  export type NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput = {
    create?: XOR<NutritionalInfoCreateWithoutRecipeInput, NutritionalInfoUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: NutritionalInfoCreateOrConnectWithoutRecipeInput
    connect?: NutritionalInfoWhereUniqueInput
  }

  export type UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<UserFavoriteRecipeCreateWithoutRecipeInput, UserFavoriteRecipeUncheckedCreateWithoutRecipeInput> | UserFavoriteRecipeCreateWithoutRecipeInput[] | UserFavoriteRecipeUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: UserFavoriteRecipeCreateOrConnectWithoutRecipeInput | UserFavoriteRecipeCreateOrConnectWithoutRecipeInput[]
    createMany?: UserFavoriteRecipeCreateManyRecipeInputEnvelope
    connect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
  }

  export type MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<MealPlanItemCreateWithoutRecipeInput, MealPlanItemUncheckedCreateWithoutRecipeInput> | MealPlanItemCreateWithoutRecipeInput[] | MealPlanItemUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: MealPlanItemCreateOrConnectWithoutRecipeInput | MealPlanItemCreateOrConnectWithoutRecipeInput[]
    createMany?: MealPlanItemCreateManyRecipeInputEnvelope
    connect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<FeedbackCreateWithoutRecipeInput, FeedbackUncheckedCreateWithoutRecipeInput> | FeedbackCreateWithoutRecipeInput[] | FeedbackUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutRecipeInput | FeedbackCreateOrConnectWithoutRecipeInput[]
    createMany?: FeedbackCreateManyRecipeInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type RecipeIngredientUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type RecipeInstructionUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput> | RecipeInstructionCreateWithoutRecipeInput[] | RecipeInstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInstructionCreateOrConnectWithoutRecipeInput | RecipeInstructionCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput | RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeInstructionCreateManyRecipeInputEnvelope
    set?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    disconnect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    delete?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    connect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    update?: RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput | RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeInstructionUpdateManyWithWhereWithoutRecipeInput | RecipeInstructionUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeInstructionScalarWhereInput | RecipeInstructionScalarWhereInput[]
  }

  export type RecipeMedicalTagUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeMedicalTagCreateWithoutRecipeInput, RecipeMedicalTagUncheckedCreateWithoutRecipeInput> | RecipeMedicalTagCreateWithoutRecipeInput[] | RecipeMedicalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeMedicalTagCreateOrConnectWithoutRecipeInput | RecipeMedicalTagCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeMedicalTagUpsertWithWhereUniqueWithoutRecipeInput | RecipeMedicalTagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeMedicalTagCreateManyRecipeInputEnvelope
    set?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    disconnect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    delete?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    connect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    update?: RecipeMedicalTagUpdateWithWhereUniqueWithoutRecipeInput | RecipeMedicalTagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeMedicalTagUpdateManyWithWhereWithoutRecipeInput | RecipeMedicalTagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeMedicalTagScalarWhereInput | RecipeMedicalTagScalarWhereInput[]
  }

  export type RecipeDietaryTagUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeDietaryTagCreateWithoutRecipeInput, RecipeDietaryTagUncheckedCreateWithoutRecipeInput> | RecipeDietaryTagCreateWithoutRecipeInput[] | RecipeDietaryTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeDietaryTagCreateOrConnectWithoutRecipeInput | RecipeDietaryTagCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeDietaryTagUpsertWithWhereUniqueWithoutRecipeInput | RecipeDietaryTagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeDietaryTagCreateManyRecipeInputEnvelope
    set?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    disconnect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    delete?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    connect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    update?: RecipeDietaryTagUpdateWithWhereUniqueWithoutRecipeInput | RecipeDietaryTagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeDietaryTagUpdateManyWithWhereWithoutRecipeInput | RecipeDietaryTagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeDietaryTagScalarWhereInput | RecipeDietaryTagScalarWhereInput[]
  }

  export type RecipePracticalTagUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipePracticalTagCreateWithoutRecipeInput, RecipePracticalTagUncheckedCreateWithoutRecipeInput> | RecipePracticalTagCreateWithoutRecipeInput[] | RecipePracticalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipePracticalTagCreateOrConnectWithoutRecipeInput | RecipePracticalTagCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipePracticalTagUpsertWithWhereUniqueWithoutRecipeInput | RecipePracticalTagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipePracticalTagCreateManyRecipeInputEnvelope
    set?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    disconnect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    delete?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    connect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    update?: RecipePracticalTagUpdateWithWhereUniqueWithoutRecipeInput | RecipePracticalTagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipePracticalTagUpdateManyWithWhereWithoutRecipeInput | RecipePracticalTagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipePracticalTagScalarWhereInput | RecipePracticalTagScalarWhereInput[]
  }

  export type RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeNutritionalTagCreateWithoutRecipeInput, RecipeNutritionalTagUncheckedCreateWithoutRecipeInput> | RecipeNutritionalTagCreateWithoutRecipeInput[] | RecipeNutritionalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeNutritionalTagCreateOrConnectWithoutRecipeInput | RecipeNutritionalTagCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeNutritionalTagUpsertWithWhereUniqueWithoutRecipeInput | RecipeNutritionalTagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeNutritionalTagCreateManyRecipeInputEnvelope
    set?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    disconnect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    delete?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    connect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    update?: RecipeNutritionalTagUpdateWithWhereUniqueWithoutRecipeInput | RecipeNutritionalTagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeNutritionalTagUpdateManyWithWhereWithoutRecipeInput | RecipeNutritionalTagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeNutritionalTagScalarWhereInput | RecipeNutritionalTagScalarWhereInput[]
  }

  export type RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeSpiceBlendCreateWithoutRecipeInput, RecipeSpiceBlendUncheckedCreateWithoutRecipeInput> | RecipeSpiceBlendCreateWithoutRecipeInput[] | RecipeSpiceBlendUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeSpiceBlendCreateOrConnectWithoutRecipeInput | RecipeSpiceBlendCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeSpiceBlendUpsertWithWhereUniqueWithoutRecipeInput | RecipeSpiceBlendUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeSpiceBlendCreateManyRecipeInputEnvelope
    set?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    disconnect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    delete?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    connect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    update?: RecipeSpiceBlendUpdateWithWhereUniqueWithoutRecipeInput | RecipeSpiceBlendUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeSpiceBlendUpdateManyWithWhereWithoutRecipeInput | RecipeSpiceBlendUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeSpiceBlendScalarWhereInput | RecipeSpiceBlendScalarWhereInput[]
  }

  export type NutritionalInfoUpdateOneWithoutRecipeNestedInput = {
    create?: XOR<NutritionalInfoCreateWithoutRecipeInput, NutritionalInfoUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: NutritionalInfoCreateOrConnectWithoutRecipeInput
    upsert?: NutritionalInfoUpsertWithoutRecipeInput
    disconnect?: NutritionalInfoWhereInput | boolean
    delete?: NutritionalInfoWhereInput | boolean
    connect?: NutritionalInfoWhereUniqueInput
    update?: XOR<XOR<NutritionalInfoUpdateToOneWithWhereWithoutRecipeInput, NutritionalInfoUpdateWithoutRecipeInput>, NutritionalInfoUncheckedUpdateWithoutRecipeInput>
  }

  export type UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<UserFavoriteRecipeCreateWithoutRecipeInput, UserFavoriteRecipeUncheckedCreateWithoutRecipeInput> | UserFavoriteRecipeCreateWithoutRecipeInput[] | UserFavoriteRecipeUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: UserFavoriteRecipeCreateOrConnectWithoutRecipeInput | UserFavoriteRecipeCreateOrConnectWithoutRecipeInput[]
    upsert?: UserFavoriteRecipeUpsertWithWhereUniqueWithoutRecipeInput | UserFavoriteRecipeUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: UserFavoriteRecipeCreateManyRecipeInputEnvelope
    set?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    disconnect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    delete?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    connect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    update?: UserFavoriteRecipeUpdateWithWhereUniqueWithoutRecipeInput | UserFavoriteRecipeUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: UserFavoriteRecipeUpdateManyWithWhereWithoutRecipeInput | UserFavoriteRecipeUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: UserFavoriteRecipeScalarWhereInput | UserFavoriteRecipeScalarWhereInput[]
  }

  export type MealPlanItemUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<MealPlanItemCreateWithoutRecipeInput, MealPlanItemUncheckedCreateWithoutRecipeInput> | MealPlanItemCreateWithoutRecipeInput[] | MealPlanItemUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: MealPlanItemCreateOrConnectWithoutRecipeInput | MealPlanItemCreateOrConnectWithoutRecipeInput[]
    upsert?: MealPlanItemUpsertWithWhereUniqueWithoutRecipeInput | MealPlanItemUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: MealPlanItemCreateManyRecipeInputEnvelope
    set?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    disconnect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    delete?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    connect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    update?: MealPlanItemUpdateWithWhereUniqueWithoutRecipeInput | MealPlanItemUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: MealPlanItemUpdateManyWithWhereWithoutRecipeInput | MealPlanItemUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: MealPlanItemScalarWhereInput | MealPlanItemScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<FeedbackCreateWithoutRecipeInput, FeedbackUncheckedCreateWithoutRecipeInput> | FeedbackCreateWithoutRecipeInput[] | FeedbackUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutRecipeInput | FeedbackCreateOrConnectWithoutRecipeInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutRecipeInput | FeedbackUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: FeedbackCreateManyRecipeInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutRecipeInput | FeedbackUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutRecipeInput | FeedbackUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput> | RecipeInstructionCreateWithoutRecipeInput[] | RecipeInstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeInstructionCreateOrConnectWithoutRecipeInput | RecipeInstructionCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput | RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeInstructionCreateManyRecipeInputEnvelope
    set?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    disconnect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    delete?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    connect?: RecipeInstructionWhereUniqueInput | RecipeInstructionWhereUniqueInput[]
    update?: RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput | RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeInstructionUpdateManyWithWhereWithoutRecipeInput | RecipeInstructionUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeInstructionScalarWhereInput | RecipeInstructionScalarWhereInput[]
  }

  export type RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeMedicalTagCreateWithoutRecipeInput, RecipeMedicalTagUncheckedCreateWithoutRecipeInput> | RecipeMedicalTagCreateWithoutRecipeInput[] | RecipeMedicalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeMedicalTagCreateOrConnectWithoutRecipeInput | RecipeMedicalTagCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeMedicalTagUpsertWithWhereUniqueWithoutRecipeInput | RecipeMedicalTagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeMedicalTagCreateManyRecipeInputEnvelope
    set?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    disconnect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    delete?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    connect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    update?: RecipeMedicalTagUpdateWithWhereUniqueWithoutRecipeInput | RecipeMedicalTagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeMedicalTagUpdateManyWithWhereWithoutRecipeInput | RecipeMedicalTagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeMedicalTagScalarWhereInput | RecipeMedicalTagScalarWhereInput[]
  }

  export type RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeDietaryTagCreateWithoutRecipeInput, RecipeDietaryTagUncheckedCreateWithoutRecipeInput> | RecipeDietaryTagCreateWithoutRecipeInput[] | RecipeDietaryTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeDietaryTagCreateOrConnectWithoutRecipeInput | RecipeDietaryTagCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeDietaryTagUpsertWithWhereUniqueWithoutRecipeInput | RecipeDietaryTagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeDietaryTagCreateManyRecipeInputEnvelope
    set?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    disconnect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    delete?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    connect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    update?: RecipeDietaryTagUpdateWithWhereUniqueWithoutRecipeInput | RecipeDietaryTagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeDietaryTagUpdateManyWithWhereWithoutRecipeInput | RecipeDietaryTagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeDietaryTagScalarWhereInput | RecipeDietaryTagScalarWhereInput[]
  }

  export type RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipePracticalTagCreateWithoutRecipeInput, RecipePracticalTagUncheckedCreateWithoutRecipeInput> | RecipePracticalTagCreateWithoutRecipeInput[] | RecipePracticalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipePracticalTagCreateOrConnectWithoutRecipeInput | RecipePracticalTagCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipePracticalTagUpsertWithWhereUniqueWithoutRecipeInput | RecipePracticalTagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipePracticalTagCreateManyRecipeInputEnvelope
    set?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    disconnect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    delete?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    connect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    update?: RecipePracticalTagUpdateWithWhereUniqueWithoutRecipeInput | RecipePracticalTagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipePracticalTagUpdateManyWithWhereWithoutRecipeInput | RecipePracticalTagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipePracticalTagScalarWhereInput | RecipePracticalTagScalarWhereInput[]
  }

  export type RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeNutritionalTagCreateWithoutRecipeInput, RecipeNutritionalTagUncheckedCreateWithoutRecipeInput> | RecipeNutritionalTagCreateWithoutRecipeInput[] | RecipeNutritionalTagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeNutritionalTagCreateOrConnectWithoutRecipeInput | RecipeNutritionalTagCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeNutritionalTagUpsertWithWhereUniqueWithoutRecipeInput | RecipeNutritionalTagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeNutritionalTagCreateManyRecipeInputEnvelope
    set?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    disconnect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    delete?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    connect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    update?: RecipeNutritionalTagUpdateWithWhereUniqueWithoutRecipeInput | RecipeNutritionalTagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeNutritionalTagUpdateManyWithWhereWithoutRecipeInput | RecipeNutritionalTagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeNutritionalTagScalarWhereInput | RecipeNutritionalTagScalarWhereInput[]
  }

  export type RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeSpiceBlendCreateWithoutRecipeInput, RecipeSpiceBlendUncheckedCreateWithoutRecipeInput> | RecipeSpiceBlendCreateWithoutRecipeInput[] | RecipeSpiceBlendUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeSpiceBlendCreateOrConnectWithoutRecipeInput | RecipeSpiceBlendCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeSpiceBlendUpsertWithWhereUniqueWithoutRecipeInput | RecipeSpiceBlendUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeSpiceBlendCreateManyRecipeInputEnvelope
    set?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    disconnect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    delete?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    connect?: RecipeSpiceBlendWhereUniqueInput | RecipeSpiceBlendWhereUniqueInput[]
    update?: RecipeSpiceBlendUpdateWithWhereUniqueWithoutRecipeInput | RecipeSpiceBlendUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeSpiceBlendUpdateManyWithWhereWithoutRecipeInput | RecipeSpiceBlendUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeSpiceBlendScalarWhereInput | RecipeSpiceBlendScalarWhereInput[]
  }

  export type NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput = {
    create?: XOR<NutritionalInfoCreateWithoutRecipeInput, NutritionalInfoUncheckedCreateWithoutRecipeInput>
    connectOrCreate?: NutritionalInfoCreateOrConnectWithoutRecipeInput
    upsert?: NutritionalInfoUpsertWithoutRecipeInput
    disconnect?: NutritionalInfoWhereInput | boolean
    delete?: NutritionalInfoWhereInput | boolean
    connect?: NutritionalInfoWhereUniqueInput
    update?: XOR<XOR<NutritionalInfoUpdateToOneWithWhereWithoutRecipeInput, NutritionalInfoUpdateWithoutRecipeInput>, NutritionalInfoUncheckedUpdateWithoutRecipeInput>
  }

  export type UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<UserFavoriteRecipeCreateWithoutRecipeInput, UserFavoriteRecipeUncheckedCreateWithoutRecipeInput> | UserFavoriteRecipeCreateWithoutRecipeInput[] | UserFavoriteRecipeUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: UserFavoriteRecipeCreateOrConnectWithoutRecipeInput | UserFavoriteRecipeCreateOrConnectWithoutRecipeInput[]
    upsert?: UserFavoriteRecipeUpsertWithWhereUniqueWithoutRecipeInput | UserFavoriteRecipeUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: UserFavoriteRecipeCreateManyRecipeInputEnvelope
    set?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    disconnect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    delete?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    connect?: UserFavoriteRecipeWhereUniqueInput | UserFavoriteRecipeWhereUniqueInput[]
    update?: UserFavoriteRecipeUpdateWithWhereUniqueWithoutRecipeInput | UserFavoriteRecipeUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: UserFavoriteRecipeUpdateManyWithWhereWithoutRecipeInput | UserFavoriteRecipeUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: UserFavoriteRecipeScalarWhereInput | UserFavoriteRecipeScalarWhereInput[]
  }

  export type MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<MealPlanItemCreateWithoutRecipeInput, MealPlanItemUncheckedCreateWithoutRecipeInput> | MealPlanItemCreateWithoutRecipeInput[] | MealPlanItemUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: MealPlanItemCreateOrConnectWithoutRecipeInput | MealPlanItemCreateOrConnectWithoutRecipeInput[]
    upsert?: MealPlanItemUpsertWithWhereUniqueWithoutRecipeInput | MealPlanItemUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: MealPlanItemCreateManyRecipeInputEnvelope
    set?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    disconnect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    delete?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    connect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    update?: MealPlanItemUpdateWithWhereUniqueWithoutRecipeInput | MealPlanItemUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: MealPlanItemUpdateManyWithWhereWithoutRecipeInput | MealPlanItemUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: MealPlanItemScalarWhereInput | MealPlanItemScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<FeedbackCreateWithoutRecipeInput, FeedbackUncheckedCreateWithoutRecipeInput> | FeedbackCreateWithoutRecipeInput[] | FeedbackUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutRecipeInput | FeedbackCreateOrConnectWithoutRecipeInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutRecipeInput | FeedbackUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: FeedbackCreateManyRecipeInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutRecipeInput | FeedbackUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutRecipeInput | FeedbackUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutIngredientsInput = {
    create?: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIngredientsInput
    connect?: RecipeWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutIngredientsNestedInput = {
    create?: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIngredientsInput
    upsert?: RecipeUpsertWithoutIngredientsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutIngredientsInput, RecipeUpdateWithoutIngredientsInput>, RecipeUncheckedUpdateWithoutIngredientsInput>
  }

  export type RecipeCreateNestedOneWithoutInstructionsInput = {
    create?: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInstructionsInput
    connect?: RecipeWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutInstructionsNestedInput = {
    create?: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInstructionsInput
    upsert?: RecipeUpsertWithoutInstructionsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutInstructionsInput, RecipeUpdateWithoutInstructionsInput>, RecipeUncheckedUpdateWithoutInstructionsInput>
  }

  export type RecipeCreateNestedOneWithoutNutritionalInfoInput = {
    create?: XOR<RecipeCreateWithoutNutritionalInfoInput, RecipeUncheckedCreateWithoutNutritionalInfoInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutNutritionalInfoInput
    connect?: RecipeWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutNutritionalInfoNestedInput = {
    create?: XOR<RecipeCreateWithoutNutritionalInfoInput, RecipeUncheckedCreateWithoutNutritionalInfoInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutNutritionalInfoInput
    upsert?: RecipeUpsertWithoutNutritionalInfoInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutNutritionalInfoInput, RecipeUpdateWithoutNutritionalInfoInput>, RecipeUncheckedUpdateWithoutNutritionalInfoInput>
  }

  export type RecipeMedicalTagCreateNestedManyWithoutMedicalTagInput = {
    create?: XOR<RecipeMedicalTagCreateWithoutMedicalTagInput, RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput> | RecipeMedicalTagCreateWithoutMedicalTagInput[] | RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput[]
    connectOrCreate?: RecipeMedicalTagCreateOrConnectWithoutMedicalTagInput | RecipeMedicalTagCreateOrConnectWithoutMedicalTagInput[]
    createMany?: RecipeMedicalTagCreateManyMedicalTagInputEnvelope
    connect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
  }

  export type RecipeMedicalTagUncheckedCreateNestedManyWithoutMedicalTagInput = {
    create?: XOR<RecipeMedicalTagCreateWithoutMedicalTagInput, RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput> | RecipeMedicalTagCreateWithoutMedicalTagInput[] | RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput[]
    connectOrCreate?: RecipeMedicalTagCreateOrConnectWithoutMedicalTagInput | RecipeMedicalTagCreateOrConnectWithoutMedicalTagInput[]
    createMany?: RecipeMedicalTagCreateManyMedicalTagInputEnvelope
    connect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
  }

  export type RecipeMedicalTagUpdateManyWithoutMedicalTagNestedInput = {
    create?: XOR<RecipeMedicalTagCreateWithoutMedicalTagInput, RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput> | RecipeMedicalTagCreateWithoutMedicalTagInput[] | RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput[]
    connectOrCreate?: RecipeMedicalTagCreateOrConnectWithoutMedicalTagInput | RecipeMedicalTagCreateOrConnectWithoutMedicalTagInput[]
    upsert?: RecipeMedicalTagUpsertWithWhereUniqueWithoutMedicalTagInput | RecipeMedicalTagUpsertWithWhereUniqueWithoutMedicalTagInput[]
    createMany?: RecipeMedicalTagCreateManyMedicalTagInputEnvelope
    set?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    disconnect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    delete?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    connect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    update?: RecipeMedicalTagUpdateWithWhereUniqueWithoutMedicalTagInput | RecipeMedicalTagUpdateWithWhereUniqueWithoutMedicalTagInput[]
    updateMany?: RecipeMedicalTagUpdateManyWithWhereWithoutMedicalTagInput | RecipeMedicalTagUpdateManyWithWhereWithoutMedicalTagInput[]
    deleteMany?: RecipeMedicalTagScalarWhereInput | RecipeMedicalTagScalarWhereInput[]
  }

  export type RecipeMedicalTagUncheckedUpdateManyWithoutMedicalTagNestedInput = {
    create?: XOR<RecipeMedicalTagCreateWithoutMedicalTagInput, RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput> | RecipeMedicalTagCreateWithoutMedicalTagInput[] | RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput[]
    connectOrCreate?: RecipeMedicalTagCreateOrConnectWithoutMedicalTagInput | RecipeMedicalTagCreateOrConnectWithoutMedicalTagInput[]
    upsert?: RecipeMedicalTagUpsertWithWhereUniqueWithoutMedicalTagInput | RecipeMedicalTagUpsertWithWhereUniqueWithoutMedicalTagInput[]
    createMany?: RecipeMedicalTagCreateManyMedicalTagInputEnvelope
    set?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    disconnect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    delete?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    connect?: RecipeMedicalTagWhereUniqueInput | RecipeMedicalTagWhereUniqueInput[]
    update?: RecipeMedicalTagUpdateWithWhereUniqueWithoutMedicalTagInput | RecipeMedicalTagUpdateWithWhereUniqueWithoutMedicalTagInput[]
    updateMany?: RecipeMedicalTagUpdateManyWithWhereWithoutMedicalTagInput | RecipeMedicalTagUpdateManyWithWhereWithoutMedicalTagInput[]
    deleteMany?: RecipeMedicalTagScalarWhereInput | RecipeMedicalTagScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutMedicalTagsInput = {
    create?: XOR<RecipeCreateWithoutMedicalTagsInput, RecipeUncheckedCreateWithoutMedicalTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutMedicalTagsInput
    connect?: RecipeWhereUniqueInput
  }

  export type MedicalTagCreateNestedOneWithoutRecipesInput = {
    create?: XOR<MedicalTagCreateWithoutRecipesInput, MedicalTagUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: MedicalTagCreateOrConnectWithoutRecipesInput
    connect?: MedicalTagWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutMedicalTagsNestedInput = {
    create?: XOR<RecipeCreateWithoutMedicalTagsInput, RecipeUncheckedCreateWithoutMedicalTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutMedicalTagsInput
    upsert?: RecipeUpsertWithoutMedicalTagsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutMedicalTagsInput, RecipeUpdateWithoutMedicalTagsInput>, RecipeUncheckedUpdateWithoutMedicalTagsInput>
  }

  export type MedicalTagUpdateOneRequiredWithoutRecipesNestedInput = {
    create?: XOR<MedicalTagCreateWithoutRecipesInput, MedicalTagUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: MedicalTagCreateOrConnectWithoutRecipesInput
    upsert?: MedicalTagUpsertWithoutRecipesInput
    connect?: MedicalTagWhereUniqueInput
    update?: XOR<XOR<MedicalTagUpdateToOneWithWhereWithoutRecipesInput, MedicalTagUpdateWithoutRecipesInput>, MedicalTagUncheckedUpdateWithoutRecipesInput>
  }

  export type RecipeDietaryTagCreateNestedManyWithoutDietaryTagInput = {
    create?: XOR<RecipeDietaryTagCreateWithoutDietaryTagInput, RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput> | RecipeDietaryTagCreateWithoutDietaryTagInput[] | RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput[]
    connectOrCreate?: RecipeDietaryTagCreateOrConnectWithoutDietaryTagInput | RecipeDietaryTagCreateOrConnectWithoutDietaryTagInput[]
    createMany?: RecipeDietaryTagCreateManyDietaryTagInputEnvelope
    connect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
  }

  export type RecipeDietaryTagUncheckedCreateNestedManyWithoutDietaryTagInput = {
    create?: XOR<RecipeDietaryTagCreateWithoutDietaryTagInput, RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput> | RecipeDietaryTagCreateWithoutDietaryTagInput[] | RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput[]
    connectOrCreate?: RecipeDietaryTagCreateOrConnectWithoutDietaryTagInput | RecipeDietaryTagCreateOrConnectWithoutDietaryTagInput[]
    createMany?: RecipeDietaryTagCreateManyDietaryTagInputEnvelope
    connect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
  }

  export type EnumDietaryCategoryFieldUpdateOperationsInput = {
    set?: $Enums.DietaryCategory
  }

  export type RecipeDietaryTagUpdateManyWithoutDietaryTagNestedInput = {
    create?: XOR<RecipeDietaryTagCreateWithoutDietaryTagInput, RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput> | RecipeDietaryTagCreateWithoutDietaryTagInput[] | RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput[]
    connectOrCreate?: RecipeDietaryTagCreateOrConnectWithoutDietaryTagInput | RecipeDietaryTagCreateOrConnectWithoutDietaryTagInput[]
    upsert?: RecipeDietaryTagUpsertWithWhereUniqueWithoutDietaryTagInput | RecipeDietaryTagUpsertWithWhereUniqueWithoutDietaryTagInput[]
    createMany?: RecipeDietaryTagCreateManyDietaryTagInputEnvelope
    set?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    disconnect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    delete?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    connect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    update?: RecipeDietaryTagUpdateWithWhereUniqueWithoutDietaryTagInput | RecipeDietaryTagUpdateWithWhereUniqueWithoutDietaryTagInput[]
    updateMany?: RecipeDietaryTagUpdateManyWithWhereWithoutDietaryTagInput | RecipeDietaryTagUpdateManyWithWhereWithoutDietaryTagInput[]
    deleteMany?: RecipeDietaryTagScalarWhereInput | RecipeDietaryTagScalarWhereInput[]
  }

  export type RecipeDietaryTagUncheckedUpdateManyWithoutDietaryTagNestedInput = {
    create?: XOR<RecipeDietaryTagCreateWithoutDietaryTagInput, RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput> | RecipeDietaryTagCreateWithoutDietaryTagInput[] | RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput[]
    connectOrCreate?: RecipeDietaryTagCreateOrConnectWithoutDietaryTagInput | RecipeDietaryTagCreateOrConnectWithoutDietaryTagInput[]
    upsert?: RecipeDietaryTagUpsertWithWhereUniqueWithoutDietaryTagInput | RecipeDietaryTagUpsertWithWhereUniqueWithoutDietaryTagInput[]
    createMany?: RecipeDietaryTagCreateManyDietaryTagInputEnvelope
    set?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    disconnect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    delete?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    connect?: RecipeDietaryTagWhereUniqueInput | RecipeDietaryTagWhereUniqueInput[]
    update?: RecipeDietaryTagUpdateWithWhereUniqueWithoutDietaryTagInput | RecipeDietaryTagUpdateWithWhereUniqueWithoutDietaryTagInput[]
    updateMany?: RecipeDietaryTagUpdateManyWithWhereWithoutDietaryTagInput | RecipeDietaryTagUpdateManyWithWhereWithoutDietaryTagInput[]
    deleteMany?: RecipeDietaryTagScalarWhereInput | RecipeDietaryTagScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutDietaryTagsInput = {
    create?: XOR<RecipeCreateWithoutDietaryTagsInput, RecipeUncheckedCreateWithoutDietaryTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutDietaryTagsInput
    connect?: RecipeWhereUniqueInput
  }

  export type DietaryTagCreateNestedOneWithoutRecipesInput = {
    create?: XOR<DietaryTagCreateWithoutRecipesInput, DietaryTagUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: DietaryTagCreateOrConnectWithoutRecipesInput
    connect?: DietaryTagWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutDietaryTagsNestedInput = {
    create?: XOR<RecipeCreateWithoutDietaryTagsInput, RecipeUncheckedCreateWithoutDietaryTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutDietaryTagsInput
    upsert?: RecipeUpsertWithoutDietaryTagsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutDietaryTagsInput, RecipeUpdateWithoutDietaryTagsInput>, RecipeUncheckedUpdateWithoutDietaryTagsInput>
  }

  export type DietaryTagUpdateOneRequiredWithoutRecipesNestedInput = {
    create?: XOR<DietaryTagCreateWithoutRecipesInput, DietaryTagUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: DietaryTagCreateOrConnectWithoutRecipesInput
    upsert?: DietaryTagUpsertWithoutRecipesInput
    connect?: DietaryTagWhereUniqueInput
    update?: XOR<XOR<DietaryTagUpdateToOneWithWhereWithoutRecipesInput, DietaryTagUpdateWithoutRecipesInput>, DietaryTagUncheckedUpdateWithoutRecipesInput>
  }

  export type RecipePracticalTagCreateNestedManyWithoutPracticalTagInput = {
    create?: XOR<RecipePracticalTagCreateWithoutPracticalTagInput, RecipePracticalTagUncheckedCreateWithoutPracticalTagInput> | RecipePracticalTagCreateWithoutPracticalTagInput[] | RecipePracticalTagUncheckedCreateWithoutPracticalTagInput[]
    connectOrCreate?: RecipePracticalTagCreateOrConnectWithoutPracticalTagInput | RecipePracticalTagCreateOrConnectWithoutPracticalTagInput[]
    createMany?: RecipePracticalTagCreateManyPracticalTagInputEnvelope
    connect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
  }

  export type RecipePracticalTagUncheckedCreateNestedManyWithoutPracticalTagInput = {
    create?: XOR<RecipePracticalTagCreateWithoutPracticalTagInput, RecipePracticalTagUncheckedCreateWithoutPracticalTagInput> | RecipePracticalTagCreateWithoutPracticalTagInput[] | RecipePracticalTagUncheckedCreateWithoutPracticalTagInput[]
    connectOrCreate?: RecipePracticalTagCreateOrConnectWithoutPracticalTagInput | RecipePracticalTagCreateOrConnectWithoutPracticalTagInput[]
    createMany?: RecipePracticalTagCreateManyPracticalTagInputEnvelope
    connect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
  }

  export type EnumPracticalCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PracticalCategory
  }

  export type RecipePracticalTagUpdateManyWithoutPracticalTagNestedInput = {
    create?: XOR<RecipePracticalTagCreateWithoutPracticalTagInput, RecipePracticalTagUncheckedCreateWithoutPracticalTagInput> | RecipePracticalTagCreateWithoutPracticalTagInput[] | RecipePracticalTagUncheckedCreateWithoutPracticalTagInput[]
    connectOrCreate?: RecipePracticalTagCreateOrConnectWithoutPracticalTagInput | RecipePracticalTagCreateOrConnectWithoutPracticalTagInput[]
    upsert?: RecipePracticalTagUpsertWithWhereUniqueWithoutPracticalTagInput | RecipePracticalTagUpsertWithWhereUniqueWithoutPracticalTagInput[]
    createMany?: RecipePracticalTagCreateManyPracticalTagInputEnvelope
    set?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    disconnect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    delete?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    connect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    update?: RecipePracticalTagUpdateWithWhereUniqueWithoutPracticalTagInput | RecipePracticalTagUpdateWithWhereUniqueWithoutPracticalTagInput[]
    updateMany?: RecipePracticalTagUpdateManyWithWhereWithoutPracticalTagInput | RecipePracticalTagUpdateManyWithWhereWithoutPracticalTagInput[]
    deleteMany?: RecipePracticalTagScalarWhereInput | RecipePracticalTagScalarWhereInput[]
  }

  export type RecipePracticalTagUncheckedUpdateManyWithoutPracticalTagNestedInput = {
    create?: XOR<RecipePracticalTagCreateWithoutPracticalTagInput, RecipePracticalTagUncheckedCreateWithoutPracticalTagInput> | RecipePracticalTagCreateWithoutPracticalTagInput[] | RecipePracticalTagUncheckedCreateWithoutPracticalTagInput[]
    connectOrCreate?: RecipePracticalTagCreateOrConnectWithoutPracticalTagInput | RecipePracticalTagCreateOrConnectWithoutPracticalTagInput[]
    upsert?: RecipePracticalTagUpsertWithWhereUniqueWithoutPracticalTagInput | RecipePracticalTagUpsertWithWhereUniqueWithoutPracticalTagInput[]
    createMany?: RecipePracticalTagCreateManyPracticalTagInputEnvelope
    set?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    disconnect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    delete?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    connect?: RecipePracticalTagWhereUniqueInput | RecipePracticalTagWhereUniqueInput[]
    update?: RecipePracticalTagUpdateWithWhereUniqueWithoutPracticalTagInput | RecipePracticalTagUpdateWithWhereUniqueWithoutPracticalTagInput[]
    updateMany?: RecipePracticalTagUpdateManyWithWhereWithoutPracticalTagInput | RecipePracticalTagUpdateManyWithWhereWithoutPracticalTagInput[]
    deleteMany?: RecipePracticalTagScalarWhereInput | RecipePracticalTagScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutPracticalTagsInput = {
    create?: XOR<RecipeCreateWithoutPracticalTagsInput, RecipeUncheckedCreateWithoutPracticalTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutPracticalTagsInput
    connect?: RecipeWhereUniqueInput
  }

  export type PracticalTagCreateNestedOneWithoutRecipesInput = {
    create?: XOR<PracticalTagCreateWithoutRecipesInput, PracticalTagUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: PracticalTagCreateOrConnectWithoutRecipesInput
    connect?: PracticalTagWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutPracticalTagsNestedInput = {
    create?: XOR<RecipeCreateWithoutPracticalTagsInput, RecipeUncheckedCreateWithoutPracticalTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutPracticalTagsInput
    upsert?: RecipeUpsertWithoutPracticalTagsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutPracticalTagsInput, RecipeUpdateWithoutPracticalTagsInput>, RecipeUncheckedUpdateWithoutPracticalTagsInput>
  }

  export type PracticalTagUpdateOneRequiredWithoutRecipesNestedInput = {
    create?: XOR<PracticalTagCreateWithoutRecipesInput, PracticalTagUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: PracticalTagCreateOrConnectWithoutRecipesInput
    upsert?: PracticalTagUpsertWithoutRecipesInput
    connect?: PracticalTagWhereUniqueInput
    update?: XOR<XOR<PracticalTagUpdateToOneWithWhereWithoutRecipesInput, PracticalTagUpdateWithoutRecipesInput>, PracticalTagUncheckedUpdateWithoutRecipesInput>
  }

  export type RecipeNutritionalTagCreateNestedManyWithoutNutritionalTagInput = {
    create?: XOR<RecipeNutritionalTagCreateWithoutNutritionalTagInput, RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput> | RecipeNutritionalTagCreateWithoutNutritionalTagInput[] | RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput[]
    connectOrCreate?: RecipeNutritionalTagCreateOrConnectWithoutNutritionalTagInput | RecipeNutritionalTagCreateOrConnectWithoutNutritionalTagInput[]
    createMany?: RecipeNutritionalTagCreateManyNutritionalTagInputEnvelope
    connect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
  }

  export type RecipeNutritionalTagUncheckedCreateNestedManyWithoutNutritionalTagInput = {
    create?: XOR<RecipeNutritionalTagCreateWithoutNutritionalTagInput, RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput> | RecipeNutritionalTagCreateWithoutNutritionalTagInput[] | RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput[]
    connectOrCreate?: RecipeNutritionalTagCreateOrConnectWithoutNutritionalTagInput | RecipeNutritionalTagCreateOrConnectWithoutNutritionalTagInput[]
    createMany?: RecipeNutritionalTagCreateManyNutritionalTagInputEnvelope
    connect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
  }

  export type EnumNutritionalCategoryFieldUpdateOperationsInput = {
    set?: $Enums.NutritionalCategory
  }

  export type RecipeNutritionalTagUpdateManyWithoutNutritionalTagNestedInput = {
    create?: XOR<RecipeNutritionalTagCreateWithoutNutritionalTagInput, RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput> | RecipeNutritionalTagCreateWithoutNutritionalTagInput[] | RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput[]
    connectOrCreate?: RecipeNutritionalTagCreateOrConnectWithoutNutritionalTagInput | RecipeNutritionalTagCreateOrConnectWithoutNutritionalTagInput[]
    upsert?: RecipeNutritionalTagUpsertWithWhereUniqueWithoutNutritionalTagInput | RecipeNutritionalTagUpsertWithWhereUniqueWithoutNutritionalTagInput[]
    createMany?: RecipeNutritionalTagCreateManyNutritionalTagInputEnvelope
    set?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    disconnect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    delete?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    connect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    update?: RecipeNutritionalTagUpdateWithWhereUniqueWithoutNutritionalTagInput | RecipeNutritionalTagUpdateWithWhereUniqueWithoutNutritionalTagInput[]
    updateMany?: RecipeNutritionalTagUpdateManyWithWhereWithoutNutritionalTagInput | RecipeNutritionalTagUpdateManyWithWhereWithoutNutritionalTagInput[]
    deleteMany?: RecipeNutritionalTagScalarWhereInput | RecipeNutritionalTagScalarWhereInput[]
  }

  export type RecipeNutritionalTagUncheckedUpdateManyWithoutNutritionalTagNestedInput = {
    create?: XOR<RecipeNutritionalTagCreateWithoutNutritionalTagInput, RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput> | RecipeNutritionalTagCreateWithoutNutritionalTagInput[] | RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput[]
    connectOrCreate?: RecipeNutritionalTagCreateOrConnectWithoutNutritionalTagInput | RecipeNutritionalTagCreateOrConnectWithoutNutritionalTagInput[]
    upsert?: RecipeNutritionalTagUpsertWithWhereUniqueWithoutNutritionalTagInput | RecipeNutritionalTagUpsertWithWhereUniqueWithoutNutritionalTagInput[]
    createMany?: RecipeNutritionalTagCreateManyNutritionalTagInputEnvelope
    set?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    disconnect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    delete?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    connect?: RecipeNutritionalTagWhereUniqueInput | RecipeNutritionalTagWhereUniqueInput[]
    update?: RecipeNutritionalTagUpdateWithWhereUniqueWithoutNutritionalTagInput | RecipeNutritionalTagUpdateWithWhereUniqueWithoutNutritionalTagInput[]
    updateMany?: RecipeNutritionalTagUpdateManyWithWhereWithoutNutritionalTagInput | RecipeNutritionalTagUpdateManyWithWhereWithoutNutritionalTagInput[]
    deleteMany?: RecipeNutritionalTagScalarWhereInput | RecipeNutritionalTagScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutNutritionalTagsInput = {
    create?: XOR<RecipeCreateWithoutNutritionalTagsInput, RecipeUncheckedCreateWithoutNutritionalTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutNutritionalTagsInput
    connect?: RecipeWhereUniqueInput
  }

  export type NutritionalTagCreateNestedOneWithoutRecipesInput = {
    create?: XOR<NutritionalTagCreateWithoutRecipesInput, NutritionalTagUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: NutritionalTagCreateOrConnectWithoutRecipesInput
    connect?: NutritionalTagWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutNutritionalTagsNestedInput = {
    create?: XOR<RecipeCreateWithoutNutritionalTagsInput, RecipeUncheckedCreateWithoutNutritionalTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutNutritionalTagsInput
    upsert?: RecipeUpsertWithoutNutritionalTagsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutNutritionalTagsInput, RecipeUpdateWithoutNutritionalTagsInput>, RecipeUncheckedUpdateWithoutNutritionalTagsInput>
  }

  export type NutritionalTagUpdateOneRequiredWithoutRecipesNestedInput = {
    create?: XOR<NutritionalTagCreateWithoutRecipesInput, NutritionalTagUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: NutritionalTagCreateOrConnectWithoutRecipesInput
    upsert?: NutritionalTagUpsertWithoutRecipesInput
    connect?: NutritionalTagWhereUniqueInput
    update?: XOR<XOR<NutritionalTagUpdateToOneWithWhereWithoutRecipesInput, NutritionalTagUpdateWithoutRecipesInput>, NutritionalTagUncheckedUpdateWithoutRecipesInput>
  }

  export type UserCreateNestedOneWithoutMealPlansInput = {
    create?: XOR<UserCreateWithoutMealPlansInput, UserUncheckedCreateWithoutMealPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutMealPlansInput
    connect?: UserWhereUniqueInput
  }

  export type MealPlanItemCreateNestedManyWithoutMealPlanInput = {
    create?: XOR<MealPlanItemCreateWithoutMealPlanInput, MealPlanItemUncheckedCreateWithoutMealPlanInput> | MealPlanItemCreateWithoutMealPlanInput[] | MealPlanItemUncheckedCreateWithoutMealPlanInput[]
    connectOrCreate?: MealPlanItemCreateOrConnectWithoutMealPlanInput | MealPlanItemCreateOrConnectWithoutMealPlanInput[]
    createMany?: MealPlanItemCreateManyMealPlanInputEnvelope
    connect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
  }

  export type ShoppingListCreateNestedOneWithoutMealPlanInput = {
    create?: XOR<ShoppingListCreateWithoutMealPlanInput, ShoppingListUncheckedCreateWithoutMealPlanInput>
    connectOrCreate?: ShoppingListCreateOrConnectWithoutMealPlanInput
    connect?: ShoppingListWhereUniqueInput
  }

  export type MealPlanItemUncheckedCreateNestedManyWithoutMealPlanInput = {
    create?: XOR<MealPlanItemCreateWithoutMealPlanInput, MealPlanItemUncheckedCreateWithoutMealPlanInput> | MealPlanItemCreateWithoutMealPlanInput[] | MealPlanItemUncheckedCreateWithoutMealPlanInput[]
    connectOrCreate?: MealPlanItemCreateOrConnectWithoutMealPlanInput | MealPlanItemCreateOrConnectWithoutMealPlanInput[]
    createMany?: MealPlanItemCreateManyMealPlanInputEnvelope
    connect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
  }

  export type ShoppingListUncheckedCreateNestedOneWithoutMealPlanInput = {
    create?: XOR<ShoppingListCreateWithoutMealPlanInput, ShoppingListUncheckedCreateWithoutMealPlanInput>
    connectOrCreate?: ShoppingListCreateOrConnectWithoutMealPlanInput
    connect?: ShoppingListWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMealPlansNestedInput = {
    create?: XOR<UserCreateWithoutMealPlansInput, UserUncheckedCreateWithoutMealPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutMealPlansInput
    upsert?: UserUpsertWithoutMealPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMealPlansInput, UserUpdateWithoutMealPlansInput>, UserUncheckedUpdateWithoutMealPlansInput>
  }

  export type MealPlanItemUpdateManyWithoutMealPlanNestedInput = {
    create?: XOR<MealPlanItemCreateWithoutMealPlanInput, MealPlanItemUncheckedCreateWithoutMealPlanInput> | MealPlanItemCreateWithoutMealPlanInput[] | MealPlanItemUncheckedCreateWithoutMealPlanInput[]
    connectOrCreate?: MealPlanItemCreateOrConnectWithoutMealPlanInput | MealPlanItemCreateOrConnectWithoutMealPlanInput[]
    upsert?: MealPlanItemUpsertWithWhereUniqueWithoutMealPlanInput | MealPlanItemUpsertWithWhereUniqueWithoutMealPlanInput[]
    createMany?: MealPlanItemCreateManyMealPlanInputEnvelope
    set?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    disconnect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    delete?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    connect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    update?: MealPlanItemUpdateWithWhereUniqueWithoutMealPlanInput | MealPlanItemUpdateWithWhereUniqueWithoutMealPlanInput[]
    updateMany?: MealPlanItemUpdateManyWithWhereWithoutMealPlanInput | MealPlanItemUpdateManyWithWhereWithoutMealPlanInput[]
    deleteMany?: MealPlanItemScalarWhereInput | MealPlanItemScalarWhereInput[]
  }

  export type ShoppingListUpdateOneWithoutMealPlanNestedInput = {
    create?: XOR<ShoppingListCreateWithoutMealPlanInput, ShoppingListUncheckedCreateWithoutMealPlanInput>
    connectOrCreate?: ShoppingListCreateOrConnectWithoutMealPlanInput
    upsert?: ShoppingListUpsertWithoutMealPlanInput
    disconnect?: ShoppingListWhereInput | boolean
    delete?: ShoppingListWhereInput | boolean
    connect?: ShoppingListWhereUniqueInput
    update?: XOR<XOR<ShoppingListUpdateToOneWithWhereWithoutMealPlanInput, ShoppingListUpdateWithoutMealPlanInput>, ShoppingListUncheckedUpdateWithoutMealPlanInput>
  }

  export type MealPlanItemUncheckedUpdateManyWithoutMealPlanNestedInput = {
    create?: XOR<MealPlanItemCreateWithoutMealPlanInput, MealPlanItemUncheckedCreateWithoutMealPlanInput> | MealPlanItemCreateWithoutMealPlanInput[] | MealPlanItemUncheckedCreateWithoutMealPlanInput[]
    connectOrCreate?: MealPlanItemCreateOrConnectWithoutMealPlanInput | MealPlanItemCreateOrConnectWithoutMealPlanInput[]
    upsert?: MealPlanItemUpsertWithWhereUniqueWithoutMealPlanInput | MealPlanItemUpsertWithWhereUniqueWithoutMealPlanInput[]
    createMany?: MealPlanItemCreateManyMealPlanInputEnvelope
    set?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    disconnect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    delete?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    connect?: MealPlanItemWhereUniqueInput | MealPlanItemWhereUniqueInput[]
    update?: MealPlanItemUpdateWithWhereUniqueWithoutMealPlanInput | MealPlanItemUpdateWithWhereUniqueWithoutMealPlanInput[]
    updateMany?: MealPlanItemUpdateManyWithWhereWithoutMealPlanInput | MealPlanItemUpdateManyWithWhereWithoutMealPlanInput[]
    deleteMany?: MealPlanItemScalarWhereInput | MealPlanItemScalarWhereInput[]
  }

  export type ShoppingListUncheckedUpdateOneWithoutMealPlanNestedInput = {
    create?: XOR<ShoppingListCreateWithoutMealPlanInput, ShoppingListUncheckedCreateWithoutMealPlanInput>
    connectOrCreate?: ShoppingListCreateOrConnectWithoutMealPlanInput
    upsert?: ShoppingListUpsertWithoutMealPlanInput
    disconnect?: ShoppingListWhereInput | boolean
    delete?: ShoppingListWhereInput | boolean
    connect?: ShoppingListWhereUniqueInput
    update?: XOR<XOR<ShoppingListUpdateToOneWithWhereWithoutMealPlanInput, ShoppingListUpdateWithoutMealPlanInput>, ShoppingListUncheckedUpdateWithoutMealPlanInput>
  }

  export type MealPlanCreateNestedOneWithoutMealsInput = {
    create?: XOR<MealPlanCreateWithoutMealsInput, MealPlanUncheckedCreateWithoutMealsInput>
    connectOrCreate?: MealPlanCreateOrConnectWithoutMealsInput
    connect?: MealPlanWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutMealPlanItemsInput = {
    create?: XOR<RecipeCreateWithoutMealPlanItemsInput, RecipeUncheckedCreateWithoutMealPlanItemsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutMealPlanItemsInput
    connect?: RecipeWhereUniqueInput
  }

  export type EnumDayOfWeekFieldUpdateOperationsInput = {
    set?: $Enums.DayOfWeek
  }

  export type EnumMealTypeFieldUpdateOperationsInput = {
    set?: $Enums.MealType
  }

  export type MealPlanUpdateOneRequiredWithoutMealsNestedInput = {
    create?: XOR<MealPlanCreateWithoutMealsInput, MealPlanUncheckedCreateWithoutMealsInput>
    connectOrCreate?: MealPlanCreateOrConnectWithoutMealsInput
    upsert?: MealPlanUpsertWithoutMealsInput
    connect?: MealPlanWhereUniqueInput
    update?: XOR<XOR<MealPlanUpdateToOneWithWhereWithoutMealsInput, MealPlanUpdateWithoutMealsInput>, MealPlanUncheckedUpdateWithoutMealsInput>
  }

  export type RecipeUpdateOneRequiredWithoutMealPlanItemsNestedInput = {
    create?: XOR<RecipeCreateWithoutMealPlanItemsInput, RecipeUncheckedCreateWithoutMealPlanItemsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutMealPlanItemsInput
    upsert?: RecipeUpsertWithoutMealPlanItemsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutMealPlanItemsInput, RecipeUpdateWithoutMealPlanItemsInput>, RecipeUncheckedUpdateWithoutMealPlanItemsInput>
  }

  export type UserCreateNestedOneWithoutShoppingListsInput = {
    create?: XOR<UserCreateWithoutShoppingListsInput, UserUncheckedCreateWithoutShoppingListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoppingListsInput
    connect?: UserWhereUniqueInput
  }

  export type MealPlanCreateNestedOneWithoutShoppingListInput = {
    create?: XOR<MealPlanCreateWithoutShoppingListInput, MealPlanUncheckedCreateWithoutShoppingListInput>
    connectOrCreate?: MealPlanCreateOrConnectWithoutShoppingListInput
    connect?: MealPlanWhereUniqueInput
  }

  export type ShoppingListItemCreateNestedManyWithoutShoppingListInput = {
    create?: XOR<ShoppingListItemCreateWithoutShoppingListInput, ShoppingListItemUncheckedCreateWithoutShoppingListInput> | ShoppingListItemCreateWithoutShoppingListInput[] | ShoppingListItemUncheckedCreateWithoutShoppingListInput[]
    connectOrCreate?: ShoppingListItemCreateOrConnectWithoutShoppingListInput | ShoppingListItemCreateOrConnectWithoutShoppingListInput[]
    createMany?: ShoppingListItemCreateManyShoppingListInputEnvelope
    connect?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
  }

  export type ShoppingListItemUncheckedCreateNestedManyWithoutShoppingListInput = {
    create?: XOR<ShoppingListItemCreateWithoutShoppingListInput, ShoppingListItemUncheckedCreateWithoutShoppingListInput> | ShoppingListItemCreateWithoutShoppingListInput[] | ShoppingListItemUncheckedCreateWithoutShoppingListInput[]
    connectOrCreate?: ShoppingListItemCreateOrConnectWithoutShoppingListInput | ShoppingListItemCreateOrConnectWithoutShoppingListInput[]
    createMany?: ShoppingListItemCreateManyShoppingListInputEnvelope
    connect?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutShoppingListsNestedInput = {
    create?: XOR<UserCreateWithoutShoppingListsInput, UserUncheckedCreateWithoutShoppingListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoppingListsInput
    upsert?: UserUpsertWithoutShoppingListsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShoppingListsInput, UserUpdateWithoutShoppingListsInput>, UserUncheckedUpdateWithoutShoppingListsInput>
  }

  export type MealPlanUpdateOneWithoutShoppingListNestedInput = {
    create?: XOR<MealPlanCreateWithoutShoppingListInput, MealPlanUncheckedCreateWithoutShoppingListInput>
    connectOrCreate?: MealPlanCreateOrConnectWithoutShoppingListInput
    upsert?: MealPlanUpsertWithoutShoppingListInput
    disconnect?: MealPlanWhereInput | boolean
    delete?: MealPlanWhereInput | boolean
    connect?: MealPlanWhereUniqueInput
    update?: XOR<XOR<MealPlanUpdateToOneWithWhereWithoutShoppingListInput, MealPlanUpdateWithoutShoppingListInput>, MealPlanUncheckedUpdateWithoutShoppingListInput>
  }

  export type ShoppingListItemUpdateManyWithoutShoppingListNestedInput = {
    create?: XOR<ShoppingListItemCreateWithoutShoppingListInput, ShoppingListItemUncheckedCreateWithoutShoppingListInput> | ShoppingListItemCreateWithoutShoppingListInput[] | ShoppingListItemUncheckedCreateWithoutShoppingListInput[]
    connectOrCreate?: ShoppingListItemCreateOrConnectWithoutShoppingListInput | ShoppingListItemCreateOrConnectWithoutShoppingListInput[]
    upsert?: ShoppingListItemUpsertWithWhereUniqueWithoutShoppingListInput | ShoppingListItemUpsertWithWhereUniqueWithoutShoppingListInput[]
    createMany?: ShoppingListItemCreateManyShoppingListInputEnvelope
    set?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
    disconnect?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
    delete?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
    connect?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
    update?: ShoppingListItemUpdateWithWhereUniqueWithoutShoppingListInput | ShoppingListItemUpdateWithWhereUniqueWithoutShoppingListInput[]
    updateMany?: ShoppingListItemUpdateManyWithWhereWithoutShoppingListInput | ShoppingListItemUpdateManyWithWhereWithoutShoppingListInput[]
    deleteMany?: ShoppingListItemScalarWhereInput | ShoppingListItemScalarWhereInput[]
  }

  export type ShoppingListItemUncheckedUpdateManyWithoutShoppingListNestedInput = {
    create?: XOR<ShoppingListItemCreateWithoutShoppingListInput, ShoppingListItemUncheckedCreateWithoutShoppingListInput> | ShoppingListItemCreateWithoutShoppingListInput[] | ShoppingListItemUncheckedCreateWithoutShoppingListInput[]
    connectOrCreate?: ShoppingListItemCreateOrConnectWithoutShoppingListInput | ShoppingListItemCreateOrConnectWithoutShoppingListInput[]
    upsert?: ShoppingListItemUpsertWithWhereUniqueWithoutShoppingListInput | ShoppingListItemUpsertWithWhereUniqueWithoutShoppingListInput[]
    createMany?: ShoppingListItemCreateManyShoppingListInputEnvelope
    set?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
    disconnect?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
    delete?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
    connect?: ShoppingListItemWhereUniqueInput | ShoppingListItemWhereUniqueInput[]
    update?: ShoppingListItemUpdateWithWhereUniqueWithoutShoppingListInput | ShoppingListItemUpdateWithWhereUniqueWithoutShoppingListInput[]
    updateMany?: ShoppingListItemUpdateManyWithWhereWithoutShoppingListInput | ShoppingListItemUpdateManyWithWhereWithoutShoppingListInput[]
    deleteMany?: ShoppingListItemScalarWhereInput | ShoppingListItemScalarWhereInput[]
  }

  export type ShoppingListCreateNestedOneWithoutItemsInput = {
    create?: XOR<ShoppingListCreateWithoutItemsInput, ShoppingListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShoppingListCreateOrConnectWithoutItemsInput
    connect?: ShoppingListWhereUniqueInput
  }

  export type ShoppingListUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ShoppingListCreateWithoutItemsInput, ShoppingListUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ShoppingListCreateOrConnectWithoutItemsInput
    upsert?: ShoppingListUpsertWithoutItemsInput
    connect?: ShoppingListWhereUniqueInput
    update?: XOR<XOR<ShoppingListUpdateToOneWithWhereWithoutItemsInput, ShoppingListUpdateWithoutItemsInput>, ShoppingListUncheckedUpdateWithoutItemsInput>
  }

  export type UserCreateNestedOneWithoutFavoriteRecipesInput = {
    create?: XOR<UserCreateWithoutFavoriteRecipesInput, UserUncheckedCreateWithoutFavoriteRecipesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteRecipesInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<RecipeCreateWithoutFavoritesInput, RecipeUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutFavoritesInput
    connect?: RecipeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoriteRecipesNestedInput = {
    create?: XOR<UserCreateWithoutFavoriteRecipesInput, UserUncheckedCreateWithoutFavoriteRecipesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteRecipesInput
    upsert?: UserUpsertWithoutFavoriteRecipesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoriteRecipesInput, UserUpdateWithoutFavoriteRecipesInput>, UserUncheckedUpdateWithoutFavoriteRecipesInput>
  }

  export type RecipeUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<RecipeCreateWithoutFavoritesInput, RecipeUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutFavoritesInput
    upsert?: RecipeUpsertWithoutFavoritesInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutFavoritesInput, RecipeUpdateWithoutFavoritesInput>, RecipeUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionInput, UserUpdateWithoutSubscriptionInput>, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<RecipeCreateWithoutFeedbacksInput, RecipeUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutFeedbacksInput
    connect?: RecipeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    upsert?: UserUpsertWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbacksInput, UserUpdateWithoutFeedbacksInput>, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type RecipeUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<RecipeCreateWithoutFeedbacksInput, RecipeUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutFeedbacksInput
    upsert?: RecipeUpsertWithoutFeedbacksInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutFeedbacksInput, RecipeUpdateWithoutFeedbacksInput>, RecipeUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserCreateNestedOneWithoutAbTestsInput = {
    create?: XOR<UserCreateWithoutAbTestsInput, UserUncheckedCreateWithoutAbTestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbTestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAbTestsNestedInput = {
    create?: XOR<UserCreateWithoutAbTestsInput, UserUncheckedCreateWithoutAbTestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbTestsInput
    upsert?: UserUpsertWithoutAbTestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAbTestsInput, UserUpdateWithoutAbTestsInput>, UserUncheckedUpdateWithoutAbTestsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumDietaryGoalNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryGoal | EnumDietaryGoalFieldRefInput<$PrismaModel> | null
    in?: $Enums.DietaryGoal[] | null
    notIn?: $Enums.DietaryGoal[] | null
    not?: NestedEnumDietaryGoalNullableFilter<$PrismaModel> | $Enums.DietaryGoal | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumDietaryGoalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryGoal | EnumDietaryGoalFieldRefInput<$PrismaModel> | null
    in?: $Enums.DietaryGoal[] | null
    notIn?: $Enums.DietaryGoal[] | null
    not?: NestedEnumDietaryGoalNullableWithAggregatesFilter<$PrismaModel> | $Enums.DietaryGoal | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDietaryGoalNullableFilter<$PrismaModel>
    _max?: NestedEnumDietaryGoalNullableFilter<$PrismaModel>
  }

  export type NestedEnumCookingSkillFilter<$PrismaModel = never> = {
    equals?: $Enums.CookingSkill | EnumCookingSkillFieldRefInput<$PrismaModel>
    in?: $Enums.CookingSkill[]
    notIn?: $Enums.CookingSkill[]
    not?: NestedEnumCookingSkillFilter<$PrismaModel> | $Enums.CookingSkill
  }

  export type NestedEnumBudgetRangeFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetRange | EnumBudgetRangeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetRange[]
    notIn?: $Enums.BudgetRange[]
    not?: NestedEnumBudgetRangeFilter<$PrismaModel> | $Enums.BudgetRange
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCookingSkillWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CookingSkill | EnumCookingSkillFieldRefInput<$PrismaModel>
    in?: $Enums.CookingSkill[]
    notIn?: $Enums.CookingSkill[]
    not?: NestedEnumCookingSkillWithAggregatesFilter<$PrismaModel> | $Enums.CookingSkill
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCookingSkillFilter<$PrismaModel>
    _max?: NestedEnumCookingSkillFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumBudgetRangeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetRange | EnumBudgetRangeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetRange[]
    notIn?: $Enums.BudgetRange[]
    not?: NestedEnumBudgetRangeWithAggregatesFilter<$PrismaModel> | $Enums.BudgetRange
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetRangeFilter<$PrismaModel>
    _max?: NestedEnumBudgetRangeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumHealthCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthCategory | EnumHealthCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.HealthCategory[]
    notIn?: $Enums.HealthCategory[]
    not?: NestedEnumHealthCategoryFilter<$PrismaModel> | $Enums.HealthCategory
  }

  export type NestedEnumHealthCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthCategory | EnumHealthCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.HealthCategory[]
    notIn?: $Enums.HealthCategory[]
    not?: NestedEnumHealthCategoryWithAggregatesFilter<$PrismaModel> | $Enums.HealthCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHealthCategoryFilter<$PrismaModel>
    _max?: NestedEnumHealthCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[]
    notIn?: $Enums.Severity[]
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[]
    notIn?: $Enums.Severity[]
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAllergenCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AllergenCategory | EnumAllergenCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AllergenCategory[]
    notIn?: $Enums.AllergenCategory[]
    not?: NestedEnumAllergenCategoryFilter<$PrismaModel> | $Enums.AllergenCategory
  }

  export type NestedEnumAllergenCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AllergenCategory | EnumAllergenCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AllergenCategory[]
    notIn?: $Enums.AllergenCategory[]
    not?: NestedEnumAllergenCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AllergenCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAllergenCategoryFilter<$PrismaModel>
    _max?: NestedEnumAllergenCategoryFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDietaryCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryCategory | EnumDietaryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DietaryCategory[]
    notIn?: $Enums.DietaryCategory[]
    not?: NestedEnumDietaryCategoryFilter<$PrismaModel> | $Enums.DietaryCategory
  }

  export type NestedEnumDietaryCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DietaryCategory | EnumDietaryCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.DietaryCategory[]
    notIn?: $Enums.DietaryCategory[]
    not?: NestedEnumDietaryCategoryWithAggregatesFilter<$PrismaModel> | $Enums.DietaryCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDietaryCategoryFilter<$PrismaModel>
    _max?: NestedEnumDietaryCategoryFilter<$PrismaModel>
  }

  export type NestedEnumPracticalCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PracticalCategory | EnumPracticalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PracticalCategory[]
    notIn?: $Enums.PracticalCategory[]
    not?: NestedEnumPracticalCategoryFilter<$PrismaModel> | $Enums.PracticalCategory
  }

  export type NestedEnumPracticalCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PracticalCategory | EnumPracticalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PracticalCategory[]
    notIn?: $Enums.PracticalCategory[]
    not?: NestedEnumPracticalCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PracticalCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPracticalCategoryFilter<$PrismaModel>
    _max?: NestedEnumPracticalCategoryFilter<$PrismaModel>
  }

  export type NestedEnumNutritionalCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NutritionalCategory | EnumNutritionalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NutritionalCategory[]
    notIn?: $Enums.NutritionalCategory[]
    not?: NestedEnumNutritionalCategoryFilter<$PrismaModel> | $Enums.NutritionalCategory
  }

  export type NestedEnumNutritionalCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NutritionalCategory | EnumNutritionalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NutritionalCategory[]
    notIn?: $Enums.NutritionalCategory[]
    not?: NestedEnumNutritionalCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NutritionalCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNutritionalCategoryFilter<$PrismaModel>
    _max?: NestedEnumNutritionalCategoryFilter<$PrismaModel>
  }

  export type NestedEnumDayOfWeekFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekFilter<$PrismaModel> | $Enums.DayOfWeek
  }

  export type NestedEnumMealTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MealType | EnumMealTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MealType[]
    notIn?: $Enums.MealType[]
    not?: NestedEnumMealTypeFilter<$PrismaModel> | $Enums.MealType
  }

  export type NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DayOfWeek | EnumDayOfWeekFieldRefInput<$PrismaModel>
    in?: $Enums.DayOfWeek[]
    notIn?: $Enums.DayOfWeek[]
    not?: NestedEnumDayOfWeekWithAggregatesFilter<$PrismaModel> | $Enums.DayOfWeek
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDayOfWeekFilter<$PrismaModel>
    _max?: NestedEnumDayOfWeekFilter<$PrismaModel>
  }

  export type NestedEnumMealTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MealType | EnumMealTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MealType[]
    notIn?: $Enums.MealType[]
    not?: NestedEnumMealTypeWithAggregatesFilter<$PrismaModel> | $Enums.MealType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMealTypeFilter<$PrismaModel>
    _max?: NestedEnumMealTypeFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[]
    notIn?: $Enums.SubscriptionTier[]
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[]
    notIn?: $Enums.SubscriptionTier[]
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type UserHealthConditionCreateWithoutUserInput = {
    id?: string
    severity?: $Enums.Severity
    diagnosedDate?: Date | string | null
    healthCondition: HealthConditionCreateNestedOneWithoutUsersInput
  }

  export type UserHealthConditionUncheckedCreateWithoutUserInput = {
    id?: string
    healthConditionId: string
    severity?: $Enums.Severity
    diagnosedDate?: Date | string | null
  }

  export type UserHealthConditionCreateOrConnectWithoutUserInput = {
    where: UserHealthConditionWhereUniqueInput
    create: XOR<UserHealthConditionCreateWithoutUserInput, UserHealthConditionUncheckedCreateWithoutUserInput>
  }

  export type UserHealthConditionCreateManyUserInputEnvelope = {
    data: UserHealthConditionCreateManyUserInput | UserHealthConditionCreateManyUserInput[]
  }

  export type UserAllergyCreateWithoutUserInput = {
    id?: string
    severity?: $Enums.Severity
    allergen: AllergenCreateNestedOneWithoutUsersInput
  }

  export type UserAllergyUncheckedCreateWithoutUserInput = {
    id?: string
    allergenId: string
    severity?: $Enums.Severity
  }

  export type UserAllergyCreateOrConnectWithoutUserInput = {
    where: UserAllergyWhereUniqueInput
    create: XOR<UserAllergyCreateWithoutUserInput, UserAllergyUncheckedCreateWithoutUserInput>
  }

  export type UserAllergyCreateManyUserInputEnvelope = {
    data: UserAllergyCreateManyUserInput | UserAllergyCreateManyUserInput[]
  }

  export type UserPreferencesCreateWithoutUserInput = {
    id?: string
    cookingSkillLevel?: $Enums.CookingSkill
    maxPrepTimeMinutes?: number
    budgetRange?: $Enums.BudgetRange
    householdSize?: number
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: number
    snacksPerDay?: number
    batchCookingPreference?: boolean
    energyRestrictionGoal?: string | null
    targetCaloriesMin?: number | null
    targetCaloriesMax?: number | null
    cuisinePreferences?: string | null
    spiceTolerance?: number
    flavorIntensity?: number
    knifeSkillLevel?: string
    preferredTechniques?: string | null
    recipeComplexityComfort?: number
    weeklyFoodBudget?: number | null
    shoppingFrequency?: string
    mealPlanningApproach?: number
    textureLimitations?: string | null
    foodsToAvoid?: string | null
    mealTimingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appliances?: UserApplianceCreateNestedManyWithoutUserPreferencesInput
    behaviorProfile?: UserBehaviorCreateNestedOneWithoutUserPreferencesInput
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    cookingSkillLevel?: $Enums.CookingSkill
    maxPrepTimeMinutes?: number
    budgetRange?: $Enums.BudgetRange
    householdSize?: number
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: number
    snacksPerDay?: number
    batchCookingPreference?: boolean
    energyRestrictionGoal?: string | null
    targetCaloriesMin?: number | null
    targetCaloriesMax?: number | null
    cuisinePreferences?: string | null
    spiceTolerance?: number
    flavorIntensity?: number
    knifeSkillLevel?: string
    preferredTechniques?: string | null
    recipeComplexityComfort?: number
    weeklyFoodBudget?: number | null
    shoppingFrequency?: string
    mealPlanningApproach?: number
    textureLimitations?: string | null
    foodsToAvoid?: string | null
    mealTimingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appliances?: UserApplianceUncheckedCreateNestedManyWithoutUserPreferencesInput
    behaviorProfile?: UserBehaviorUncheckedCreateNestedOneWithoutUserPreferencesInput
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type MealPlanCreateWithoutUserInput = {
    id?: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: MealPlanItemCreateNestedManyWithoutMealPlanInput
    shoppingList?: ShoppingListCreateNestedOneWithoutMealPlanInput
  }

  export type MealPlanUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: MealPlanItemUncheckedCreateNestedManyWithoutMealPlanInput
    shoppingList?: ShoppingListUncheckedCreateNestedOneWithoutMealPlanInput
  }

  export type MealPlanCreateOrConnectWithoutUserInput = {
    where: MealPlanWhereUniqueInput
    create: XOR<MealPlanCreateWithoutUserInput, MealPlanUncheckedCreateWithoutUserInput>
  }

  export type MealPlanCreateManyUserInputEnvelope = {
    data: MealPlanCreateManyUserInput | MealPlanCreateManyUserInput[]
  }

  export type ShoppingListCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mealPlan?: MealPlanCreateNestedOneWithoutShoppingListInput
    items?: ShoppingListItemCreateNestedManyWithoutShoppingListInput
  }

  export type ShoppingListUncheckedCreateWithoutUserInput = {
    id?: string
    mealPlanId?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ShoppingListItemUncheckedCreateNestedManyWithoutShoppingListInput
  }

  export type ShoppingListCreateOrConnectWithoutUserInput = {
    where: ShoppingListWhereUniqueInput
    create: XOR<ShoppingListCreateWithoutUserInput, ShoppingListUncheckedCreateWithoutUserInput>
  }

  export type ShoppingListCreateManyUserInputEnvelope = {
    data: ShoppingListCreateManyUserInput | ShoppingListCreateManyUserInput[]
  }

  export type UserFavoriteRecipeCreateWithoutUserInput = {
    id?: string
    addedAt?: Date | string
    recipe: RecipeCreateNestedOneWithoutFavoritesInput
  }

  export type UserFavoriteRecipeUncheckedCreateWithoutUserInput = {
    id?: string
    recipeId: string
    addedAt?: Date | string
  }

  export type UserFavoriteRecipeCreateOrConnectWithoutUserInput = {
    where: UserFavoriteRecipeWhereUniqueInput
    create: XOR<UserFavoriteRecipeCreateWithoutUserInput, UserFavoriteRecipeUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteRecipeCreateManyUserInputEnvelope = {
    data: UserFavoriteRecipeCreateManyUserInput | UserFavoriteRecipeCreateManyUserInput[]
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status: $Enums.SubscriptionStatus
    tier: $Enums.SubscriptionTier
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    stripeCustomerId?: string | null
    stripeSubscriptionId?: string | null
    status: $Enums.SubscriptionStatus
    tier: $Enums.SubscriptionTier
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type FeedbackCreateWithoutUserInput = {
    id?: string
    rating: number
    notes?: string | null
    timestamp?: Date | string
    recipe: RecipeCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateWithoutUserInput = {
    id?: string
    recipeId: string
    rating: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackCreateManyUserInputEnvelope = {
    data: FeedbackCreateManyUserInput | FeedbackCreateManyUserInput[]
  }

  export type ABTestCreateWithoutUserInput = {
    id?: string
    feature: string
    variant: string
    timestamp?: Date | string
  }

  export type ABTestUncheckedCreateWithoutUserInput = {
    id?: string
    feature: string
    variant: string
    timestamp?: Date | string
  }

  export type ABTestCreateOrConnectWithoutUserInput = {
    where: ABTestWhereUniqueInput
    create: XOR<ABTestCreateWithoutUserInput, ABTestUncheckedCreateWithoutUserInput>
  }

  export type ABTestCreateManyUserInputEnvelope = {
    data: ABTestCreateManyUserInput | ABTestCreateManyUserInput[]
  }

  export type UserHealthConditionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserHealthConditionWhereUniqueInput
    update: XOR<UserHealthConditionUpdateWithoutUserInput, UserHealthConditionUncheckedUpdateWithoutUserInput>
    create: XOR<UserHealthConditionCreateWithoutUserInput, UserHealthConditionUncheckedCreateWithoutUserInput>
  }

  export type UserHealthConditionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserHealthConditionWhereUniqueInput
    data: XOR<UserHealthConditionUpdateWithoutUserInput, UserHealthConditionUncheckedUpdateWithoutUserInput>
  }

  export type UserHealthConditionUpdateManyWithWhereWithoutUserInput = {
    where: UserHealthConditionScalarWhereInput
    data: XOR<UserHealthConditionUpdateManyMutationInput, UserHealthConditionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserHealthConditionScalarWhereInput = {
    AND?: UserHealthConditionScalarWhereInput | UserHealthConditionScalarWhereInput[]
    OR?: UserHealthConditionScalarWhereInput[]
    NOT?: UserHealthConditionScalarWhereInput | UserHealthConditionScalarWhereInput[]
    id?: StringFilter<"UserHealthCondition"> | string
    userId?: StringFilter<"UserHealthCondition"> | string
    healthConditionId?: StringFilter<"UserHealthCondition"> | string
    severity?: EnumSeverityFilter<"UserHealthCondition"> | $Enums.Severity
    diagnosedDate?: DateTimeNullableFilter<"UserHealthCondition"> | Date | string | null
  }

  export type UserAllergyUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAllergyWhereUniqueInput
    update: XOR<UserAllergyUpdateWithoutUserInput, UserAllergyUncheckedUpdateWithoutUserInput>
    create: XOR<UserAllergyCreateWithoutUserInput, UserAllergyUncheckedCreateWithoutUserInput>
  }

  export type UserAllergyUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAllergyWhereUniqueInput
    data: XOR<UserAllergyUpdateWithoutUserInput, UserAllergyUncheckedUpdateWithoutUserInput>
  }

  export type UserAllergyUpdateManyWithWhereWithoutUserInput = {
    where: UserAllergyScalarWhereInput
    data: XOR<UserAllergyUpdateManyMutationInput, UserAllergyUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAllergyScalarWhereInput = {
    AND?: UserAllergyScalarWhereInput | UserAllergyScalarWhereInput[]
    OR?: UserAllergyScalarWhereInput[]
    NOT?: UserAllergyScalarWhereInput | UserAllergyScalarWhereInput[]
    id?: StringFilter<"UserAllergy"> | string
    userId?: StringFilter<"UserAllergy"> | string
    allergenId?: StringFilter<"UserAllergy"> | string
    severity?: EnumSeverityFilter<"UserAllergy"> | $Enums.Severity
  }

  export type UserPreferencesUpsertWithoutUserInput = {
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appliances?: UserApplianceUpdateManyWithoutUserPreferencesNestedInput
    behaviorProfile?: UserBehaviorUpdateOneWithoutUserPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appliances?: UserApplianceUncheckedUpdateManyWithoutUserPreferencesNestedInput
    behaviorProfile?: UserBehaviorUncheckedUpdateOneWithoutUserPreferencesNestedInput
  }

  export type MealPlanUpsertWithWhereUniqueWithoutUserInput = {
    where: MealPlanWhereUniqueInput
    update: XOR<MealPlanUpdateWithoutUserInput, MealPlanUncheckedUpdateWithoutUserInput>
    create: XOR<MealPlanCreateWithoutUserInput, MealPlanUncheckedCreateWithoutUserInput>
  }

  export type MealPlanUpdateWithWhereUniqueWithoutUserInput = {
    where: MealPlanWhereUniqueInput
    data: XOR<MealPlanUpdateWithoutUserInput, MealPlanUncheckedUpdateWithoutUserInput>
  }

  export type MealPlanUpdateManyWithWhereWithoutUserInput = {
    where: MealPlanScalarWhereInput
    data: XOR<MealPlanUpdateManyMutationInput, MealPlanUncheckedUpdateManyWithoutUserInput>
  }

  export type MealPlanScalarWhereInput = {
    AND?: MealPlanScalarWhereInput | MealPlanScalarWhereInput[]
    OR?: MealPlanScalarWhereInput[]
    NOT?: MealPlanScalarWhereInput | MealPlanScalarWhereInput[]
    id?: StringFilter<"MealPlan"> | string
    userId?: StringFilter<"MealPlan"> | string
    name?: StringFilter<"MealPlan"> | string
    weekStartDate?: DateTimeFilter<"MealPlan"> | Date | string
    createdAt?: DateTimeFilter<"MealPlan"> | Date | string
    updatedAt?: DateTimeFilter<"MealPlan"> | Date | string
  }

  export type ShoppingListUpsertWithWhereUniqueWithoutUserInput = {
    where: ShoppingListWhereUniqueInput
    update: XOR<ShoppingListUpdateWithoutUserInput, ShoppingListUncheckedUpdateWithoutUserInput>
    create: XOR<ShoppingListCreateWithoutUserInput, ShoppingListUncheckedCreateWithoutUserInput>
  }

  export type ShoppingListUpdateWithWhereUniqueWithoutUserInput = {
    where: ShoppingListWhereUniqueInput
    data: XOR<ShoppingListUpdateWithoutUserInput, ShoppingListUncheckedUpdateWithoutUserInput>
  }

  export type ShoppingListUpdateManyWithWhereWithoutUserInput = {
    where: ShoppingListScalarWhereInput
    data: XOR<ShoppingListUpdateManyMutationInput, ShoppingListUncheckedUpdateManyWithoutUserInput>
  }

  export type ShoppingListScalarWhereInput = {
    AND?: ShoppingListScalarWhereInput | ShoppingListScalarWhereInput[]
    OR?: ShoppingListScalarWhereInput[]
    NOT?: ShoppingListScalarWhereInput | ShoppingListScalarWhereInput[]
    id?: StringFilter<"ShoppingList"> | string
    userId?: StringFilter<"ShoppingList"> | string
    mealPlanId?: StringNullableFilter<"ShoppingList"> | string | null
    name?: StringFilter<"ShoppingList"> | string
    createdAt?: DateTimeFilter<"ShoppingList"> | Date | string
    updatedAt?: DateTimeFilter<"ShoppingList"> | Date | string
  }

  export type UserFavoriteRecipeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteRecipeWhereUniqueInput
    update: XOR<UserFavoriteRecipeUpdateWithoutUserInput, UserFavoriteRecipeUncheckedUpdateWithoutUserInput>
    create: XOR<UserFavoriteRecipeCreateWithoutUserInput, UserFavoriteRecipeUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteRecipeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteRecipeWhereUniqueInput
    data: XOR<UserFavoriteRecipeUpdateWithoutUserInput, UserFavoriteRecipeUncheckedUpdateWithoutUserInput>
  }

  export type UserFavoriteRecipeUpdateManyWithWhereWithoutUserInput = {
    where: UserFavoriteRecipeScalarWhereInput
    data: XOR<UserFavoriteRecipeUpdateManyMutationInput, UserFavoriteRecipeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFavoriteRecipeScalarWhereInput = {
    AND?: UserFavoriteRecipeScalarWhereInput | UserFavoriteRecipeScalarWhereInput[]
    OR?: UserFavoriteRecipeScalarWhereInput[]
    NOT?: UserFavoriteRecipeScalarWhereInput | UserFavoriteRecipeScalarWhereInput[]
    id?: StringFilter<"UserFavoriteRecipe"> | string
    userId?: StringFilter<"UserFavoriteRecipe"> | string
    recipeId?: StringFilter<"UserFavoriteRecipe"> | string
    addedAt?: DateTimeFilter<"UserFavoriteRecipe"> | Date | string
  }

  export type SubscriptionUpsertWithoutUserInput = {
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    tier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
    create: XOR<FeedbackCreateWithoutUserInput, FeedbackUncheckedCreateWithoutUserInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutUserInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutUserInput, FeedbackUncheckedUpdateWithoutUserInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutUserInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutUserInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: StringFilter<"Feedback"> | string
    userId?: StringFilter<"Feedback"> | string
    recipeId?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    notes?: StringNullableFilter<"Feedback"> | string | null
    timestamp?: DateTimeFilter<"Feedback"> | Date | string
  }

  export type ABTestUpsertWithWhereUniqueWithoutUserInput = {
    where: ABTestWhereUniqueInput
    update: XOR<ABTestUpdateWithoutUserInput, ABTestUncheckedUpdateWithoutUserInput>
    create: XOR<ABTestCreateWithoutUserInput, ABTestUncheckedCreateWithoutUserInput>
  }

  export type ABTestUpdateWithWhereUniqueWithoutUserInput = {
    where: ABTestWhereUniqueInput
    data: XOR<ABTestUpdateWithoutUserInput, ABTestUncheckedUpdateWithoutUserInput>
  }

  export type ABTestUpdateManyWithWhereWithoutUserInput = {
    where: ABTestScalarWhereInput
    data: XOR<ABTestUpdateManyMutationInput, ABTestUncheckedUpdateManyWithoutUserInput>
  }

  export type ABTestScalarWhereInput = {
    AND?: ABTestScalarWhereInput | ABTestScalarWhereInput[]
    OR?: ABTestScalarWhereInput[]
    NOT?: ABTestScalarWhereInput | ABTestScalarWhereInput[]
    id?: StringFilter<"ABTest"> | string
    userId?: StringFilter<"ABTest"> | string
    feature?: StringFilter<"ABTest"> | string
    variant?: StringFilter<"ABTest"> | string
    timestamp?: DateTimeFilter<"ABTest"> | Date | string
  }

  export type UserCreateWithoutPreferencesInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionCreateNestedManyWithoutUserInput
    allergies?: UserAllergyCreateNestedManyWithoutUserInput
    mealPlans?: MealPlanCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    abTests?: ABTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionUncheckedCreateNestedManyWithoutUserInput
    allergies?: UserAllergyUncheckedCreateNestedManyWithoutUserInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListUncheckedCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    abTests?: ABTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserApplianceCreateWithoutUserPreferencesInput = {
    id?: string
    usageFrequency?: number
    appliance: ApplianceCreateNestedOneWithoutUsersInput
  }

  export type UserApplianceUncheckedCreateWithoutUserPreferencesInput = {
    id?: string
    applianceId: string
    usageFrequency?: number
  }

  export type UserApplianceCreateOrConnectWithoutUserPreferencesInput = {
    where: UserApplianceWhereUniqueInput
    create: XOR<UserApplianceCreateWithoutUserPreferencesInput, UserApplianceUncheckedCreateWithoutUserPreferencesInput>
  }

  export type UserApplianceCreateManyUserPreferencesInputEnvelope = {
    data: UserApplianceCreateManyUserPreferencesInput | UserApplianceCreateManyUserPreferencesInput[]
  }

  export type UserBehaviorCreateWithoutUserPreferencesInput = {
    id?: string
    portionControlMotivation?: number
    habitChangeReadiness?: string | null
    socialEatingPattern?: number
    successTrackingPreference?: string
    activityLevel?: string
    healthConditionPriority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBehaviorUncheckedCreateWithoutUserPreferencesInput = {
    id?: string
    portionControlMotivation?: number
    habitChangeReadiness?: string | null
    socialEatingPattern?: number
    successTrackingPreference?: string
    activityLevel?: string
    healthConditionPriority?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBehaviorCreateOrConnectWithoutUserPreferencesInput = {
    where: UserBehaviorWhereUniqueInput
    create: XOR<UserBehaviorCreateWithoutUserPreferencesInput, UserBehaviorUncheckedCreateWithoutUserPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUpdateManyWithoutUserNestedInput
    mealPlans?: MealPlanUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    abTests?: ABTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUncheckedUpdateManyWithoutUserNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUncheckedUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    abTests?: ABTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserApplianceUpsertWithWhereUniqueWithoutUserPreferencesInput = {
    where: UserApplianceWhereUniqueInput
    update: XOR<UserApplianceUpdateWithoutUserPreferencesInput, UserApplianceUncheckedUpdateWithoutUserPreferencesInput>
    create: XOR<UserApplianceCreateWithoutUserPreferencesInput, UserApplianceUncheckedCreateWithoutUserPreferencesInput>
  }

  export type UserApplianceUpdateWithWhereUniqueWithoutUserPreferencesInput = {
    where: UserApplianceWhereUniqueInput
    data: XOR<UserApplianceUpdateWithoutUserPreferencesInput, UserApplianceUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type UserApplianceUpdateManyWithWhereWithoutUserPreferencesInput = {
    where: UserApplianceScalarWhereInput
    data: XOR<UserApplianceUpdateManyMutationInput, UserApplianceUncheckedUpdateManyWithoutUserPreferencesInput>
  }

  export type UserApplianceScalarWhereInput = {
    AND?: UserApplianceScalarWhereInput | UserApplianceScalarWhereInput[]
    OR?: UserApplianceScalarWhereInput[]
    NOT?: UserApplianceScalarWhereInput | UserApplianceScalarWhereInput[]
    id?: StringFilter<"UserAppliance"> | string
    userPreferencesId?: StringFilter<"UserAppliance"> | string
    applianceId?: StringFilter<"UserAppliance"> | string
    usageFrequency?: IntFilter<"UserAppliance"> | number
  }

  export type UserBehaviorUpsertWithoutUserPreferencesInput = {
    update: XOR<UserBehaviorUpdateWithoutUserPreferencesInput, UserBehaviorUncheckedUpdateWithoutUserPreferencesInput>
    create: XOR<UserBehaviorCreateWithoutUserPreferencesInput, UserBehaviorUncheckedCreateWithoutUserPreferencesInput>
    where?: UserBehaviorWhereInput
  }

  export type UserBehaviorUpdateToOneWithWhereWithoutUserPreferencesInput = {
    where?: UserBehaviorWhereInput
    data: XOR<UserBehaviorUpdateWithoutUserPreferencesInput, UserBehaviorUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type UserBehaviorUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    portionControlMotivation?: IntFieldUpdateOperationsInput | number
    habitChangeReadiness?: NullableStringFieldUpdateOperationsInput | string | null
    socialEatingPattern?: IntFieldUpdateOperationsInput | number
    successTrackingPreference?: StringFieldUpdateOperationsInput | string
    activityLevel?: StringFieldUpdateOperationsInput | string
    healthConditionPriority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBehaviorUncheckedUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    portionControlMotivation?: IntFieldUpdateOperationsInput | number
    habitChangeReadiness?: NullableStringFieldUpdateOperationsInput | string | null
    socialEatingPattern?: IntFieldUpdateOperationsInput | number
    successTrackingPreference?: StringFieldUpdateOperationsInput | string
    activityLevel?: StringFieldUpdateOperationsInput | string
    healthConditionPriority?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserHealthConditionCreateWithoutHealthConditionInput = {
    id?: string
    severity?: $Enums.Severity
    diagnosedDate?: Date | string | null
    user: UserCreateNestedOneWithoutHealthConditionsInput
  }

  export type UserHealthConditionUncheckedCreateWithoutHealthConditionInput = {
    id?: string
    userId: string
    severity?: $Enums.Severity
    diagnosedDate?: Date | string | null
  }

  export type UserHealthConditionCreateOrConnectWithoutHealthConditionInput = {
    where: UserHealthConditionWhereUniqueInput
    create: XOR<UserHealthConditionCreateWithoutHealthConditionInput, UserHealthConditionUncheckedCreateWithoutHealthConditionInput>
  }

  export type UserHealthConditionCreateManyHealthConditionInputEnvelope = {
    data: UserHealthConditionCreateManyHealthConditionInput | UserHealthConditionCreateManyHealthConditionInput[]
  }

  export type UserHealthConditionUpsertWithWhereUniqueWithoutHealthConditionInput = {
    where: UserHealthConditionWhereUniqueInput
    update: XOR<UserHealthConditionUpdateWithoutHealthConditionInput, UserHealthConditionUncheckedUpdateWithoutHealthConditionInput>
    create: XOR<UserHealthConditionCreateWithoutHealthConditionInput, UserHealthConditionUncheckedCreateWithoutHealthConditionInput>
  }

  export type UserHealthConditionUpdateWithWhereUniqueWithoutHealthConditionInput = {
    where: UserHealthConditionWhereUniqueInput
    data: XOR<UserHealthConditionUpdateWithoutHealthConditionInput, UserHealthConditionUncheckedUpdateWithoutHealthConditionInput>
  }

  export type UserHealthConditionUpdateManyWithWhereWithoutHealthConditionInput = {
    where: UserHealthConditionScalarWhereInput
    data: XOR<UserHealthConditionUpdateManyMutationInput, UserHealthConditionUncheckedUpdateManyWithoutHealthConditionInput>
  }

  export type UserCreateWithoutHealthConditionsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    allergies?: UserAllergyCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    abTests?: ABTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHealthConditionsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    allergies?: UserAllergyUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListUncheckedCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    abTests?: ABTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHealthConditionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHealthConditionsInput, UserUncheckedCreateWithoutHealthConditionsInput>
  }

  export type HealthConditionCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.HealthCategory
  }

  export type HealthConditionUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.HealthCategory
  }

  export type HealthConditionCreateOrConnectWithoutUsersInput = {
    where: HealthConditionWhereUniqueInput
    create: XOR<HealthConditionCreateWithoutUsersInput, HealthConditionUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutHealthConditionsInput = {
    update: XOR<UserUpdateWithoutHealthConditionsInput, UserUncheckedUpdateWithoutHealthConditionsInput>
    create: XOR<UserCreateWithoutHealthConditionsInput, UserUncheckedCreateWithoutHealthConditionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHealthConditionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHealthConditionsInput, UserUncheckedUpdateWithoutHealthConditionsInput>
  }

  export type UserUpdateWithoutHealthConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: UserAllergyUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    abTests?: ABTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHealthConditionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: UserAllergyUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUncheckedUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    abTests?: ABTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HealthConditionUpsertWithoutUsersInput = {
    update: XOR<HealthConditionUpdateWithoutUsersInput, HealthConditionUncheckedUpdateWithoutUsersInput>
    create: XOR<HealthConditionCreateWithoutUsersInput, HealthConditionUncheckedCreateWithoutUsersInput>
    where?: HealthConditionWhereInput
  }

  export type HealthConditionUpdateToOneWithWhereWithoutUsersInput = {
    where?: HealthConditionWhereInput
    data: XOR<HealthConditionUpdateWithoutUsersInput, HealthConditionUncheckedUpdateWithoutUsersInput>
  }

  export type HealthConditionUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumHealthCategoryFieldUpdateOperationsInput | $Enums.HealthCategory
  }

  export type HealthConditionUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumHealthCategoryFieldUpdateOperationsInput | $Enums.HealthCategory
  }

  export type UserAllergyCreateWithoutAllergenInput = {
    id?: string
    severity?: $Enums.Severity
    user: UserCreateNestedOneWithoutAllergiesInput
  }

  export type UserAllergyUncheckedCreateWithoutAllergenInput = {
    id?: string
    userId: string
    severity?: $Enums.Severity
  }

  export type UserAllergyCreateOrConnectWithoutAllergenInput = {
    where: UserAllergyWhereUniqueInput
    create: XOR<UserAllergyCreateWithoutAllergenInput, UserAllergyUncheckedCreateWithoutAllergenInput>
  }

  export type UserAllergyCreateManyAllergenInputEnvelope = {
    data: UserAllergyCreateManyAllergenInput | UserAllergyCreateManyAllergenInput[]
  }

  export type UserAllergyUpsertWithWhereUniqueWithoutAllergenInput = {
    where: UserAllergyWhereUniqueInput
    update: XOR<UserAllergyUpdateWithoutAllergenInput, UserAllergyUncheckedUpdateWithoutAllergenInput>
    create: XOR<UserAllergyCreateWithoutAllergenInput, UserAllergyUncheckedCreateWithoutAllergenInput>
  }

  export type UserAllergyUpdateWithWhereUniqueWithoutAllergenInput = {
    where: UserAllergyWhereUniqueInput
    data: XOR<UserAllergyUpdateWithoutAllergenInput, UserAllergyUncheckedUpdateWithoutAllergenInput>
  }

  export type UserAllergyUpdateManyWithWhereWithoutAllergenInput = {
    where: UserAllergyScalarWhereInput
    data: XOR<UserAllergyUpdateManyMutationInput, UserAllergyUncheckedUpdateManyWithoutAllergenInput>
  }

  export type UserCreateWithoutAllergiesInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    abTests?: ABTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAllergiesInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListUncheckedCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    abTests?: ABTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAllergiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAllergiesInput, UserUncheckedCreateWithoutAllergiesInput>
  }

  export type AllergenCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.AllergenCategory
  }

  export type AllergenUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.AllergenCategory
  }

  export type AllergenCreateOrConnectWithoutUsersInput = {
    where: AllergenWhereUniqueInput
    create: XOR<AllergenCreateWithoutUsersInput, AllergenUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutAllergiesInput = {
    update: XOR<UserUpdateWithoutAllergiesInput, UserUncheckedUpdateWithoutAllergiesInput>
    create: XOR<UserCreateWithoutAllergiesInput, UserUncheckedCreateWithoutAllergiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAllergiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAllergiesInput, UserUncheckedUpdateWithoutAllergiesInput>
  }

  export type UserUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    abTests?: ABTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUncheckedUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    abTests?: ABTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AllergenUpsertWithoutUsersInput = {
    update: XOR<AllergenUpdateWithoutUsersInput, AllergenUncheckedUpdateWithoutUsersInput>
    create: XOR<AllergenCreateWithoutUsersInput, AllergenUncheckedCreateWithoutUsersInput>
    where?: AllergenWhereInput
  }

  export type AllergenUpdateToOneWithWhereWithoutUsersInput = {
    where?: AllergenWhereInput
    data: XOR<AllergenUpdateWithoutUsersInput, AllergenUncheckedUpdateWithoutUsersInput>
  }

  export type AllergenUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAllergenCategoryFieldUpdateOperationsInput | $Enums.AllergenCategory
  }

  export type AllergenUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumAllergenCategoryFieldUpdateOperationsInput | $Enums.AllergenCategory
  }

  export type UserApplianceCreateWithoutApplianceInput = {
    id?: string
    usageFrequency?: number
    userPreferences: UserPreferencesCreateNestedOneWithoutAppliancesInput
  }

  export type UserApplianceUncheckedCreateWithoutApplianceInput = {
    id?: string
    userPreferencesId: string
    usageFrequency?: number
  }

  export type UserApplianceCreateOrConnectWithoutApplianceInput = {
    where: UserApplianceWhereUniqueInput
    create: XOR<UserApplianceCreateWithoutApplianceInput, UserApplianceUncheckedCreateWithoutApplianceInput>
  }

  export type UserApplianceCreateManyApplianceInputEnvelope = {
    data: UserApplianceCreateManyApplianceInput | UserApplianceCreateManyApplianceInput[]
  }

  export type UserApplianceUpsertWithWhereUniqueWithoutApplianceInput = {
    where: UserApplianceWhereUniqueInput
    update: XOR<UserApplianceUpdateWithoutApplianceInput, UserApplianceUncheckedUpdateWithoutApplianceInput>
    create: XOR<UserApplianceCreateWithoutApplianceInput, UserApplianceUncheckedCreateWithoutApplianceInput>
  }

  export type UserApplianceUpdateWithWhereUniqueWithoutApplianceInput = {
    where: UserApplianceWhereUniqueInput
    data: XOR<UserApplianceUpdateWithoutApplianceInput, UserApplianceUncheckedUpdateWithoutApplianceInput>
  }

  export type UserApplianceUpdateManyWithWhereWithoutApplianceInput = {
    where: UserApplianceScalarWhereInput
    data: XOR<UserApplianceUpdateManyMutationInput, UserApplianceUncheckedUpdateManyWithoutApplianceInput>
  }

  export type UserPreferencesCreateWithoutAppliancesInput = {
    id?: string
    cookingSkillLevel?: $Enums.CookingSkill
    maxPrepTimeMinutes?: number
    budgetRange?: $Enums.BudgetRange
    householdSize?: number
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: number
    snacksPerDay?: number
    batchCookingPreference?: boolean
    energyRestrictionGoal?: string | null
    targetCaloriesMin?: number | null
    targetCaloriesMax?: number | null
    cuisinePreferences?: string | null
    spiceTolerance?: number
    flavorIntensity?: number
    knifeSkillLevel?: string
    preferredTechniques?: string | null
    recipeComplexityComfort?: number
    weeklyFoodBudget?: number | null
    shoppingFrequency?: string
    mealPlanningApproach?: number
    textureLimitations?: string | null
    foodsToAvoid?: string | null
    mealTimingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPreferencesInput
    behaviorProfile?: UserBehaviorCreateNestedOneWithoutUserPreferencesInput
  }

  export type UserPreferencesUncheckedCreateWithoutAppliancesInput = {
    id?: string
    userId: string
    cookingSkillLevel?: $Enums.CookingSkill
    maxPrepTimeMinutes?: number
    budgetRange?: $Enums.BudgetRange
    householdSize?: number
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: number
    snacksPerDay?: number
    batchCookingPreference?: boolean
    energyRestrictionGoal?: string | null
    targetCaloriesMin?: number | null
    targetCaloriesMax?: number | null
    cuisinePreferences?: string | null
    spiceTolerance?: number
    flavorIntensity?: number
    knifeSkillLevel?: string
    preferredTechniques?: string | null
    recipeComplexityComfort?: number
    weeklyFoodBudget?: number | null
    shoppingFrequency?: string
    mealPlanningApproach?: number
    textureLimitations?: string | null
    foodsToAvoid?: string | null
    mealTimingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    behaviorProfile?: UserBehaviorUncheckedCreateNestedOneWithoutUserPreferencesInput
  }

  export type UserPreferencesCreateOrConnectWithoutAppliancesInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutAppliancesInput, UserPreferencesUncheckedCreateWithoutAppliancesInput>
  }

  export type ApplianceCreateWithoutUsersInput = {
    id?: string
    name: string
    displayName: string
    category: string
  }

  export type ApplianceUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    displayName: string
    category: string
  }

  export type ApplianceCreateOrConnectWithoutUsersInput = {
    where: ApplianceWhereUniqueInput
    create: XOR<ApplianceCreateWithoutUsersInput, ApplianceUncheckedCreateWithoutUsersInput>
  }

  export type UserPreferencesUpsertWithoutAppliancesInput = {
    update: XOR<UserPreferencesUpdateWithoutAppliancesInput, UserPreferencesUncheckedUpdateWithoutAppliancesInput>
    create: XOR<UserPreferencesCreateWithoutAppliancesInput, UserPreferencesUncheckedCreateWithoutAppliancesInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutAppliancesInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutAppliancesInput, UserPreferencesUncheckedUpdateWithoutAppliancesInput>
  }

  export type UserPreferencesUpdateWithoutAppliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
    behaviorProfile?: UserBehaviorUpdateOneWithoutUserPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateWithoutAppliancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    behaviorProfile?: UserBehaviorUncheckedUpdateOneWithoutUserPreferencesNestedInput
  }

  export type ApplianceUpsertWithoutUsersInput = {
    update: XOR<ApplianceUpdateWithoutUsersInput, ApplianceUncheckedUpdateWithoutUsersInput>
    create: XOR<ApplianceCreateWithoutUsersInput, ApplianceUncheckedCreateWithoutUsersInput>
    where?: ApplianceWhereInput
  }

  export type ApplianceUpdateToOneWithWhereWithoutUsersInput = {
    where?: ApplianceWhereInput
    data: XOR<ApplianceUpdateWithoutUsersInput, ApplianceUncheckedUpdateWithoutUsersInput>
  }

  export type ApplianceUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type ApplianceUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type UserPreferencesCreateWithoutBehaviorProfileInput = {
    id?: string
    cookingSkillLevel?: $Enums.CookingSkill
    maxPrepTimeMinutes?: number
    budgetRange?: $Enums.BudgetRange
    householdSize?: number
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: number
    snacksPerDay?: number
    batchCookingPreference?: boolean
    energyRestrictionGoal?: string | null
    targetCaloriesMin?: number | null
    targetCaloriesMax?: number | null
    cuisinePreferences?: string | null
    spiceTolerance?: number
    flavorIntensity?: number
    knifeSkillLevel?: string
    preferredTechniques?: string | null
    recipeComplexityComfort?: number
    weeklyFoodBudget?: number | null
    shoppingFrequency?: string
    mealPlanningApproach?: number
    textureLimitations?: string | null
    foodsToAvoid?: string | null
    mealTimingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPreferencesInput
    appliances?: UserApplianceCreateNestedManyWithoutUserPreferencesInput
  }

  export type UserPreferencesUncheckedCreateWithoutBehaviorProfileInput = {
    id?: string
    userId: string
    cookingSkillLevel?: $Enums.CookingSkill
    maxPrepTimeMinutes?: number
    budgetRange?: $Enums.BudgetRange
    householdSize?: number
    hasOven?: boolean
    hasStove?: boolean
    hasMicrowave?: boolean
    hasBlender?: boolean
    hasAirFryer?: boolean
    hasSlowCooker?: boolean
    hasInstantPot?: boolean
    mealsPerDay?: number
    snacksPerDay?: number
    batchCookingPreference?: boolean
    energyRestrictionGoal?: string | null
    targetCaloriesMin?: number | null
    targetCaloriesMax?: number | null
    cuisinePreferences?: string | null
    spiceTolerance?: number
    flavorIntensity?: number
    knifeSkillLevel?: string
    preferredTechniques?: string | null
    recipeComplexityComfort?: number
    weeklyFoodBudget?: number | null
    shoppingFrequency?: string
    mealPlanningApproach?: number
    textureLimitations?: string | null
    foodsToAvoid?: string | null
    mealTimingPreference?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appliances?: UserApplianceUncheckedCreateNestedManyWithoutUserPreferencesInput
  }

  export type UserPreferencesCreateOrConnectWithoutBehaviorProfileInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutBehaviorProfileInput, UserPreferencesUncheckedCreateWithoutBehaviorProfileInput>
  }

  export type UserPreferencesUpsertWithoutBehaviorProfileInput = {
    update: XOR<UserPreferencesUpdateWithoutBehaviorProfileInput, UserPreferencesUncheckedUpdateWithoutBehaviorProfileInput>
    create: XOR<UserPreferencesCreateWithoutBehaviorProfileInput, UserPreferencesUncheckedCreateWithoutBehaviorProfileInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutBehaviorProfileInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutBehaviorProfileInput, UserPreferencesUncheckedUpdateWithoutBehaviorProfileInput>
  }

  export type UserPreferencesUpdateWithoutBehaviorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
    appliances?: UserApplianceUpdateManyWithoutUserPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateWithoutBehaviorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cookingSkillLevel?: EnumCookingSkillFieldUpdateOperationsInput | $Enums.CookingSkill
    maxPrepTimeMinutes?: IntFieldUpdateOperationsInput | number
    budgetRange?: EnumBudgetRangeFieldUpdateOperationsInput | $Enums.BudgetRange
    householdSize?: IntFieldUpdateOperationsInput | number
    hasOven?: BoolFieldUpdateOperationsInput | boolean
    hasStove?: BoolFieldUpdateOperationsInput | boolean
    hasMicrowave?: BoolFieldUpdateOperationsInput | boolean
    hasBlender?: BoolFieldUpdateOperationsInput | boolean
    hasAirFryer?: BoolFieldUpdateOperationsInput | boolean
    hasSlowCooker?: BoolFieldUpdateOperationsInput | boolean
    hasInstantPot?: BoolFieldUpdateOperationsInput | boolean
    mealsPerDay?: IntFieldUpdateOperationsInput | number
    snacksPerDay?: IntFieldUpdateOperationsInput | number
    batchCookingPreference?: BoolFieldUpdateOperationsInput | boolean
    energyRestrictionGoal?: NullableStringFieldUpdateOperationsInput | string | null
    targetCaloriesMin?: NullableIntFieldUpdateOperationsInput | number | null
    targetCaloriesMax?: NullableIntFieldUpdateOperationsInput | number | null
    cuisinePreferences?: NullableStringFieldUpdateOperationsInput | string | null
    spiceTolerance?: IntFieldUpdateOperationsInput | number
    flavorIntensity?: IntFieldUpdateOperationsInput | number
    knifeSkillLevel?: StringFieldUpdateOperationsInput | string
    preferredTechniques?: NullableStringFieldUpdateOperationsInput | string | null
    recipeComplexityComfort?: IntFieldUpdateOperationsInput | number
    weeklyFoodBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    shoppingFrequency?: StringFieldUpdateOperationsInput | string
    mealPlanningApproach?: IntFieldUpdateOperationsInput | number
    textureLimitations?: NullableStringFieldUpdateOperationsInput | string | null
    foodsToAvoid?: NullableStringFieldUpdateOperationsInput | string | null
    mealTimingPreference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appliances?: UserApplianceUncheckedUpdateManyWithoutUserPreferencesNestedInput
  }

  export type RecipeSpiceBlendCreateWithoutSpiceBlendInput = {
    id?: string
    amountGrams: number
    recipe: RecipeCreateNestedOneWithoutSpiceBlendsInput
  }

  export type RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput = {
    id?: string
    recipeId: string
    amountGrams: number
  }

  export type RecipeSpiceBlendCreateOrConnectWithoutSpiceBlendInput = {
    where: RecipeSpiceBlendWhereUniqueInput
    create: XOR<RecipeSpiceBlendCreateWithoutSpiceBlendInput, RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput>
  }

  export type RecipeSpiceBlendCreateManySpiceBlendInputEnvelope = {
    data: RecipeSpiceBlendCreateManySpiceBlendInput | RecipeSpiceBlendCreateManySpiceBlendInput[]
  }

  export type RecipeSpiceBlendUpsertWithWhereUniqueWithoutSpiceBlendInput = {
    where: RecipeSpiceBlendWhereUniqueInput
    update: XOR<RecipeSpiceBlendUpdateWithoutSpiceBlendInput, RecipeSpiceBlendUncheckedUpdateWithoutSpiceBlendInput>
    create: XOR<RecipeSpiceBlendCreateWithoutSpiceBlendInput, RecipeSpiceBlendUncheckedCreateWithoutSpiceBlendInput>
  }

  export type RecipeSpiceBlendUpdateWithWhereUniqueWithoutSpiceBlendInput = {
    where: RecipeSpiceBlendWhereUniqueInput
    data: XOR<RecipeSpiceBlendUpdateWithoutSpiceBlendInput, RecipeSpiceBlendUncheckedUpdateWithoutSpiceBlendInput>
  }

  export type RecipeSpiceBlendUpdateManyWithWhereWithoutSpiceBlendInput = {
    where: RecipeSpiceBlendScalarWhereInput
    data: XOR<RecipeSpiceBlendUpdateManyMutationInput, RecipeSpiceBlendUncheckedUpdateManyWithoutSpiceBlendInput>
  }

  export type RecipeSpiceBlendScalarWhereInput = {
    AND?: RecipeSpiceBlendScalarWhereInput | RecipeSpiceBlendScalarWhereInput[]
    OR?: RecipeSpiceBlendScalarWhereInput[]
    NOT?: RecipeSpiceBlendScalarWhereInput | RecipeSpiceBlendScalarWhereInput[]
    id?: StringFilter<"RecipeSpiceBlend"> | string
    recipeId?: StringFilter<"RecipeSpiceBlend"> | string
    spiceBlendId?: StringFilter<"RecipeSpiceBlend"> | string
    amountGrams?: FloatFilter<"RecipeSpiceBlend"> | number
  }

  export type RecipeCreateWithoutSpiceBlendsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutSpiceBlendsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutSpiceBlendsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutSpiceBlendsInput, RecipeUncheckedCreateWithoutSpiceBlendsInput>
  }

  export type SpiceBlendCreateWithoutRecipesInput = {
    id?: string
    name: string
    displayName: string
    activeCompounds: string
    clinicalEvidence: string
    primaryBenefit: string
    effectiveDoseGrams: number
    bioavailabilityHack?: string | null
    quickApplications: string
  }

  export type SpiceBlendUncheckedCreateWithoutRecipesInput = {
    id?: string
    name: string
    displayName: string
    activeCompounds: string
    clinicalEvidence: string
    primaryBenefit: string
    effectiveDoseGrams: number
    bioavailabilityHack?: string | null
    quickApplications: string
  }

  export type SpiceBlendCreateOrConnectWithoutRecipesInput = {
    where: SpiceBlendWhereUniqueInput
    create: XOR<SpiceBlendCreateWithoutRecipesInput, SpiceBlendUncheckedCreateWithoutRecipesInput>
  }

  export type RecipeUpsertWithoutSpiceBlendsInput = {
    update: XOR<RecipeUpdateWithoutSpiceBlendsInput, RecipeUncheckedUpdateWithoutSpiceBlendsInput>
    create: XOR<RecipeCreateWithoutSpiceBlendsInput, RecipeUncheckedCreateWithoutSpiceBlendsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutSpiceBlendsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutSpiceBlendsInput, RecipeUncheckedUpdateWithoutSpiceBlendsInput>
  }

  export type RecipeUpdateWithoutSpiceBlendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutSpiceBlendsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type SpiceBlendUpsertWithoutRecipesInput = {
    update: XOR<SpiceBlendUpdateWithoutRecipesInput, SpiceBlendUncheckedUpdateWithoutRecipesInput>
    create: XOR<SpiceBlendCreateWithoutRecipesInput, SpiceBlendUncheckedCreateWithoutRecipesInput>
    where?: SpiceBlendWhereInput
  }

  export type SpiceBlendUpdateToOneWithWhereWithoutRecipesInput = {
    where?: SpiceBlendWhereInput
    data: XOR<SpiceBlendUpdateWithoutRecipesInput, SpiceBlendUncheckedUpdateWithoutRecipesInput>
  }

  export type SpiceBlendUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    activeCompounds?: StringFieldUpdateOperationsInput | string
    clinicalEvidence?: StringFieldUpdateOperationsInput | string
    primaryBenefit?: StringFieldUpdateOperationsInput | string
    effectiveDoseGrams?: FloatFieldUpdateOperationsInput | number
    bioavailabilityHack?: NullableStringFieldUpdateOperationsInput | string | null
    quickApplications?: StringFieldUpdateOperationsInput | string
  }

  export type SpiceBlendUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    activeCompounds?: StringFieldUpdateOperationsInput | string
    clinicalEvidence?: StringFieldUpdateOperationsInput | string
    primaryBenefit?: StringFieldUpdateOperationsInput | string
    effectiveDoseGrams?: FloatFieldUpdateOperationsInput | number
    bioavailabilityHack?: NullableStringFieldUpdateOperationsInput | string | null
    quickApplications?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeIngredientCreateWithoutRecipeInput = {
    id?: string
    name: string
    amount: number
    unit: string
    notes?: string | null
  }

  export type RecipeIngredientUncheckedCreateWithoutRecipeInput = {
    id?: string
    name: string
    amount: number
    unit: string
    notes?: string | null
  }

  export type RecipeIngredientCreateOrConnectWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientCreateManyRecipeInputEnvelope = {
    data: RecipeIngredientCreateManyRecipeInput | RecipeIngredientCreateManyRecipeInput[]
  }

  export type RecipeInstructionCreateWithoutRecipeInput = {
    id?: string
    stepNumber: number
    instruction: string
  }

  export type RecipeInstructionUncheckedCreateWithoutRecipeInput = {
    id?: string
    stepNumber: number
    instruction: string
  }

  export type RecipeInstructionCreateOrConnectWithoutRecipeInput = {
    where: RecipeInstructionWhereUniqueInput
    create: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeInstructionCreateManyRecipeInputEnvelope = {
    data: RecipeInstructionCreateManyRecipeInput | RecipeInstructionCreateManyRecipeInput[]
  }

  export type RecipeMedicalTagCreateWithoutRecipeInput = {
    id?: string
    medicalTag: MedicalTagCreateNestedOneWithoutRecipesInput
  }

  export type RecipeMedicalTagUncheckedCreateWithoutRecipeInput = {
    id?: string
    medicalTagId: string
  }

  export type RecipeMedicalTagCreateOrConnectWithoutRecipeInput = {
    where: RecipeMedicalTagWhereUniqueInput
    create: XOR<RecipeMedicalTagCreateWithoutRecipeInput, RecipeMedicalTagUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeMedicalTagCreateManyRecipeInputEnvelope = {
    data: RecipeMedicalTagCreateManyRecipeInput | RecipeMedicalTagCreateManyRecipeInput[]
  }

  export type RecipeDietaryTagCreateWithoutRecipeInput = {
    id?: string
    dietaryTag: DietaryTagCreateNestedOneWithoutRecipesInput
  }

  export type RecipeDietaryTagUncheckedCreateWithoutRecipeInput = {
    id?: string
    dietaryTagId: string
  }

  export type RecipeDietaryTagCreateOrConnectWithoutRecipeInput = {
    where: RecipeDietaryTagWhereUniqueInput
    create: XOR<RecipeDietaryTagCreateWithoutRecipeInput, RecipeDietaryTagUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeDietaryTagCreateManyRecipeInputEnvelope = {
    data: RecipeDietaryTagCreateManyRecipeInput | RecipeDietaryTagCreateManyRecipeInput[]
  }

  export type RecipePracticalTagCreateWithoutRecipeInput = {
    id?: string
    practicalTag: PracticalTagCreateNestedOneWithoutRecipesInput
  }

  export type RecipePracticalTagUncheckedCreateWithoutRecipeInput = {
    id?: string
    practicalTagId: string
  }

  export type RecipePracticalTagCreateOrConnectWithoutRecipeInput = {
    where: RecipePracticalTagWhereUniqueInput
    create: XOR<RecipePracticalTagCreateWithoutRecipeInput, RecipePracticalTagUncheckedCreateWithoutRecipeInput>
  }

  export type RecipePracticalTagCreateManyRecipeInputEnvelope = {
    data: RecipePracticalTagCreateManyRecipeInput | RecipePracticalTagCreateManyRecipeInput[]
  }

  export type RecipeNutritionalTagCreateWithoutRecipeInput = {
    id?: string
    nutritionalTag: NutritionalTagCreateNestedOneWithoutRecipesInput
  }

  export type RecipeNutritionalTagUncheckedCreateWithoutRecipeInput = {
    id?: string
    nutritionalTagId: string
  }

  export type RecipeNutritionalTagCreateOrConnectWithoutRecipeInput = {
    where: RecipeNutritionalTagWhereUniqueInput
    create: XOR<RecipeNutritionalTagCreateWithoutRecipeInput, RecipeNutritionalTagUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeNutritionalTagCreateManyRecipeInputEnvelope = {
    data: RecipeNutritionalTagCreateManyRecipeInput | RecipeNutritionalTagCreateManyRecipeInput[]
  }

  export type RecipeSpiceBlendCreateWithoutRecipeInput = {
    id?: string
    amountGrams: number
    spiceBlend: SpiceBlendCreateNestedOneWithoutRecipesInput
  }

  export type RecipeSpiceBlendUncheckedCreateWithoutRecipeInput = {
    id?: string
    spiceBlendId: string
    amountGrams: number
  }

  export type RecipeSpiceBlendCreateOrConnectWithoutRecipeInput = {
    where: RecipeSpiceBlendWhereUniqueInput
    create: XOR<RecipeSpiceBlendCreateWithoutRecipeInput, RecipeSpiceBlendUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeSpiceBlendCreateManyRecipeInputEnvelope = {
    data: RecipeSpiceBlendCreateManyRecipeInput | RecipeSpiceBlendCreateManyRecipeInput[]
  }

  export type NutritionalInfoCreateWithoutRecipeInput = {
    id?: string
    calories?: number | null
    protein?: number | null
    carbohydrates?: number | null
    fat?: number | null
    fiber?: number | null
    sugar?: number | null
    sodium?: number | null
    cholesterol?: number | null
    vitaminC?: number | null
    vitaminD?: number | null
    calcium?: number | null
    iron?: number | null
    potassium?: number | null
  }

  export type NutritionalInfoUncheckedCreateWithoutRecipeInput = {
    id?: string
    calories?: number | null
    protein?: number | null
    carbohydrates?: number | null
    fat?: number | null
    fiber?: number | null
    sugar?: number | null
    sodium?: number | null
    cholesterol?: number | null
    vitaminC?: number | null
    vitaminD?: number | null
    calcium?: number | null
    iron?: number | null
    potassium?: number | null
  }

  export type NutritionalInfoCreateOrConnectWithoutRecipeInput = {
    where: NutritionalInfoWhereUniqueInput
    create: XOR<NutritionalInfoCreateWithoutRecipeInput, NutritionalInfoUncheckedCreateWithoutRecipeInput>
  }

  export type UserFavoriteRecipeCreateWithoutRecipeInput = {
    id?: string
    addedAt?: Date | string
    user: UserCreateNestedOneWithoutFavoriteRecipesInput
  }

  export type UserFavoriteRecipeUncheckedCreateWithoutRecipeInput = {
    id?: string
    userId: string
    addedAt?: Date | string
  }

  export type UserFavoriteRecipeCreateOrConnectWithoutRecipeInput = {
    where: UserFavoriteRecipeWhereUniqueInput
    create: XOR<UserFavoriteRecipeCreateWithoutRecipeInput, UserFavoriteRecipeUncheckedCreateWithoutRecipeInput>
  }

  export type UserFavoriteRecipeCreateManyRecipeInputEnvelope = {
    data: UserFavoriteRecipeCreateManyRecipeInput | UserFavoriteRecipeCreateManyRecipeInput[]
  }

  export type MealPlanItemCreateWithoutRecipeInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings?: number
    mealPlan: MealPlanCreateNestedOneWithoutMealsInput
  }

  export type MealPlanItemUncheckedCreateWithoutRecipeInput = {
    id?: string
    mealPlanId: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings?: number
  }

  export type MealPlanItemCreateOrConnectWithoutRecipeInput = {
    where: MealPlanItemWhereUniqueInput
    create: XOR<MealPlanItemCreateWithoutRecipeInput, MealPlanItemUncheckedCreateWithoutRecipeInput>
  }

  export type MealPlanItemCreateManyRecipeInputEnvelope = {
    data: MealPlanItemCreateManyRecipeInput | MealPlanItemCreateManyRecipeInput[]
  }

  export type FeedbackCreateWithoutRecipeInput = {
    id?: string
    rating: number
    notes?: string | null
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateWithoutRecipeInput = {
    id?: string
    userId: string
    rating: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutRecipeInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutRecipeInput, FeedbackUncheckedCreateWithoutRecipeInput>
  }

  export type FeedbackCreateManyRecipeInputEnvelope = {
    data: FeedbackCreateManyRecipeInput | FeedbackCreateManyRecipeInput[]
  }

  export type RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    update: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    data: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeIngredientScalarWhereInput
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeIngredientScalarWhereInput = {
    AND?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    OR?: RecipeIngredientScalarWhereInput[]
    NOT?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    id?: StringFilter<"RecipeIngredient"> | string
    recipeId?: StringFilter<"RecipeIngredient"> | string
    name?: StringFilter<"RecipeIngredient"> | string
    amount?: FloatFilter<"RecipeIngredient"> | number
    unit?: StringFilter<"RecipeIngredient"> | string
    notes?: StringNullableFilter<"RecipeIngredient"> | string | null
  }

  export type RecipeInstructionUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeInstructionWhereUniqueInput
    update: XOR<RecipeInstructionUpdateWithoutRecipeInput, RecipeInstructionUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeInstructionCreateWithoutRecipeInput, RecipeInstructionUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeInstructionUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeInstructionWhereUniqueInput
    data: XOR<RecipeInstructionUpdateWithoutRecipeInput, RecipeInstructionUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeInstructionUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeInstructionScalarWhereInput
    data: XOR<RecipeInstructionUpdateManyMutationInput, RecipeInstructionUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeInstructionScalarWhereInput = {
    AND?: RecipeInstructionScalarWhereInput | RecipeInstructionScalarWhereInput[]
    OR?: RecipeInstructionScalarWhereInput[]
    NOT?: RecipeInstructionScalarWhereInput | RecipeInstructionScalarWhereInput[]
    id?: StringFilter<"RecipeInstruction"> | string
    recipeId?: StringFilter<"RecipeInstruction"> | string
    stepNumber?: IntFilter<"RecipeInstruction"> | number
    instruction?: StringFilter<"RecipeInstruction"> | string
  }

  export type RecipeMedicalTagUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeMedicalTagWhereUniqueInput
    update: XOR<RecipeMedicalTagUpdateWithoutRecipeInput, RecipeMedicalTagUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeMedicalTagCreateWithoutRecipeInput, RecipeMedicalTagUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeMedicalTagUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeMedicalTagWhereUniqueInput
    data: XOR<RecipeMedicalTagUpdateWithoutRecipeInput, RecipeMedicalTagUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeMedicalTagUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeMedicalTagScalarWhereInput
    data: XOR<RecipeMedicalTagUpdateManyMutationInput, RecipeMedicalTagUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeMedicalTagScalarWhereInput = {
    AND?: RecipeMedicalTagScalarWhereInput | RecipeMedicalTagScalarWhereInput[]
    OR?: RecipeMedicalTagScalarWhereInput[]
    NOT?: RecipeMedicalTagScalarWhereInput | RecipeMedicalTagScalarWhereInput[]
    id?: StringFilter<"RecipeMedicalTag"> | string
    recipeId?: StringFilter<"RecipeMedicalTag"> | string
    medicalTagId?: StringFilter<"RecipeMedicalTag"> | string
  }

  export type RecipeDietaryTagUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeDietaryTagWhereUniqueInput
    update: XOR<RecipeDietaryTagUpdateWithoutRecipeInput, RecipeDietaryTagUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeDietaryTagCreateWithoutRecipeInput, RecipeDietaryTagUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeDietaryTagUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeDietaryTagWhereUniqueInput
    data: XOR<RecipeDietaryTagUpdateWithoutRecipeInput, RecipeDietaryTagUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeDietaryTagUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeDietaryTagScalarWhereInput
    data: XOR<RecipeDietaryTagUpdateManyMutationInput, RecipeDietaryTagUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeDietaryTagScalarWhereInput = {
    AND?: RecipeDietaryTagScalarWhereInput | RecipeDietaryTagScalarWhereInput[]
    OR?: RecipeDietaryTagScalarWhereInput[]
    NOT?: RecipeDietaryTagScalarWhereInput | RecipeDietaryTagScalarWhereInput[]
    id?: StringFilter<"RecipeDietaryTag"> | string
    recipeId?: StringFilter<"RecipeDietaryTag"> | string
    dietaryTagId?: StringFilter<"RecipeDietaryTag"> | string
  }

  export type RecipePracticalTagUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipePracticalTagWhereUniqueInput
    update: XOR<RecipePracticalTagUpdateWithoutRecipeInput, RecipePracticalTagUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipePracticalTagCreateWithoutRecipeInput, RecipePracticalTagUncheckedCreateWithoutRecipeInput>
  }

  export type RecipePracticalTagUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipePracticalTagWhereUniqueInput
    data: XOR<RecipePracticalTagUpdateWithoutRecipeInput, RecipePracticalTagUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipePracticalTagUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipePracticalTagScalarWhereInput
    data: XOR<RecipePracticalTagUpdateManyMutationInput, RecipePracticalTagUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipePracticalTagScalarWhereInput = {
    AND?: RecipePracticalTagScalarWhereInput | RecipePracticalTagScalarWhereInput[]
    OR?: RecipePracticalTagScalarWhereInput[]
    NOT?: RecipePracticalTagScalarWhereInput | RecipePracticalTagScalarWhereInput[]
    id?: StringFilter<"RecipePracticalTag"> | string
    recipeId?: StringFilter<"RecipePracticalTag"> | string
    practicalTagId?: StringFilter<"RecipePracticalTag"> | string
  }

  export type RecipeNutritionalTagUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeNutritionalTagWhereUniqueInput
    update: XOR<RecipeNutritionalTagUpdateWithoutRecipeInput, RecipeNutritionalTagUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeNutritionalTagCreateWithoutRecipeInput, RecipeNutritionalTagUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeNutritionalTagUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeNutritionalTagWhereUniqueInput
    data: XOR<RecipeNutritionalTagUpdateWithoutRecipeInput, RecipeNutritionalTagUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeNutritionalTagUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeNutritionalTagScalarWhereInput
    data: XOR<RecipeNutritionalTagUpdateManyMutationInput, RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeNutritionalTagScalarWhereInput = {
    AND?: RecipeNutritionalTagScalarWhereInput | RecipeNutritionalTagScalarWhereInput[]
    OR?: RecipeNutritionalTagScalarWhereInput[]
    NOT?: RecipeNutritionalTagScalarWhereInput | RecipeNutritionalTagScalarWhereInput[]
    id?: StringFilter<"RecipeNutritionalTag"> | string
    recipeId?: StringFilter<"RecipeNutritionalTag"> | string
    nutritionalTagId?: StringFilter<"RecipeNutritionalTag"> | string
  }

  export type RecipeSpiceBlendUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeSpiceBlendWhereUniqueInput
    update: XOR<RecipeSpiceBlendUpdateWithoutRecipeInput, RecipeSpiceBlendUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeSpiceBlendCreateWithoutRecipeInput, RecipeSpiceBlendUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeSpiceBlendUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeSpiceBlendWhereUniqueInput
    data: XOR<RecipeSpiceBlendUpdateWithoutRecipeInput, RecipeSpiceBlendUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeSpiceBlendUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeSpiceBlendScalarWhereInput
    data: XOR<RecipeSpiceBlendUpdateManyMutationInput, RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeInput>
  }

  export type NutritionalInfoUpsertWithoutRecipeInput = {
    update: XOR<NutritionalInfoUpdateWithoutRecipeInput, NutritionalInfoUncheckedUpdateWithoutRecipeInput>
    create: XOR<NutritionalInfoCreateWithoutRecipeInput, NutritionalInfoUncheckedCreateWithoutRecipeInput>
    where?: NutritionalInfoWhereInput
  }

  export type NutritionalInfoUpdateToOneWithWhereWithoutRecipeInput = {
    where?: NutritionalInfoWhereInput
    data: XOR<NutritionalInfoUpdateWithoutRecipeInput, NutritionalInfoUncheckedUpdateWithoutRecipeInput>
  }

  export type NutritionalInfoUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    calories?: NullableFloatFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbohydrates?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    fiber?: NullableFloatFieldUpdateOperationsInput | number | null
    sugar?: NullableFloatFieldUpdateOperationsInput | number | null
    sodium?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesterol?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminC?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminD?: NullableFloatFieldUpdateOperationsInput | number | null
    calcium?: NullableFloatFieldUpdateOperationsInput | number | null
    iron?: NullableFloatFieldUpdateOperationsInput | number | null
    potassium?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type NutritionalInfoUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    calories?: NullableFloatFieldUpdateOperationsInput | number | null
    protein?: NullableFloatFieldUpdateOperationsInput | number | null
    carbohydrates?: NullableFloatFieldUpdateOperationsInput | number | null
    fat?: NullableFloatFieldUpdateOperationsInput | number | null
    fiber?: NullableFloatFieldUpdateOperationsInput | number | null
    sugar?: NullableFloatFieldUpdateOperationsInput | number | null
    sodium?: NullableFloatFieldUpdateOperationsInput | number | null
    cholesterol?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminC?: NullableFloatFieldUpdateOperationsInput | number | null
    vitaminD?: NullableFloatFieldUpdateOperationsInput | number | null
    calcium?: NullableFloatFieldUpdateOperationsInput | number | null
    iron?: NullableFloatFieldUpdateOperationsInput | number | null
    potassium?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserFavoriteRecipeUpsertWithWhereUniqueWithoutRecipeInput = {
    where: UserFavoriteRecipeWhereUniqueInput
    update: XOR<UserFavoriteRecipeUpdateWithoutRecipeInput, UserFavoriteRecipeUncheckedUpdateWithoutRecipeInput>
    create: XOR<UserFavoriteRecipeCreateWithoutRecipeInput, UserFavoriteRecipeUncheckedCreateWithoutRecipeInput>
  }

  export type UserFavoriteRecipeUpdateWithWhereUniqueWithoutRecipeInput = {
    where: UserFavoriteRecipeWhereUniqueInput
    data: XOR<UserFavoriteRecipeUpdateWithoutRecipeInput, UserFavoriteRecipeUncheckedUpdateWithoutRecipeInput>
  }

  export type UserFavoriteRecipeUpdateManyWithWhereWithoutRecipeInput = {
    where: UserFavoriteRecipeScalarWhereInput
    data: XOR<UserFavoriteRecipeUpdateManyMutationInput, UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeInput>
  }

  export type MealPlanItemUpsertWithWhereUniqueWithoutRecipeInput = {
    where: MealPlanItemWhereUniqueInput
    update: XOR<MealPlanItemUpdateWithoutRecipeInput, MealPlanItemUncheckedUpdateWithoutRecipeInput>
    create: XOR<MealPlanItemCreateWithoutRecipeInput, MealPlanItemUncheckedCreateWithoutRecipeInput>
  }

  export type MealPlanItemUpdateWithWhereUniqueWithoutRecipeInput = {
    where: MealPlanItemWhereUniqueInput
    data: XOR<MealPlanItemUpdateWithoutRecipeInput, MealPlanItemUncheckedUpdateWithoutRecipeInput>
  }

  export type MealPlanItemUpdateManyWithWhereWithoutRecipeInput = {
    where: MealPlanItemScalarWhereInput
    data: XOR<MealPlanItemUpdateManyMutationInput, MealPlanItemUncheckedUpdateManyWithoutRecipeInput>
  }

  export type MealPlanItemScalarWhereInput = {
    AND?: MealPlanItemScalarWhereInput | MealPlanItemScalarWhereInput[]
    OR?: MealPlanItemScalarWhereInput[]
    NOT?: MealPlanItemScalarWhereInput | MealPlanItemScalarWhereInput[]
    id?: StringFilter<"MealPlanItem"> | string
    mealPlanId?: StringFilter<"MealPlanItem"> | string
    recipeId?: StringFilter<"MealPlanItem"> | string
    dayOfWeek?: EnumDayOfWeekFilter<"MealPlanItem"> | $Enums.DayOfWeek
    mealType?: EnumMealTypeFilter<"MealPlanItem"> | $Enums.MealType
    servings?: IntFilter<"MealPlanItem"> | number
  }

  export type FeedbackUpsertWithWhereUniqueWithoutRecipeInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutRecipeInput, FeedbackUncheckedUpdateWithoutRecipeInput>
    create: XOR<FeedbackCreateWithoutRecipeInput, FeedbackUncheckedCreateWithoutRecipeInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutRecipeInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutRecipeInput, FeedbackUncheckedUpdateWithoutRecipeInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutRecipeInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeCreateWithoutIngredientsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutIngredientsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutIngredientsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
  }

  export type RecipeUpsertWithoutIngredientsInput = {
    update: XOR<RecipeUpdateWithoutIngredientsInput, RecipeUncheckedUpdateWithoutIngredientsInput>
    create: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutIngredientsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutIngredientsInput, RecipeUncheckedUpdateWithoutIngredientsInput>
  }

  export type RecipeUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateWithoutInstructionsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutInstructionsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutInstructionsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
  }

  export type RecipeUpsertWithoutInstructionsInput = {
    update: XOR<RecipeUpdateWithoutInstructionsInput, RecipeUncheckedUpdateWithoutInstructionsInput>
    create: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutInstructionsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutInstructionsInput, RecipeUncheckedUpdateWithoutInstructionsInput>
  }

  export type RecipeUpdateWithoutInstructionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutInstructionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateWithoutNutritionalInfoInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutNutritionalInfoInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutNutritionalInfoInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutNutritionalInfoInput, RecipeUncheckedCreateWithoutNutritionalInfoInput>
  }

  export type RecipeUpsertWithoutNutritionalInfoInput = {
    update: XOR<RecipeUpdateWithoutNutritionalInfoInput, RecipeUncheckedUpdateWithoutNutritionalInfoInput>
    create: XOR<RecipeCreateWithoutNutritionalInfoInput, RecipeUncheckedCreateWithoutNutritionalInfoInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutNutritionalInfoInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutNutritionalInfoInput, RecipeUncheckedUpdateWithoutNutritionalInfoInput>
  }

  export type RecipeUpdateWithoutNutritionalInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutNutritionalInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeMedicalTagCreateWithoutMedicalTagInput = {
    id?: string
    recipe: RecipeCreateNestedOneWithoutMedicalTagsInput
  }

  export type RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput = {
    id?: string
    recipeId: string
  }

  export type RecipeMedicalTagCreateOrConnectWithoutMedicalTagInput = {
    where: RecipeMedicalTagWhereUniqueInput
    create: XOR<RecipeMedicalTagCreateWithoutMedicalTagInput, RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput>
  }

  export type RecipeMedicalTagCreateManyMedicalTagInputEnvelope = {
    data: RecipeMedicalTagCreateManyMedicalTagInput | RecipeMedicalTagCreateManyMedicalTagInput[]
  }

  export type RecipeMedicalTagUpsertWithWhereUniqueWithoutMedicalTagInput = {
    where: RecipeMedicalTagWhereUniqueInput
    update: XOR<RecipeMedicalTagUpdateWithoutMedicalTagInput, RecipeMedicalTagUncheckedUpdateWithoutMedicalTagInput>
    create: XOR<RecipeMedicalTagCreateWithoutMedicalTagInput, RecipeMedicalTagUncheckedCreateWithoutMedicalTagInput>
  }

  export type RecipeMedicalTagUpdateWithWhereUniqueWithoutMedicalTagInput = {
    where: RecipeMedicalTagWhereUniqueInput
    data: XOR<RecipeMedicalTagUpdateWithoutMedicalTagInput, RecipeMedicalTagUncheckedUpdateWithoutMedicalTagInput>
  }

  export type RecipeMedicalTagUpdateManyWithWhereWithoutMedicalTagInput = {
    where: RecipeMedicalTagScalarWhereInput
    data: XOR<RecipeMedicalTagUpdateManyMutationInput, RecipeMedicalTagUncheckedUpdateManyWithoutMedicalTagInput>
  }

  export type RecipeCreateWithoutMedicalTagsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutMedicalTagsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutMedicalTagsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutMedicalTagsInput, RecipeUncheckedCreateWithoutMedicalTagsInput>
  }

  export type MedicalTagCreateWithoutRecipesInput = {
    id?: string
    name: string
    description?: string | null
    condition: string
  }

  export type MedicalTagUncheckedCreateWithoutRecipesInput = {
    id?: string
    name: string
    description?: string | null
    condition: string
  }

  export type MedicalTagCreateOrConnectWithoutRecipesInput = {
    where: MedicalTagWhereUniqueInput
    create: XOR<MedicalTagCreateWithoutRecipesInput, MedicalTagUncheckedCreateWithoutRecipesInput>
  }

  export type RecipeUpsertWithoutMedicalTagsInput = {
    update: XOR<RecipeUpdateWithoutMedicalTagsInput, RecipeUncheckedUpdateWithoutMedicalTagsInput>
    create: XOR<RecipeCreateWithoutMedicalTagsInput, RecipeUncheckedCreateWithoutMedicalTagsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutMedicalTagsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutMedicalTagsInput, RecipeUncheckedUpdateWithoutMedicalTagsInput>
  }

  export type RecipeUpdateWithoutMedicalTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutMedicalTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type MedicalTagUpsertWithoutRecipesInput = {
    update: XOR<MedicalTagUpdateWithoutRecipesInput, MedicalTagUncheckedUpdateWithoutRecipesInput>
    create: XOR<MedicalTagCreateWithoutRecipesInput, MedicalTagUncheckedCreateWithoutRecipesInput>
    where?: MedicalTagWhereInput
  }

  export type MedicalTagUpdateToOneWithWhereWithoutRecipesInput = {
    where?: MedicalTagWhereInput
    data: XOR<MedicalTagUpdateWithoutRecipesInput, MedicalTagUncheckedUpdateWithoutRecipesInput>
  }

  export type MedicalTagUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalTagUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeDietaryTagCreateWithoutDietaryTagInput = {
    id?: string
    recipe: RecipeCreateNestedOneWithoutDietaryTagsInput
  }

  export type RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput = {
    id?: string
    recipeId: string
  }

  export type RecipeDietaryTagCreateOrConnectWithoutDietaryTagInput = {
    where: RecipeDietaryTagWhereUniqueInput
    create: XOR<RecipeDietaryTagCreateWithoutDietaryTagInput, RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput>
  }

  export type RecipeDietaryTagCreateManyDietaryTagInputEnvelope = {
    data: RecipeDietaryTagCreateManyDietaryTagInput | RecipeDietaryTagCreateManyDietaryTagInput[]
  }

  export type RecipeDietaryTagUpsertWithWhereUniqueWithoutDietaryTagInput = {
    where: RecipeDietaryTagWhereUniqueInput
    update: XOR<RecipeDietaryTagUpdateWithoutDietaryTagInput, RecipeDietaryTagUncheckedUpdateWithoutDietaryTagInput>
    create: XOR<RecipeDietaryTagCreateWithoutDietaryTagInput, RecipeDietaryTagUncheckedCreateWithoutDietaryTagInput>
  }

  export type RecipeDietaryTagUpdateWithWhereUniqueWithoutDietaryTagInput = {
    where: RecipeDietaryTagWhereUniqueInput
    data: XOR<RecipeDietaryTagUpdateWithoutDietaryTagInput, RecipeDietaryTagUncheckedUpdateWithoutDietaryTagInput>
  }

  export type RecipeDietaryTagUpdateManyWithWhereWithoutDietaryTagInput = {
    where: RecipeDietaryTagScalarWhereInput
    data: XOR<RecipeDietaryTagUpdateManyMutationInput, RecipeDietaryTagUncheckedUpdateManyWithoutDietaryTagInput>
  }

  export type RecipeCreateWithoutDietaryTagsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutDietaryTagsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutDietaryTagsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutDietaryTagsInput, RecipeUncheckedCreateWithoutDietaryTagsInput>
  }

  export type DietaryTagCreateWithoutRecipesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.DietaryCategory
  }

  export type DietaryTagUncheckedCreateWithoutRecipesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.DietaryCategory
  }

  export type DietaryTagCreateOrConnectWithoutRecipesInput = {
    where: DietaryTagWhereUniqueInput
    create: XOR<DietaryTagCreateWithoutRecipesInput, DietaryTagUncheckedCreateWithoutRecipesInput>
  }

  export type RecipeUpsertWithoutDietaryTagsInput = {
    update: XOR<RecipeUpdateWithoutDietaryTagsInput, RecipeUncheckedUpdateWithoutDietaryTagsInput>
    create: XOR<RecipeCreateWithoutDietaryTagsInput, RecipeUncheckedCreateWithoutDietaryTagsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutDietaryTagsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutDietaryTagsInput, RecipeUncheckedUpdateWithoutDietaryTagsInput>
  }

  export type RecipeUpdateWithoutDietaryTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutDietaryTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type DietaryTagUpsertWithoutRecipesInput = {
    update: XOR<DietaryTagUpdateWithoutRecipesInput, DietaryTagUncheckedUpdateWithoutRecipesInput>
    create: XOR<DietaryTagCreateWithoutRecipesInput, DietaryTagUncheckedCreateWithoutRecipesInput>
    where?: DietaryTagWhereInput
  }

  export type DietaryTagUpdateToOneWithWhereWithoutRecipesInput = {
    where?: DietaryTagWhereInput
    data: XOR<DietaryTagUpdateWithoutRecipesInput, DietaryTagUncheckedUpdateWithoutRecipesInput>
  }

  export type DietaryTagUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDietaryCategoryFieldUpdateOperationsInput | $Enums.DietaryCategory
  }

  export type DietaryTagUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumDietaryCategoryFieldUpdateOperationsInput | $Enums.DietaryCategory
  }

  export type RecipePracticalTagCreateWithoutPracticalTagInput = {
    id?: string
    recipe: RecipeCreateNestedOneWithoutPracticalTagsInput
  }

  export type RecipePracticalTagUncheckedCreateWithoutPracticalTagInput = {
    id?: string
    recipeId: string
  }

  export type RecipePracticalTagCreateOrConnectWithoutPracticalTagInput = {
    where: RecipePracticalTagWhereUniqueInput
    create: XOR<RecipePracticalTagCreateWithoutPracticalTagInput, RecipePracticalTagUncheckedCreateWithoutPracticalTagInput>
  }

  export type RecipePracticalTagCreateManyPracticalTagInputEnvelope = {
    data: RecipePracticalTagCreateManyPracticalTagInput | RecipePracticalTagCreateManyPracticalTagInput[]
  }

  export type RecipePracticalTagUpsertWithWhereUniqueWithoutPracticalTagInput = {
    where: RecipePracticalTagWhereUniqueInput
    update: XOR<RecipePracticalTagUpdateWithoutPracticalTagInput, RecipePracticalTagUncheckedUpdateWithoutPracticalTagInput>
    create: XOR<RecipePracticalTagCreateWithoutPracticalTagInput, RecipePracticalTagUncheckedCreateWithoutPracticalTagInput>
  }

  export type RecipePracticalTagUpdateWithWhereUniqueWithoutPracticalTagInput = {
    where: RecipePracticalTagWhereUniqueInput
    data: XOR<RecipePracticalTagUpdateWithoutPracticalTagInput, RecipePracticalTagUncheckedUpdateWithoutPracticalTagInput>
  }

  export type RecipePracticalTagUpdateManyWithWhereWithoutPracticalTagInput = {
    where: RecipePracticalTagScalarWhereInput
    data: XOR<RecipePracticalTagUpdateManyMutationInput, RecipePracticalTagUncheckedUpdateManyWithoutPracticalTagInput>
  }

  export type RecipeCreateWithoutPracticalTagsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutPracticalTagsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutPracticalTagsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutPracticalTagsInput, RecipeUncheckedCreateWithoutPracticalTagsInput>
  }

  export type PracticalTagCreateWithoutRecipesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.PracticalCategory
  }

  export type PracticalTagUncheckedCreateWithoutRecipesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.PracticalCategory
  }

  export type PracticalTagCreateOrConnectWithoutRecipesInput = {
    where: PracticalTagWhereUniqueInput
    create: XOR<PracticalTagCreateWithoutRecipesInput, PracticalTagUncheckedCreateWithoutRecipesInput>
  }

  export type RecipeUpsertWithoutPracticalTagsInput = {
    update: XOR<RecipeUpdateWithoutPracticalTagsInput, RecipeUncheckedUpdateWithoutPracticalTagsInput>
    create: XOR<RecipeCreateWithoutPracticalTagsInput, RecipeUncheckedCreateWithoutPracticalTagsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutPracticalTagsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutPracticalTagsInput, RecipeUncheckedUpdateWithoutPracticalTagsInput>
  }

  export type RecipeUpdateWithoutPracticalTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutPracticalTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type PracticalTagUpsertWithoutRecipesInput = {
    update: XOR<PracticalTagUpdateWithoutRecipesInput, PracticalTagUncheckedUpdateWithoutRecipesInput>
    create: XOR<PracticalTagCreateWithoutRecipesInput, PracticalTagUncheckedCreateWithoutRecipesInput>
    where?: PracticalTagWhereInput
  }

  export type PracticalTagUpdateToOneWithWhereWithoutRecipesInput = {
    where?: PracticalTagWhereInput
    data: XOR<PracticalTagUpdateWithoutRecipesInput, PracticalTagUncheckedUpdateWithoutRecipesInput>
  }

  export type PracticalTagUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPracticalCategoryFieldUpdateOperationsInput | $Enums.PracticalCategory
  }

  export type PracticalTagUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPracticalCategoryFieldUpdateOperationsInput | $Enums.PracticalCategory
  }

  export type RecipeNutritionalTagCreateWithoutNutritionalTagInput = {
    id?: string
    recipe: RecipeCreateNestedOneWithoutNutritionalTagsInput
  }

  export type RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput = {
    id?: string
    recipeId: string
  }

  export type RecipeNutritionalTagCreateOrConnectWithoutNutritionalTagInput = {
    where: RecipeNutritionalTagWhereUniqueInput
    create: XOR<RecipeNutritionalTagCreateWithoutNutritionalTagInput, RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput>
  }

  export type RecipeNutritionalTagCreateManyNutritionalTagInputEnvelope = {
    data: RecipeNutritionalTagCreateManyNutritionalTagInput | RecipeNutritionalTagCreateManyNutritionalTagInput[]
  }

  export type RecipeNutritionalTagUpsertWithWhereUniqueWithoutNutritionalTagInput = {
    where: RecipeNutritionalTagWhereUniqueInput
    update: XOR<RecipeNutritionalTagUpdateWithoutNutritionalTagInput, RecipeNutritionalTagUncheckedUpdateWithoutNutritionalTagInput>
    create: XOR<RecipeNutritionalTagCreateWithoutNutritionalTagInput, RecipeNutritionalTagUncheckedCreateWithoutNutritionalTagInput>
  }

  export type RecipeNutritionalTagUpdateWithWhereUniqueWithoutNutritionalTagInput = {
    where: RecipeNutritionalTagWhereUniqueInput
    data: XOR<RecipeNutritionalTagUpdateWithoutNutritionalTagInput, RecipeNutritionalTagUncheckedUpdateWithoutNutritionalTagInput>
  }

  export type RecipeNutritionalTagUpdateManyWithWhereWithoutNutritionalTagInput = {
    where: RecipeNutritionalTagScalarWhereInput
    data: XOR<RecipeNutritionalTagUpdateManyMutationInput, RecipeNutritionalTagUncheckedUpdateManyWithoutNutritionalTagInput>
  }

  export type RecipeCreateWithoutNutritionalTagsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutNutritionalTagsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutNutritionalTagsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutNutritionalTagsInput, RecipeUncheckedCreateWithoutNutritionalTagsInput>
  }

  export type NutritionalTagCreateWithoutRecipesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.NutritionalCategory
  }

  export type NutritionalTagUncheckedCreateWithoutRecipesInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.NutritionalCategory
  }

  export type NutritionalTagCreateOrConnectWithoutRecipesInput = {
    where: NutritionalTagWhereUniqueInput
    create: XOR<NutritionalTagCreateWithoutRecipesInput, NutritionalTagUncheckedCreateWithoutRecipesInput>
  }

  export type RecipeUpsertWithoutNutritionalTagsInput = {
    update: XOR<RecipeUpdateWithoutNutritionalTagsInput, RecipeUncheckedUpdateWithoutNutritionalTagsInput>
    create: XOR<RecipeCreateWithoutNutritionalTagsInput, RecipeUncheckedCreateWithoutNutritionalTagsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutNutritionalTagsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutNutritionalTagsInput, RecipeUncheckedUpdateWithoutNutritionalTagsInput>
  }

  export type RecipeUpdateWithoutNutritionalTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutNutritionalTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type NutritionalTagUpsertWithoutRecipesInput = {
    update: XOR<NutritionalTagUpdateWithoutRecipesInput, NutritionalTagUncheckedUpdateWithoutRecipesInput>
    create: XOR<NutritionalTagCreateWithoutRecipesInput, NutritionalTagUncheckedCreateWithoutRecipesInput>
    where?: NutritionalTagWhereInput
  }

  export type NutritionalTagUpdateToOneWithWhereWithoutRecipesInput = {
    where?: NutritionalTagWhereInput
    data: XOR<NutritionalTagUpdateWithoutRecipesInput, NutritionalTagUncheckedUpdateWithoutRecipesInput>
  }

  export type NutritionalTagUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNutritionalCategoryFieldUpdateOperationsInput | $Enums.NutritionalCategory
  }

  export type NutritionalTagUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumNutritionalCategoryFieldUpdateOperationsInput | $Enums.NutritionalCategory
  }

  export type UserCreateWithoutMealPlansInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionCreateNestedManyWithoutUserInput
    allergies?: UserAllergyCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    shoppingLists?: ShoppingListCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    abTests?: ABTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMealPlansInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionUncheckedCreateNestedManyWithoutUserInput
    allergies?: UserAllergyUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    shoppingLists?: ShoppingListUncheckedCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    abTests?: ABTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMealPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMealPlansInput, UserUncheckedCreateWithoutMealPlansInput>
  }

  export type MealPlanItemCreateWithoutMealPlanInput = {
    id?: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings?: number
    recipe: RecipeCreateNestedOneWithoutMealPlanItemsInput
  }

  export type MealPlanItemUncheckedCreateWithoutMealPlanInput = {
    id?: string
    recipeId: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings?: number
  }

  export type MealPlanItemCreateOrConnectWithoutMealPlanInput = {
    where: MealPlanItemWhereUniqueInput
    create: XOR<MealPlanItemCreateWithoutMealPlanInput, MealPlanItemUncheckedCreateWithoutMealPlanInput>
  }

  export type MealPlanItemCreateManyMealPlanInputEnvelope = {
    data: MealPlanItemCreateManyMealPlanInput | MealPlanItemCreateManyMealPlanInput[]
  }

  export type ShoppingListCreateWithoutMealPlanInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShoppingListsInput
    items?: ShoppingListItemCreateNestedManyWithoutShoppingListInput
  }

  export type ShoppingListUncheckedCreateWithoutMealPlanInput = {
    id?: string
    userId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ShoppingListItemUncheckedCreateNestedManyWithoutShoppingListInput
  }

  export type ShoppingListCreateOrConnectWithoutMealPlanInput = {
    where: ShoppingListWhereUniqueInput
    create: XOR<ShoppingListCreateWithoutMealPlanInput, ShoppingListUncheckedCreateWithoutMealPlanInput>
  }

  export type UserUpsertWithoutMealPlansInput = {
    update: XOR<UserUpdateWithoutMealPlansInput, UserUncheckedUpdateWithoutMealPlansInput>
    create: XOR<UserCreateWithoutMealPlansInput, UserUncheckedCreateWithoutMealPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMealPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMealPlansInput, UserUncheckedUpdateWithoutMealPlansInput>
  }

  export type UserUpdateWithoutMealPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    shoppingLists?: ShoppingListUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    abTests?: ABTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMealPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    shoppingLists?: ShoppingListUncheckedUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    abTests?: ABTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MealPlanItemUpsertWithWhereUniqueWithoutMealPlanInput = {
    where: MealPlanItemWhereUniqueInput
    update: XOR<MealPlanItemUpdateWithoutMealPlanInput, MealPlanItemUncheckedUpdateWithoutMealPlanInput>
    create: XOR<MealPlanItemCreateWithoutMealPlanInput, MealPlanItemUncheckedCreateWithoutMealPlanInput>
  }

  export type MealPlanItemUpdateWithWhereUniqueWithoutMealPlanInput = {
    where: MealPlanItemWhereUniqueInput
    data: XOR<MealPlanItemUpdateWithoutMealPlanInput, MealPlanItemUncheckedUpdateWithoutMealPlanInput>
  }

  export type MealPlanItemUpdateManyWithWhereWithoutMealPlanInput = {
    where: MealPlanItemScalarWhereInput
    data: XOR<MealPlanItemUpdateManyMutationInput, MealPlanItemUncheckedUpdateManyWithoutMealPlanInput>
  }

  export type ShoppingListUpsertWithoutMealPlanInput = {
    update: XOR<ShoppingListUpdateWithoutMealPlanInput, ShoppingListUncheckedUpdateWithoutMealPlanInput>
    create: XOR<ShoppingListCreateWithoutMealPlanInput, ShoppingListUncheckedCreateWithoutMealPlanInput>
    where?: ShoppingListWhereInput
  }

  export type ShoppingListUpdateToOneWithWhereWithoutMealPlanInput = {
    where?: ShoppingListWhereInput
    data: XOR<ShoppingListUpdateWithoutMealPlanInput, ShoppingListUncheckedUpdateWithoutMealPlanInput>
  }

  export type ShoppingListUpdateWithoutMealPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShoppingListsNestedInput
    items?: ShoppingListItemUpdateManyWithoutShoppingListNestedInput
  }

  export type ShoppingListUncheckedUpdateWithoutMealPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShoppingListItemUncheckedUpdateManyWithoutShoppingListNestedInput
  }

  export type MealPlanCreateWithoutMealsInput = {
    id?: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMealPlansInput
    shoppingList?: ShoppingListCreateNestedOneWithoutMealPlanInput
  }

  export type MealPlanUncheckedCreateWithoutMealsInput = {
    id?: string
    userId: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    shoppingList?: ShoppingListUncheckedCreateNestedOneWithoutMealPlanInput
  }

  export type MealPlanCreateOrConnectWithoutMealsInput = {
    where: MealPlanWhereUniqueInput
    create: XOR<MealPlanCreateWithoutMealsInput, MealPlanUncheckedCreateWithoutMealsInput>
  }

  export type RecipeCreateWithoutMealPlanItemsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutMealPlanItemsInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutMealPlanItemsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutMealPlanItemsInput, RecipeUncheckedCreateWithoutMealPlanItemsInput>
  }

  export type MealPlanUpsertWithoutMealsInput = {
    update: XOR<MealPlanUpdateWithoutMealsInput, MealPlanUncheckedUpdateWithoutMealsInput>
    create: XOR<MealPlanCreateWithoutMealsInput, MealPlanUncheckedCreateWithoutMealsInput>
    where?: MealPlanWhereInput
  }

  export type MealPlanUpdateToOneWithWhereWithoutMealsInput = {
    where?: MealPlanWhereInput
    data: XOR<MealPlanUpdateWithoutMealsInput, MealPlanUncheckedUpdateWithoutMealsInput>
  }

  export type MealPlanUpdateWithoutMealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMealPlansNestedInput
    shoppingList?: ShoppingListUpdateOneWithoutMealPlanNestedInput
  }

  export type MealPlanUncheckedUpdateWithoutMealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shoppingList?: ShoppingListUncheckedUpdateOneWithoutMealPlanNestedInput
  }

  export type RecipeUpsertWithoutMealPlanItemsInput = {
    update: XOR<RecipeUpdateWithoutMealPlanItemsInput, RecipeUncheckedUpdateWithoutMealPlanItemsInput>
    create: XOR<RecipeCreateWithoutMealPlanItemsInput, RecipeUncheckedCreateWithoutMealPlanItemsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutMealPlanItemsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutMealPlanItemsInput, RecipeUncheckedUpdateWithoutMealPlanItemsInput>
  }

  export type RecipeUpdateWithoutMealPlanItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutMealPlanItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type UserCreateWithoutShoppingListsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionCreateNestedManyWithoutUserInput
    allergies?: UserAllergyCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    abTests?: ABTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShoppingListsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionUncheckedCreateNestedManyWithoutUserInput
    allergies?: UserAllergyUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    abTests?: ABTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShoppingListsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShoppingListsInput, UserUncheckedCreateWithoutShoppingListsInput>
  }

  export type MealPlanCreateWithoutShoppingListInput = {
    id?: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMealPlansInput
    meals?: MealPlanItemCreateNestedManyWithoutMealPlanInput
  }

  export type MealPlanUncheckedCreateWithoutShoppingListInput = {
    id?: string
    userId: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    meals?: MealPlanItemUncheckedCreateNestedManyWithoutMealPlanInput
  }

  export type MealPlanCreateOrConnectWithoutShoppingListInput = {
    where: MealPlanWhereUniqueInput
    create: XOR<MealPlanCreateWithoutShoppingListInput, MealPlanUncheckedCreateWithoutShoppingListInput>
  }

  export type ShoppingListItemCreateWithoutShoppingListInput = {
    id?: string
    name: string
    amount: number
    unit: string
    category?: string | null
    purchased?: boolean
    estimatedPrice?: number | null
  }

  export type ShoppingListItemUncheckedCreateWithoutShoppingListInput = {
    id?: string
    name: string
    amount: number
    unit: string
    category?: string | null
    purchased?: boolean
    estimatedPrice?: number | null
  }

  export type ShoppingListItemCreateOrConnectWithoutShoppingListInput = {
    where: ShoppingListItemWhereUniqueInput
    create: XOR<ShoppingListItemCreateWithoutShoppingListInput, ShoppingListItemUncheckedCreateWithoutShoppingListInput>
  }

  export type ShoppingListItemCreateManyShoppingListInputEnvelope = {
    data: ShoppingListItemCreateManyShoppingListInput | ShoppingListItemCreateManyShoppingListInput[]
  }

  export type UserUpsertWithoutShoppingListsInput = {
    update: XOR<UserUpdateWithoutShoppingListsInput, UserUncheckedUpdateWithoutShoppingListsInput>
    create: XOR<UserCreateWithoutShoppingListsInput, UserUncheckedCreateWithoutShoppingListsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShoppingListsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShoppingListsInput, UserUncheckedUpdateWithoutShoppingListsInput>
  }

  export type UserUpdateWithoutShoppingListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    abTests?: ABTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutShoppingListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    abTests?: ABTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MealPlanUpsertWithoutShoppingListInput = {
    update: XOR<MealPlanUpdateWithoutShoppingListInput, MealPlanUncheckedUpdateWithoutShoppingListInput>
    create: XOR<MealPlanCreateWithoutShoppingListInput, MealPlanUncheckedCreateWithoutShoppingListInput>
    where?: MealPlanWhereInput
  }

  export type MealPlanUpdateToOneWithWhereWithoutShoppingListInput = {
    where?: MealPlanWhereInput
    data: XOR<MealPlanUpdateWithoutShoppingListInput, MealPlanUncheckedUpdateWithoutShoppingListInput>
  }

  export type MealPlanUpdateWithoutShoppingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMealPlansNestedInput
    meals?: MealPlanItemUpdateManyWithoutMealPlanNestedInput
  }

  export type MealPlanUncheckedUpdateWithoutShoppingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: MealPlanItemUncheckedUpdateManyWithoutMealPlanNestedInput
  }

  export type ShoppingListItemUpsertWithWhereUniqueWithoutShoppingListInput = {
    where: ShoppingListItemWhereUniqueInput
    update: XOR<ShoppingListItemUpdateWithoutShoppingListInput, ShoppingListItemUncheckedUpdateWithoutShoppingListInput>
    create: XOR<ShoppingListItemCreateWithoutShoppingListInput, ShoppingListItemUncheckedCreateWithoutShoppingListInput>
  }

  export type ShoppingListItemUpdateWithWhereUniqueWithoutShoppingListInput = {
    where: ShoppingListItemWhereUniqueInput
    data: XOR<ShoppingListItemUpdateWithoutShoppingListInput, ShoppingListItemUncheckedUpdateWithoutShoppingListInput>
  }

  export type ShoppingListItemUpdateManyWithWhereWithoutShoppingListInput = {
    where: ShoppingListItemScalarWhereInput
    data: XOR<ShoppingListItemUpdateManyMutationInput, ShoppingListItemUncheckedUpdateManyWithoutShoppingListInput>
  }

  export type ShoppingListItemScalarWhereInput = {
    AND?: ShoppingListItemScalarWhereInput | ShoppingListItemScalarWhereInput[]
    OR?: ShoppingListItemScalarWhereInput[]
    NOT?: ShoppingListItemScalarWhereInput | ShoppingListItemScalarWhereInput[]
    id?: StringFilter<"ShoppingListItem"> | string
    shoppingListId?: StringFilter<"ShoppingListItem"> | string
    name?: StringFilter<"ShoppingListItem"> | string
    amount?: FloatFilter<"ShoppingListItem"> | number
    unit?: StringFilter<"ShoppingListItem"> | string
    category?: StringNullableFilter<"ShoppingListItem"> | string | null
    purchased?: BoolFilter<"ShoppingListItem"> | boolean
    estimatedPrice?: FloatNullableFilter<"ShoppingListItem"> | number | null
  }

  export type ShoppingListCreateWithoutItemsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShoppingListsInput
    mealPlan?: MealPlanCreateNestedOneWithoutShoppingListInput
  }

  export type ShoppingListUncheckedCreateWithoutItemsInput = {
    id?: string
    userId: string
    mealPlanId?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShoppingListCreateOrConnectWithoutItemsInput = {
    where: ShoppingListWhereUniqueInput
    create: XOR<ShoppingListCreateWithoutItemsInput, ShoppingListUncheckedCreateWithoutItemsInput>
  }

  export type ShoppingListUpsertWithoutItemsInput = {
    update: XOR<ShoppingListUpdateWithoutItemsInput, ShoppingListUncheckedUpdateWithoutItemsInput>
    create: XOR<ShoppingListCreateWithoutItemsInput, ShoppingListUncheckedCreateWithoutItemsInput>
    where?: ShoppingListWhereInput
  }

  export type ShoppingListUpdateToOneWithWhereWithoutItemsInput = {
    where?: ShoppingListWhereInput
    data: XOR<ShoppingListUpdateWithoutItemsInput, ShoppingListUncheckedUpdateWithoutItemsInput>
  }

  export type ShoppingListUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShoppingListsNestedInput
    mealPlan?: MealPlanUpdateOneWithoutShoppingListNestedInput
  }

  export type ShoppingListUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mealPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutFavoriteRecipesInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionCreateNestedManyWithoutUserInput
    allergies?: UserAllergyCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    abTests?: ABTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoriteRecipesInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionUncheckedCreateNestedManyWithoutUserInput
    allergies?: UserAllergyUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    abTests?: ABTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoriteRecipesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoriteRecipesInput, UserUncheckedCreateWithoutFavoriteRecipesInput>
  }

  export type RecipeCreateWithoutFavoritesInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutFavoritesInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutFavoritesInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutFavoritesInput, RecipeUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoriteRecipesInput = {
    update: XOR<UserUpdateWithoutFavoriteRecipesInput, UserUncheckedUpdateWithoutFavoriteRecipesInput>
    create: XOR<UserCreateWithoutFavoriteRecipesInput, UserUncheckedCreateWithoutFavoriteRecipesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoriteRecipesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoriteRecipesInput, UserUncheckedUpdateWithoutFavoriteRecipesInput>
  }

  export type UserUpdateWithoutFavoriteRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    abTests?: ABTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoriteRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    abTests?: ABTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecipeUpsertWithoutFavoritesInput = {
    update: XOR<RecipeUpdateWithoutFavoritesInput, RecipeUncheckedUpdateWithoutFavoritesInput>
    create: XOR<RecipeCreateWithoutFavoritesInput, RecipeUncheckedCreateWithoutFavoritesInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutFavoritesInput, RecipeUncheckedUpdateWithoutFavoritesInput>
  }

  export type RecipeUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionCreateNestedManyWithoutUserInput
    allergies?: UserAllergyCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
    abTests?: ABTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionUncheckedCreateNestedManyWithoutUserInput
    allergies?: UserAllergyUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListUncheckedCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
    abTests?: ABTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
    abTests?: ABTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUncheckedUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
    abTests?: ABTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFeedbacksInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionCreateNestedManyWithoutUserInput
    allergies?: UserAllergyCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    abTests?: ABTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionUncheckedCreateNestedManyWithoutUserInput
    allergies?: UserAllergyUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListUncheckedCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    abTests?: ABTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbacksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
  }

  export type RecipeCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    name: string
    description?: string | null
    servings?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    prepTimeMinutes: number
    cookTimeMinutes: number
    totalTimeMinutes: number
    complexity?: number
    costTier?: string
    requiredAppliances?: string
    goalTags?: string
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: RecipeInstructionUncheckedCreateNestedManyWithoutRecipeInput
    medicalTags?: RecipeMedicalTagUncheckedCreateNestedManyWithoutRecipeInput
    dietaryTags?: RecipeDietaryTagUncheckedCreateNestedManyWithoutRecipeInput
    practicalTags?: RecipePracticalTagUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalTags?: RecipeNutritionalTagUncheckedCreateNestedManyWithoutRecipeInput
    spiceBlends?: RecipeSpiceBlendUncheckedCreateNestedManyWithoutRecipeInput
    nutritionalInfo?: NutritionalInfoUncheckedCreateNestedOneWithoutRecipeInput
    favorites?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutRecipeInput
    mealPlanItems?: MealPlanItemUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutFeedbacksInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutFeedbacksInput, RecipeUncheckedCreateWithoutFeedbacksInput>
  }

  export type UserUpsertWithoutFeedbacksInput = {
    update: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    abTests?: ABTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUncheckedUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    abTests?: ABTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecipeUpsertWithoutFeedbacksInput = {
    update: XOR<RecipeUpdateWithoutFeedbacksInput, RecipeUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<RecipeCreateWithoutFeedbacksInput, RecipeUncheckedCreateWithoutFeedbacksInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutFeedbacksInput, RecipeUncheckedUpdateWithoutFeedbacksInput>
  }

  export type RecipeUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    servings?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prepTimeMinutes?: IntFieldUpdateOperationsInput | number
    cookTimeMinutes?: IntFieldUpdateOperationsInput | number
    totalTimeMinutes?: IntFieldUpdateOperationsInput | number
    complexity?: IntFieldUpdateOperationsInput | number
    costTier?: StringFieldUpdateOperationsInput | string
    requiredAppliances?: StringFieldUpdateOperationsInput | string
    goalTags?: StringFieldUpdateOperationsInput | string
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: RecipeInstructionUncheckedUpdateManyWithoutRecipeNestedInput
    medicalTags?: RecipeMedicalTagUncheckedUpdateManyWithoutRecipeNestedInput
    dietaryTags?: RecipeDietaryTagUncheckedUpdateManyWithoutRecipeNestedInput
    practicalTags?: RecipePracticalTagUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalTags?: RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeNestedInput
    spiceBlends?: RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeNestedInput
    nutritionalInfo?: NutritionalInfoUncheckedUpdateOneWithoutRecipeNestedInput
    favorites?: UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeNestedInput
    mealPlanItems?: MealPlanItemUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type UserCreateWithoutAbTestsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionCreateNestedManyWithoutUserInput
    allergies?: UserAllergyCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAbTestsInput = {
    id?: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    primaryGoal?: $Enums.DietaryGoal | null
    preferencesJson?: string | null
    healthConditions?: UserHealthConditionUncheckedCreateNestedManyWithoutUserInput
    allergies?: UserAllergyUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    mealPlans?: MealPlanUncheckedCreateNestedManyWithoutUserInput
    shoppingLists?: ShoppingListUncheckedCreateNestedManyWithoutUserInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedOneWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAbTestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAbTestsInput, UserUncheckedCreateWithoutAbTestsInput>
  }

  export type UserUpsertWithoutAbTestsInput = {
    update: XOR<UserUpdateWithoutAbTestsInput, UserUncheckedUpdateWithoutAbTestsInput>
    create: XOR<UserCreateWithoutAbTestsInput, UserUncheckedCreateWithoutAbTestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAbTestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAbTestsInput, UserUncheckedUpdateWithoutAbTestsInput>
  }

  export type UserUpdateWithoutAbTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAbTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    primaryGoal?: NullableEnumDietaryGoalFieldUpdateOperationsInput | $Enums.DietaryGoal | null
    preferencesJson?: NullableStringFieldUpdateOperationsInput | string | null
    healthConditions?: UserHealthConditionUncheckedUpdateManyWithoutUserNestedInput
    allergies?: UserAllergyUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    mealPlans?: MealPlanUncheckedUpdateManyWithoutUserNestedInput
    shoppingLists?: ShoppingListUncheckedUpdateManyWithoutUserNestedInput
    favoriteRecipes?: UserFavoriteRecipeUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateOneWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserHealthConditionCreateManyUserInput = {
    id?: string
    healthConditionId: string
    severity?: $Enums.Severity
    diagnosedDate?: Date | string | null
  }

  export type UserAllergyCreateManyUserInput = {
    id?: string
    allergenId: string
    severity?: $Enums.Severity
  }

  export type MealPlanCreateManyUserInput = {
    id?: string
    name: string
    weekStartDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShoppingListCreateManyUserInput = {
    id?: string
    mealPlanId?: string | null
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFavoriteRecipeCreateManyUserInput = {
    id?: string
    recipeId: string
    addedAt?: Date | string
  }

  export type FeedbackCreateManyUserInput = {
    id?: string
    recipeId: string
    rating: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type ABTestCreateManyUserInput = {
    id?: string
    feature: string
    variant: string
    timestamp?: Date | string
  }

  export type UserHealthConditionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthCondition?: HealthConditionUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserHealthConditionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthConditionId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserHealthConditionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthConditionId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAllergyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    allergen?: AllergenUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserAllergyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    allergenId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
  }

  export type UserAllergyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    allergenId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
  }

  export type MealPlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: MealPlanItemUpdateManyWithoutMealPlanNestedInput
    shoppingList?: ShoppingListUpdateOneWithoutMealPlanNestedInput
  }

  export type MealPlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meals?: MealPlanItemUncheckedUpdateManyWithoutMealPlanNestedInput
    shoppingList?: ShoppingListUncheckedUpdateOneWithoutMealPlanNestedInput
  }

  export type MealPlanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShoppingListUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mealPlan?: MealPlanUpdateOneWithoutShoppingListNestedInput
    items?: ShoppingListItemUpdateManyWithoutShoppingListNestedInput
  }

  export type ShoppingListUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ShoppingListItemUncheckedUpdateManyWithoutShoppingListNestedInput
  }

  export type ShoppingListUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteRecipeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: RecipeUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type UserFavoriteRecipeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteRecipeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: RecipeUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    variant?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserApplianceCreateManyUserPreferencesInput = {
    id?: string
    applianceId: string
    usageFrequency?: number
  }

  export type UserApplianceUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
    appliance?: ApplianceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserApplianceUncheckedUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    applianceId?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type UserApplianceUncheckedUpdateManyWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    applianceId?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type UserHealthConditionCreateManyHealthConditionInput = {
    id?: string
    userId: string
    severity?: $Enums.Severity
    diagnosedDate?: Date | string | null
  }

  export type UserHealthConditionUpdateWithoutHealthConditionInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutHealthConditionsNestedInput
  }

  export type UserHealthConditionUncheckedUpdateWithoutHealthConditionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserHealthConditionUncheckedUpdateManyWithoutHealthConditionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAllergyCreateManyAllergenInput = {
    id?: string
    userId: string
    severity?: $Enums.Severity
  }

  export type UserAllergyUpdateWithoutAllergenInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    user?: UserUpdateOneRequiredWithoutAllergiesNestedInput
  }

  export type UserAllergyUncheckedUpdateWithoutAllergenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
  }

  export type UserAllergyUncheckedUpdateManyWithoutAllergenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
  }

  export type UserApplianceCreateManyApplianceInput = {
    id?: string
    userPreferencesId: string
    usageFrequency?: number
  }

  export type UserApplianceUpdateWithoutApplianceInput = {
    id?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
    userPreferences?: UserPreferencesUpdateOneRequiredWithoutAppliancesNestedInput
  }

  export type UserApplianceUncheckedUpdateWithoutApplianceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPreferencesId?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type UserApplianceUncheckedUpdateManyWithoutApplianceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userPreferencesId?: StringFieldUpdateOperationsInput | string
    usageFrequency?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeSpiceBlendCreateManySpiceBlendInput = {
    id?: string
    recipeId: string
    amountGrams: number
  }

  export type RecipeSpiceBlendUpdateWithoutSpiceBlendInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutSpiceBlendsNestedInput
  }

  export type RecipeSpiceBlendUncheckedUpdateWithoutSpiceBlendInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeSpiceBlendUncheckedUpdateManyWithoutSpiceBlendInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeIngredientCreateManyRecipeInput = {
    id?: string
    name: string
    amount: number
    unit: string
    notes?: string | null
  }

  export type RecipeInstructionCreateManyRecipeInput = {
    id?: string
    stepNumber: number
    instruction: string
  }

  export type RecipeMedicalTagCreateManyRecipeInput = {
    id?: string
    medicalTagId: string
  }

  export type RecipeDietaryTagCreateManyRecipeInput = {
    id?: string
    dietaryTagId: string
  }

  export type RecipePracticalTagCreateManyRecipeInput = {
    id?: string
    practicalTagId: string
  }

  export type RecipeNutritionalTagCreateManyRecipeInput = {
    id?: string
    nutritionalTagId: string
  }

  export type RecipeSpiceBlendCreateManyRecipeInput = {
    id?: string
    spiceBlendId: string
    amountGrams: number
  }

  export type UserFavoriteRecipeCreateManyRecipeInput = {
    id?: string
    userId: string
    addedAt?: Date | string
  }

  export type MealPlanItemCreateManyRecipeInput = {
    id?: string
    mealPlanId: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings?: number
  }

  export type FeedbackCreateManyRecipeInput = {
    id?: string
    userId: string
    rating: number
    notes?: string | null
    timestamp?: Date | string
  }

  export type RecipeIngredientUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeIngredientUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeInstructionUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeInstructionUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeInstructionUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    instruction?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeMedicalTagUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalTag?: MedicalTagUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeMedicalTagUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeMedicalTagUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeDietaryTagUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dietaryTag?: DietaryTagUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeDietaryTagUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dietaryTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeDietaryTagUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dietaryTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipePracticalTagUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    practicalTag?: PracticalTagUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipePracticalTagUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    practicalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipePracticalTagUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    practicalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeNutritionalTagUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nutritionalTag?: NutritionalTagUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeNutritionalTagUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nutritionalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeNutritionalTagUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nutritionalTagId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeSpiceBlendUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
    spiceBlend?: SpiceBlendUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeSpiceBlendUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    spiceBlendId?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
  }

  export type RecipeSpiceBlendUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    spiceBlendId?: StringFieldUpdateOperationsInput | string
    amountGrams?: FloatFieldUpdateOperationsInput | number
  }

  export type UserFavoriteRecipeUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoriteRecipesNestedInput
  }

  export type UserFavoriteRecipeUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteRecipeUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MealPlanItemUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
    mealPlan?: MealPlanUpdateOneRequiredWithoutMealsNestedInput
  }

  export type MealPlanItemUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealPlanId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
  }

  export type MealPlanItemUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    mealPlanId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
  }

  export type FeedbackUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeMedicalTagCreateManyMedicalTagInput = {
    id?: string
    recipeId: string
  }

  export type RecipeMedicalTagUpdateWithoutMedicalTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutMedicalTagsNestedInput
  }

  export type RecipeMedicalTagUncheckedUpdateWithoutMedicalTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeMedicalTagUncheckedUpdateManyWithoutMedicalTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeDietaryTagCreateManyDietaryTagInput = {
    id?: string
    recipeId: string
  }

  export type RecipeDietaryTagUpdateWithoutDietaryTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutDietaryTagsNestedInput
  }

  export type RecipeDietaryTagUncheckedUpdateWithoutDietaryTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeDietaryTagUncheckedUpdateManyWithoutDietaryTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipePracticalTagCreateManyPracticalTagInput = {
    id?: string
    recipeId: string
  }

  export type RecipePracticalTagUpdateWithoutPracticalTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutPracticalTagsNestedInput
  }

  export type RecipePracticalTagUncheckedUpdateWithoutPracticalTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipePracticalTagUncheckedUpdateManyWithoutPracticalTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeNutritionalTagCreateManyNutritionalTagInput = {
    id?: string
    recipeId: string
  }

  export type RecipeNutritionalTagUpdateWithoutNutritionalTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutNutritionalTagsNestedInput
  }

  export type RecipeNutritionalTagUncheckedUpdateWithoutNutritionalTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeNutritionalTagUncheckedUpdateManyWithoutNutritionalTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type MealPlanItemCreateManyMealPlanInput = {
    id?: string
    recipeId: string
    dayOfWeek: $Enums.DayOfWeek
    mealType: $Enums.MealType
    servings?: number
  }

  export type MealPlanItemUpdateWithoutMealPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutMealPlanItemsNestedInput
  }

  export type MealPlanItemUncheckedUpdateWithoutMealPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
  }

  export type MealPlanItemUncheckedUpdateManyWithoutMealPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: EnumDayOfWeekFieldUpdateOperationsInput | $Enums.DayOfWeek
    mealType?: EnumMealTypeFieldUpdateOperationsInput | $Enums.MealType
    servings?: IntFieldUpdateOperationsInput | number
  }

  export type ShoppingListItemCreateManyShoppingListInput = {
    id?: string
    name: string
    amount: number
    unit: string
    category?: string | null
    purchased?: boolean
    estimatedPrice?: number | null
  }

  export type ShoppingListItemUpdateWithoutShoppingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    purchased?: BoolFieldUpdateOperationsInput | boolean
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ShoppingListItemUncheckedUpdateWithoutShoppingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    purchased?: BoolFieldUpdateOperationsInput | boolean
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ShoppingListItemUncheckedUpdateManyWithoutShoppingListInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    purchased?: BoolFieldUpdateOperationsInput | boolean
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}